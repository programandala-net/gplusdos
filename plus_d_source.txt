###### 0000-restart.html ######
###### 0000-restart.html ######


 ____________________________
|Previous|Next|Contents|Index|
The restart routines

THE 'POWER UP RESET' RESTART
When the Spectrum is turned on or the reset button is pressed, the +D ROM is
paged in at
address 0, i.e. the routine listed here is executed.

0000 POWER_UP   NOP
0001            LD   BC,#0101
0004            NOP
0005            JP   #0533,POWER_UP2     Jump to main routine.

THE 'USE G+DOS' RESTART
This is the main entry point to the +D system; it is paged in when the Z80
reaches
address #0008, that is, the address of the 'main' ROM 'ERROR' routine.

0008 START      LD   HL,(23645)          The address reached by the interpreter
000B            LD   (23647),HL          (CH_ADD) is copied to the error
pointer
000E            JR   #0013,START2        (X_PTR) before proceeding.

THE 'CALL A MAIN ROM ROUTINE' RESTART
This routine allows for a subroutine in the 'main' ROM to be called from the
+D system. It can be called by using a RST #10 instruction, followed by the
address of the 'main' ROM subroutine.

0010 CALBAS     JP   #04A6,CALBAS_2      Jump forward.

THE 'START_2' ROUTINE

0013 START2     JP   #013B,START_3       Continue with the +D systems main
                                         entry routine.
0016            DEFB #00,#00             Unused locations.

THE 'FLAGS ADDRESS' RESTART
This routine is used by the -BIT- routines at address #15F4, the original HL is
saved
and the flags address is loaded into HL.

0018 F_ADDR     EX   (SP),HL             Exchange RETurn address and HL.
0019            PUSH HL                  Re-stack RETurn address.
001A            LD   HL,#3ACF            Address of FLAGS3.
001D            RET
001E            DEFB #00,#00             Unused locations.

THE '+D ERROR' RESTART
A RST #20 followed by an one-byte error code will print the appropriate
message, when
the error occurred during the execution of a command code however, the error
code will be
returned in the A register with the Carry flag set.

0020 DISC_ERR   LD   HL,(23645)          The address reached by the interpreter
0023            LD   (23647),HL          is copied to the error pointer before
0026            JR   #0035,DISC_ERR2     proceeding.

THE 'NEXT CHAR' RESTART
This routine gets the next character from a BASIC line, it does this by calling
the RST
#20 routine in the 'main' ROM.

0028 NEXT_C     RST  #10,CALBAS          Call 'main' ROM 'NEXT_CHAR'.
0029            DEFW #0020,NEXT_CHAR
002B            RET

THE 'GET CHAR' ROUTINE
Get character by calling the 'main' ROM restart.

002C GET_C      RST  #10,CALBAS          Call 'main' ROM 'GET_CHAR'.
002D            DEFW #0018,GET_CHAR
002F            RET

THE 'SYNTAX-Z' RESTART
This corresponds to the 'main' ROM 'SYNTAX-Z' subroutine. A test of bit 7 of
FLAGS will
give the Zero flag set during syntax checking, and reset during execution.

0030 SYNTAX_Z   BIT  7,(IY+1)            Test the runtime flag.
0034            RET

THE 'DISC_ERR2' ROUTINE

0035 DISC_ERR2  JP   #182D,D_ERROR       Continue with the +D error routine.

THE 'MASKABLE INTERRUPT' RESTART
While the +D system is paged in, 'nothing' is done during an interrupt.

0038 INT        EI                       Enable interrupts before RETurning.
0039            RET

AN 'UNUSED' SUBROUTINE
This is probably a piece of an older ROM version, it loads HL with (FRAMES) and
CALLs
another unused routine at #02E3.

003A            LD   HL,(23672)          Get the two LSBs of FRAMES.
003D            CALL #02E3
0040            OUT  (231),A             Page-out.
0042            DEFB #B5
0043            DEFB #00,#00,#00

THE 'UNPAGE 128 ROM' SUBROUTINE
This routine pages out the +D system and returns to the 128K ROM at address
#0049. That
address contains a RET instruction so the effect is a jump to BC with the 128K
ROM paged
in.

0046 UNPAGE_BC  PUSH BC                  Stack return address.
0047 UNPAGE_0   OUT  (231),A             Page out +D system.
0049            RET                      ? This statement is not reached from
                                         above.
004A            DEFB #00,#00,#00,#00,#00 Unused locations.

THE 'UNPAGE' SUBROUTINE
This routine pages out the +D system and returns to the 'main' ROM at address
#0052.
That address contains a RET instruction so the effect is a jump to HL with the
'main' ROM
paged in.

004F UNPAGE_HL  PUSH HL                  Stack return address.
0050 UNPAGE_1   OUT  (231),A             Page out +D system.
0052            RET
 ____________________________
|Previous|Next|Contents|Index|
###### 0053-snapshot.html ######
###### 0053-snapshot.html ######


 ____________________________
|Previous|Next|Contents|Index|
The Snapshot routines

THE 'NON-MASKABLE INTERRUPT' CONTINUED
This piece of code determines whether the NMI button was pressed or a return
from a
CALBAS was made.

0053 NMI_1      LD   A,(#3DE5)
0056            CP   #47                 Check if returning from a CALBAS.
0058            JR   NZ,#0060,NMI_2      Jump if not returning from a CALBAS.
005A            XOR  A
005B            LD   (#3DE5),A           Clear CALBAS executing.
005E            POP  AF                  Restore A register and return to the
005F            RET                      calling routine.
0060 NMI_2      LD   A,R
0062            PUSH AF                  Save R register and interrupt status.
0063            JR   #0069,SNAPSHOT
0065            DEFB #00

THE 'NON-MASKABLE INTERRUPT' ROUTINE
This is the third point, from address #0000, at which the +D system is paged
in. It is
reached  either by pressing the 'snapshot' button or when returning from a
CALBAS.

0066 NMI        PUSH AF                  Save A register.
0067            JR   #0053,NMI_1

THE 'SNAPSHOT' ROUTINE
When the 'snapshot' button is pressed this routine is executed. By pressing the
keys 1
or 2 a choice can be made to dump the screen to the printer in small or grey-
scale
format. As soon as the system file is loaded it is possible to make snapshots
to disk
(See #20A1 and further).

0069 SNAPSHOT   LD   (#3FFE),SP          Use 'internal' stack.
006D            LD   SP,#3FFE
0070            LD   A,I
0072            PUSH AF                  Save all registers, starting with I.
0073            PUSH HL
0074            PUSH BC
0075            PUSH DE
0076            EX   AF,AF'              Save alternative registerset.
0077            EXX
0078            PUSH AF
0079            PUSH HL
007A            PUSH BC
007B            PUSH DE
007C            PUSH IX                  Save the index registers.
007E            PUSH IY
0080            DI                       Disable interrupts in case #0066 was
                                         called normally. When a NMI occurs the
                                         Z80 disables interrupts.
0081            LD   HL,#00B1,SNAP_EXIT
0084            PUSH HL                  RETurn address from snapshot.
0085            LD   (#2066),SP          Store current stackpointer at D_ERR_SP
                                         so an error will activate SNAP_EXIT.
0089 SNAP_KEYS  LD   BC,#F7FE            Keyboard port and key 1-5 I/O address.
008C            IN   E,(C)
008E            BIT  0,E                 CASE key OF
0090            JP   Z,#12D2,COPS        1: jump to the smallcopy routine.
0093            BIT  1,E
0095            JP   Z,#133E,COPS2       2: jump to the greyscale routine.
0098            CALL #0527,SYSTEM_Z      System loaded?
009B            CALL Z,#20A1,JSNAP       Yes, then call system snap routine.
009E            INC  A                   END CASE.
009F            AND  #07
00A1            OUT  (C),A               Nice stripes in border.
00A3            LD   B,#FE               CAPS-V I/O address.
00A5            IN   E,(C)
00A7            BIT  2,E
00A9            JR   NZ,#0089,SNAP_KEYS  Test for X, loop if not pressed.
00AB SNAP_KEY1  IN   E,(C)
00AD            BIT  2,E
00AF            JR   Z,#00AB,SNAP_KEY1   Wait until X is released again.

THE 'SNAP_EXIT' ROUTINE
This routine is used to return to the snapshotted program.

00B1 SNAP_EXIT  DI
00B2            LD   HL,#0000            Clear D_ERR_SP.
00B5            LD   (#2066),HL
00B8            CALL #168E,BORD_REST
00BB            LD   SP,#3FEA
00BE            POP  IY                  Restore the index registers.
00C0            POP  IX
00C2            POP  DE                  Restore the alternate registerset.
00C3            POP  BC
00C4            POP  HL
00C5            POP  AF
00C6            EX   AF,AF'
00C7            EXX
00C8            CALL #011D,?_ROMBANK     Determine current 'main' ROM bank.
00CB            JR   NZ,#00F5,SNAP_EX3   Jump if 128K ROM bank.
00CD            CALL #0511,REST_PBUF
00D0            POP  DE                  Restore the registerset.
00D1            POP  BC
00D2            POP  HL
00D3            POP  AF
00D4            LD   I,A
00D6            CP   #00
00D8            JR   Z,#00E0,SNAP_EX1
00DA            CP   #3F                 When the I register doesn't contain
#00
00DC            JR   Z,#00E0,SNAP_EX1    or #3F, it is most likely that the
00DE            IM   2                   interrupt mode is 2.
00E0 SNAP_EX1   LD   SP,(#3FFE)          Restore stack pointer.
00E4            POP  AF
00E5            LD   R,A                 Jump if the interupts were disabled
00E7            JP   PO,#00F1,SNAP_EX2   when 'SNAPSHOT' was entered.
00EA            PUSH HL
00EB            LD   HL,#004F            Otherwise return to snapshotted
program
00EE            JP   #004F,UNPAGE_HL     via 'main' ROM "POP  HL", "POP  AF"
and
                                         "EI".
00F1 SNAP_EX2   POP  AF                  Return to the instruction before which
00F2            JP   #0050,UNPAGE_1      the snapshot occurred.

This piece of code does almost the same as the above. The only difference is
that it
returns to the 128 'main' ROM at a somewhat different address.

00F5 SNAP_EX3   CALL #0511,REST_PBUF
00F8            POP  DE
00F9            POP  BC
00FA            POP  HL
00FB            POP  AF
00FC            LD   I,A
00FE            CP   #00
0100            JR   Z,#0108,SNAP_EX4
0102            CP   #3F
0104            JR   Z,#0108,SNAP_EX4
0106            IM   2
0108 SNAP_EX4   LD   SP,(#3FFE)
010C            POP  AF
010D            LD   R,A
010F            JP   PO,#0119,SNAP_EX5
0112            PUSH BC
0113            LD   BC,#007B
0116            JP   #0046,UNPAGE_BC

0119 SNAP_EX5   POP  AF
011A            JP   #0047,UNPAGE_0

THE 'DETERMINE 128K ROM BANK' SUBROUTINE
This routine determines, by examining the byte at address #0001, which bank of
the 128K
ROM is selected. Because the +D system is currently paged in the 'main' ROM
can't be
accessed directly. So a routine, which pages out the +D, is copied to the
printer buffer.
But first the first 10 bytes of the printer buffer are saved.

011D ?_ROMBANK  LD   HL,23296            Save the 10 bytes needed by the
0120            LD   DE,#3BE6            subroutine in +D RAM.
0123            LD   BC,10
0126            LDIR
0128            LD   HL,#051D,DET_ROM    Copy the subroutine to the freed
bytes.
012B            LD   DE,23296,DET_ROM'
012E            LD   BC,10
0131            LDIR
0133            LD   A,#47               Signal 'CALBAS executing' (the NMI
0135            LD   (#3DE5),A           routine returns immediately).
0138            JP   23296,DET_ROM'      Exit via DET_ROM.
 ____________________________
|Previous|Next|Contents|Index|
###### 013b-control.html ######
###### 013b-control.html ######


 ____________________________
|Previous|Next|Contents|Index|
The control routine

This routine is called from 'START' at #0008, when the +D system is paged in.
It has three main tasks:
- If a disc channel has been requested, it jumps to the required 'input' or
  'output' routine.
- If a hook/command code is used, it jumps to the required routine.
- If an error occurred in the 'main' ROM, it checks whether a +D command was
  used. If so the corresponding routine is called, otherwise a return is made
to
  the 'main' ROM, except when the +D variable ONERR holds a non zero address.
  In that case a CALBAS to that address is made.

013B START_3    LD   (#3DD6),HL          +D's CH_ADD (D_CH_ADD).
013E            LD   (#3E4F),A
0141            POP  HL                  Get RETurn address (usually points to
0142            PUSH HL                  the error code).
0143            PUSH DE

Now see if a +D channel has been requested.

0144            AND  A
0145            LD   DE,#15FE            If a channel has been requested, this
                                         is the RETurn address stored by the
                                         CALL #162C in the 'CALL-SUB'
subroutine
                                         in the Spectrum ROM.
0148            SBC  HL,DE
014A            POP  DE
014B            JR   NZ,#0168,START_4    Jump if no channels have been
requested
014D            LD   HL,#0050,UNPAGE_1   Make UNPAGE_1 RETurn address
0150            PUSH HL

Now see if the channel requested is the "P" channel. The +D "P" channel differs
only
from the Spectrum's in the 'input' and 'output' addresses. For the +D they both
are
#0008. There is no information in the channel on what the +D system's in/output
addresses
are (as with "D" channels). So it has to be handled separately.

0151            PUSH BC
0152            LD   HL,(23631)          Fetch CHANS.
0155            LD   BC,16               Point to "P" channel.
0158            ADD  HL,BC
0159            SBC  HL,DE               DE holds address of requested channel.
015B            POP  BC
015C            JP   Z,#1415,PCHAN_OUT   Jump if +D "P" channel was used.
015F            LD   HL,4                DE holds address of routine pointer-4.
                                         See #15EF in 'main' ROM.
0162            ADD  HL,DE               HL now holds address of routine
pointer
0163            LD   E,(HL)
0164            INC  HL                  Fetch routine address.
0165            LD   D,(HL)
0166            EX   DE,HL               HL now points to the routine.
0167            JP   (HL)                Jump to the appropriate 'input' or
                                         'output' routine.

At this point, the +D has been paged-in by an error in the 'main' ROM or by a
hook/command code. When an error occurred during a CALBAS and D_ERR_SP isn't
zero, the
error has to be handled by the 'main' ROM. If D_ERR_SP is zero, the error is
reported to
the routine which executed a CALBAS.

0168 START_4    LD   A,(#3DE5)           Check if the +D CALLed a Spectrum
016B            CP   #47                 ROM routine.
016D            JR   NZ,#018C,START_5    Jump if it didn't.
016F            XOR  A
0170            LD   (#3ACF),A           Clear CALBAS executing.
0173            POP  HL                  Fetch RETurn address.
0174            RST  #10,CALBAS          This CALL's a LD A,(HL) in the
Spectrum
0175            DEFW #007B               ROM, so the error code is fetched.
0177            LD   (23610),A           Store the error code in ERR_NR.
017A            LD   HL,(#2066)          Fetch D_ERR_SP.
017D            LD   A,H
017E            OR   L                   Jump if D_ERR_SP was zero, that is
when
017F            JP   Z,#04F9,SPEC_ERR1   the 'main' ROM has to handle the
error.
0182            SET  7,(IY+0)            Signal 'Spectrum error'.
0186            LD   A,(23610)           Copy error code in A register.
0189            LD   SP,HL               Clear stack.
018A            SCF                      Signal 'error and exit', someone else
018B            RET                      has to handle the error.

Now it is most likely that the +D has to handle the problem which the 'main'
ROM
couldn't.

018C START_5    POP  HL                  Fetch address of error or hook/command
                                         code (the byte after RST #08).
018D            RST  #10,CALBAS          Fetch the byte.
018E            DEFW #007B
0190            LD   (23610),A           Store it in ERR_NR.
0193            CP   255
0195            JR   NZ,#01B1,START_7    Jump if the error isn't 'OK'.
0197            CALL #0527,SYSTEM_Z      System loaded?
019A            CALL Z,#045A,SYSTEM_OK   Yes, then check if it's OK.
019D            JR   Z,#01AE,START_6     Give 'OK G+DOS' message if so.
019F            BIT  7,(IY+12)           Give the message also if PPC-hi
01A3            JR   Z,#01AE,START_6     indicates line is not in editing area.
01A5            LD   HL,(23641)          Fetch the command from the editing
area
01A8            LD   A,(HL)
01A9            CP   247,"RUN"           Load the system file if the command
01AB            JP   Z,#037B,RUN         is 'RUN'.
01AE START_6    JP   #166C,REP_20

The error code in the A register determines the task to be executed.

01B1 START_7    SUB  27                  Adjust range, hookcodes start at 0
now.
01B3            JR   C,#01CB,START_8     Jump if it isn't a hook or command
code
01B5            CALL #0527,SYSTEM_Z      Jump to the system routine if the
01B8            JP   Z,#209E,JHOOK       system is loaded.
01BB            CP   44                  Give the error 'No G+DOS loaded'
except
01BD            JP   NZ,#167E,REP_29     with command code 71.
01C0            LD   (IY+0),#FF          Clear the error.
01C4            SET  2,(IY+1)
01C8            INC  HL                  Advance return address past the code.
01C9            PUSH HL
01CA            RET

01CB START_8    CP   240                 Jump if the error is
01CD            JR   Z,#01DC,TEST_INPUT  'Nonsense in BASIC'.
01CF            CP   243
01D1            JR   Z,#01DC,TEST_INPUT  Also if it is 'Invalid filename'.
01D3            CP   252
01D5            JR   Z,#01DC,TEST_INPUT  Or 'Invalid stream'.
01D7            CP   230                 Jump to the 'main' ROM error handler
if
01D9            JP   NZ,#04F9,SPEC_ERR1  it isn't 'Variable not found'.
01DC TEST_INPUT BIT  5,(IY+55)           Use 'main' ROM error handler also if
in
01E0            JP   NZ,#04F9,SPEC_ERR1  INPUT mode.
01E3            RST  #30,SYNTAX_Z
01E4            JR   NZ,#01EA,RUNTIME    Jump during RUNtime.
01E6            LD   (IY+12),#FF         Signal 'syntax time' (PPC-hi).

Now a loop is entered to find the line that has produced the error. The routine
used
here is copied from the IF1 and is way ahead of the DISCiPLE's backstepping
routine.

01EA RUNTIME    LD   B,(IY+13)           Statement counter.
01ED            LD   C,0                 Counter of ' " ' characters.
01EF            BIT  7,(IY+12)           Jump forward if the line is in the
01F3            JR   Z,#01FF,PROG_LINE   program area.
01F5            PUSH BC                  Save counters.
01F6            RST  #10,CALBAS          Call main ROM 'E-LINE-NO' (it fetches
01F7            DEFW #19FB,E_LINE_NO     the number of the line in the editing
                                         area, but is actually used to update
                                         CH-ADD to the 1st char.in the line).
01F9            POP  BC                  Restore counters.
01FA            RST  #10,CALBAS          Update HL to the first character in
01FB            DEFW #0018,GET_CHAR      the line.
01FD            JR   #023F,S_STAT

01FF PROG_LINE  LD   HL,(23635)          (PROG), start of the program area.
0202 SC_L_LOOP  LD   A,(IY+12)           Give error if the current line number
0205            CP   (HL)                is greater than that of the line to be
0206            JP   C,#1644,REP_0       searched for.
0209            INC  HL                  Point to low byte of line number.
020A            JR   NZ,#0213,LINE_LEN   Jump if not at expected line.
020C            LD   A,(23621)           Compare also the low byte of the line
020F            CP   (HL)                numbers (PPC-lo).
0210            JP   C,#1644,REP_0       Give error if the line doesn't exist.
0213 LINE_LEN   INC  HL                  Fetch line length.
0214            LD   E,(HL)
0215            INC  HL
0216            LD   D,(HL)
0217            INC  HL
0218            JR   Z,#023F,S_STAT      Jump forward if the line is found.
021A            ADD  HL,DE
021B            JR   #0202,SC_L_LOOP     Next line.

021D SKIP_NUM   LD   DE,6                Length of a floating point number
0220            ADD  HL,DE               and marker.

This loop advances HL until it points to the start of the statement that has
produced
the error.

0221 EACH_ST    LD   A,(HL)              Get a character from the line.
0222            CP   #0E
0224            JR   Z,#021D,SKIP_NUM    Skip over floating point numbers.
0226            INC  HL
0227            CP   34,"""
0229            JR   NZ,#022C,CHKEND
022B            DEC  C                   Decrement counter for each ' " '.
022C CHKEND     CP   58,":"
022E            JR   Z,#0234,CHKEVEN     A colon or the 'THEN' keyword mark
0230            CP   203,"THEN"          the beginning of a new statement, but
0232            JR   NZ,#0238,CHKEND_L   only if they occur out of a string.
0234 CHKEVEN    BIT  0,C                 I.e. the number of quotes found must
0236            JR   Z,#023F,S_STAT      be even.
0238 CHKEND_L   CP   13
023A            JR   NZ,#0221,EACH_ST    Repeat until 'end of line'.
023C            JP   #1644,REP_0         An uneven number of quotes is
                                         unacceptable.
023F S_STAT     DJNZ #0221,EACH_ST       Loop for every statement in the line.
0241            DEC  HL                  Update CH_ADD to the address of
0242            LD   (23645),HL          the statement found.
0245            RST  #30,SYNTAX_Z
0246            JR   NZ,#027A,CL_WORK    Jump forward during runtime.
0248            BIT  7,(IY+12)           Give an error if the line is not in
the
024C            JP   Z,#04F0,SPEC_ERR    editing area.

The final loop is made during syntax checking, for removing all 6-byte floating
point
numbers inserted in the line by the 'main' ROM interpreter.

024F            DEC  HL                  Balance the "INC HL" below.
0250            LD   C,0                 ???? C isn't used anymore.
0252 RCLM_NUM   INC  HL                  Point to next character.
0253            LD   A,(HL)
0254            CP   #0E                 Is it a 'number' marker ?
0256            JR   NZ,#0275,NEXT_NUM   Jump if not.
0258            PUSH BC                  ???? again.
0259            LD   BC,6
025C            RST  #10,CALBAS          Reclaim the 6 bytes forming a number
025D            DEFW #19E8,RECLAIM_2     and the 'number marker'.
025F            PUSH HL
0260            LD   DE,(#3DD6)          Fetch D_CH_ADD.
0264            AND  A                   Jump if the number bytes reclaimed
were
0265            SBC  HL,DE               after the character pointed to by
0267            JR   NC,#0273,NXT_1      D_CH_ADD.
0269            EX   DE,HL               Otherwise D_CH_ADD has to be updated.
026A            LD   BC,6
026D            AND  A                   The character pointed by D_CH_ADD has
026E            SBC  HL,BC               been moved '6' bytes down.
0270            LD   (#3DD6),HL          Update D_CH_ADD.
0273 NXT_1      POP  HL
0274            POP  BC
0275 NEXT_NUM   LD   A,(HL)
0276            CP   13
0278            JR   NZ,#0252,RCLM_NUM   Again repeat until 'end of line'.

Now the working area is cleared. The two commands 'RUN' and 'POKE' are handled
by the +D
ROM, the G+DOS system should handle all other commands.

027A CL_WORK    RST  #10,CALBAS          Clear Spectrum work areas by calling
027B            DEFW #16BF,SET_WORK      'SET_WORK' in 'main' ROM.
027D            RST  #28,NEXT_C
027E            CP   244,"POKE"
0280            JP   Z,#04C7,POKE@       Jump with 'POKE' command.
0283            CALL #0527,SYSTEM_Z      The system routine is called when
0286            CALL Z,#20A4,JCTRL       present.
0289            JP   #04F0,SPEC_ERR      Otherwise give an error.

028C 2843            JR   Z,L82D1
 ____________________________
|Previous|Next|Contents|Index|
###### 028e-periodic.html ######
###### 028e-periodic.html ######


 ____________________________
|Previous|Next|Contents|Index|
The periodic routines &
   The +D default variables and tables

THE 'KEY-SCAN' ROUTINE
This is another entry point to the +D system; it is paged in when the Z80
reaches
address #028E, that is, the Spectrum 'KEY-SCAN' routine. So whenever the
Spectrum tries
to scan the keyboard by calling this routine the +D is paged in first.

028E KEYSCAN    LD   L,#2F               Same instruction as in 'main' ROM.
0290            CALL #0296,KEYSC_1
0293            NOP                      Page-out into the 'main' ROM
0294            OUT  (231),A             'KEY_SCAN'.

0296 KEYSC_1    CALL #02A2,KEYSC_2
0299            LD   L,#2F               Restore registers for 'main' ROM
029B            LD   DE,#FFFF            'KEY-SCAN'
029E            LD   BC,#FEFE
02A1            RET

02A2 KEYSC_2    LD   A,(#3DE5)
02A5            CP   #47                 If a CALBAS was under execution return
02A7            RET  Z                   immediately to 'main' ROM 'KEY-SCAN'.
02A8            LD   A,(#3DE4)
02AB            CP   #58
02AD            JP   Z,#040C,TAKE_PRTR   Jump if this is a minimal system.
02B0            CP   #44                 Initialize the minimal system if there
02B2            JR   NZ,NOSYS            is no system file loaded.
02B4            CALL #2098,JKSCAN        Otherwise call the appropriate system
02B7            JP   #040C,TAKE_PRTR     routine and exit refreshing the 'P'
                                         channel.

02BA NOSYS      LD   HL,#2000
02BD            LD   BC,8192             Clear the 8K RAM.
02C0 CLR_RAM    LD   (HL),0
02C2            INC  HL
02C3            DEC  BC
02C4            LD   A,B
02C5            OR   C
02C6            JR   NZ,#02C0,CLR_RAM
02C8            OUT  (239),A             Clear control port.
02CA            OUT  (247),A             Clear printer port.
02CC            LD   HL,#02F2            Copy the default system variables and
02CF            LD   DE,#2000            settings to RAM.
02D2            LD   BC,104
02D5            LDIR
02D7            LD   A,#58               Signal 'minimal' system
02D9            LD   (#3DE4),A
02DC            LD   HL,275              Disk buffer offset.
02DF            LD   (#3AD2),HL
02E2            RET

02E3            PUSH BC                  Leftover routine?
02E4            PUSH DE
02E5            PUSH HL
02E6            CALL #02A2,KEYSC_2
02E9            POP  HL
02EA            INC  HL
02EB            LD   (23672),HL
02EE            POP  DE
02EF            POP  BC
02F0            LD   A,H
02F1            RET

THE 'SYSTEM VARIABLES'
These variables hold various default settings for drives etc. They can be
accessed from
BASIC with POKE @p,n. Where p is 0 for RBCC at #2000. The default variables and
system
tables, addresses #02F2-#0359, are copied to #2000 if there is no system file
loaded.

02F2 RBCC       DEFB #00       @0        No flashing borders.
02F3 TRAKS1     DEFB 80+128    @1        Drive 1 80 tracks double sided.
02F4 TRAKS2     DEFB 80+128    @2        Drive 2 80 tracks double sided.
02F5 STPRAT     DEFB 12        @3        "Steprate" 0 msec.
02F6 NSTAT      DEFB 1         @4        Network off.
02F7 WIDTH      DEFB 80        @5        Printer right margin.
02F8 PCODE      DEFB 0         @6        Expand tokens, etc. before printing.
02F9 LSPCE      DEFB 12        @7        Line spacing 12/72 inch.
02FA LFEED      DEFB 0         @8        Number of line feeds after CR 1.
02FB LMARG      DEFB 0         @9        Left margin at 0.
02FC GRAPH      DEFB 1         @10       Print graphic images of some chars.
02FD ZXPNT      DEFB 1         @11       +D printer port not used.
02FE RESERVED   DEFW #0000     @12
0301 ONERR      DEFW #0000     @14       Address of routine called after an
                                         error has occurred.
0303 EVERY_INT  DEFW #0000     @16       Address of routine called at every
                                         interrupt.

THE 'PRINTER CODES' TABLE
Here the default printer control codes are stored.

0304 INIT_PRT   DEFB 13,#80,#80,#80
0308            DEFB #80,#80,#80,#80
030C CHAR_PITCH DEFB 27,"M",#80,#80
0310            DEFB #80,#80,#80,#80
0314 N/72_LSPC  DEFB 27,"A",#80,#80
0318            DEFB #80,#80,#80,#80
031C GRAPH_DPI  DEFB 27,"*",5,#80
0320            DEFB #80,#80,#80,#80
0324 INIT_PRT2  DEFB #80,#80,#80,#80
0328            DEFB #80,#80,#80,#80

THE 'GRAPHIC REPRESENTATION' TABLE
This table consists of the graphic representations of the £, # and (c) signs.
The
'GRAPH' system variable (@10) determines whether the normal code or the graphic
representation is outputted to the printer.

032C £-SIGN     DEFB %00011000
032D            DEFB %00100000
032E            DEFB %00100000
032F            DEFB %01111000
0330            DEFB %00100000
0331            DEFB %00100000
0332            DEFB %01111100
0333            DEFB %00000000

0334 #-SIGN     DEFB %00000000
0335            DEFB %00100100
0336            DEFB %01111110
0337            DEFB %00100100
0338            DEFB %00100100
0339            DEFB %01111110
033A            DEFB %00100100
033B            DEFB %00000000

033C (c)-SIGN     DEFB %01111110
033D            DEFB %10000001
033E            DEFB %10111101
033F            DEFB %10100001
0340            DEFB %10100001
0341            DEFB %10111101
0342            DEFB %10000001
0343            DEFB %01111110

THE 'GREYSCALE' PRINTER CONTROL CODE
This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

0344            DEFB 27,"*",5,64
0348            DEFB 2,#80,#80,#80

THE 'GREYSCALE' TABLE
This table consists of three times three bytes of greyscale info. Each screen
pixel is
converted into 3x3 printer dots during greyscale printing. The printer dots are
ordered
as follows: The first dot row is produced from the first three bytes by taking
the bit,
which number is corresponding with the colour number, from each of the three
bytes. E.g.
for colour 2 (=red) bit 2 is used. In the same way the second and third dot
rows are
produced from the second and third three bytes respectively.
The following eight 3x3 matrices are produced:

 White  Yellow  Cyan  Green Magenta  Red    Blue  Black
  000    000    100    000    100    010    110    111
  000    010    010    101    111    111    111    111
  000    000    001    000    001    010    011    111

Note that some greytones aren't right. E.g. cyan is darker than green, which
isn't so on
the screen.

                       colour
                      76543210


034C            DEFB %00101011
034D            DEFB %00011111           first row
034E            DEFB %00000001

034F            DEFB %00000111
0350            DEFB %01101111           second row
0351            DEFB %00000111

0352            DEFB %00000001
0353            DEFB %00011111           third
0354            DEFB %00101011

0355 RAM2063    DEFW #1429,P_ALL         Address of 'output' routine for "P".
0357 RAM2065    DEFB #00                 The 'ENTER' flag.
0358 RAM2066    DEFW #0000               D_ERR_SP
 ____________________________
|Previous|Next|Contents|Index|
###### 035a-init.html ######
###### 035a-init.html ######


 ____________________________
|Previous|Next|Contents|Index|
The initialise system routine

THE 'SYSTEM-FILE' NAME
The following 11 bytes form the file description (directory description and
filename) of
a System-file.

035A SYS_DESCR  DEFB 4
035B            DEFM "+SYS*     "

THE '"AUTO*" FILE' UFIA
The following 22 bytes form the UFIA of the autoload file, which is loaded
right after
the system file.

0365 AUTO_UFIA  DEFB #01                 Drive 1
0366            DEFB #00
0367            DEFB #00
0368            DEFB "D"                 Device "D"
0369            DEFB #01                 Dir. entry for BASIC file.
036A            DEFM "AUTO*     "        Name of autoload file.
0374            DEFB #00                 File type is BASIC.
0375            DEFW #FFFF               Max. length.
0377            DEFW #FFFF
0379            DEFW #FFFF

THE 'RUN' COMMAND ROUTINE
The RUN command loads the system file.

037B RUN        SET  7,(IY+10)           Clear the 'jump' signal set by using
                                         the 'RUN' command.
037F            LD   IX,#3AC3
0383            LD   A,1                 Signal 'drive 1 is being used'.
0385            LD   (IX+11),A
0388            LD   A,1                 Set drive 1.
038A            LD   (#3DDA),A           Store it in the control port state.
038D            OUT  (239),A             Activate.
038F            CALL #06B6,REST          Move drive head to track 0.
0392            LD   HL,#035A,SYS_DESCR  Copy the file description to UFIA1.
0395            LD   DE,#3E05
0398            LD   BC,11
039B            LDIR
039D            LD   A,%00001000         Signal 'matching name and directory
                                         description have to be found'.
039F            CALL #09A5,SCAN_CAT      Search for the file.
03A2            JP   NZ,#1652,REP_7      Give 'No "SYSTEM" file' error when
file
                                         not found.
03A5            RST  #10,CALBAS          Clear the whole screen.
03A6            DEFW #0DAF,CL_ALL
03A8            CALL #17A9,MESG_0        Print the 'SYSTEM LOADING' message.
03AB            CALL #0C04,LOAD_1ST      Copy the file description (directory
                                         description and filename) to UFIA2 and
                                         load the first sector of the file into
                                         the disk buffer.
03AE            LD   HL,#3BD6            Copy the file header (the 9 bytes
03B1            LD   DE,#3E29            consisting of filetype, length, etc.)
03B4            LD   BC,9                to UFIA2.
03B7            LDIR
03B9            LD   (IX+13),9           Update the buffer pointer.
03BD            LD   DE,(#3E2A)          Fetch the systemfile's length.
03C1            LD   HL,#2000            Loadaddress is #2000.
03C4            CALL #079E,LOAD_FILE     Load the system.
03C7            LD   A,#44               Load the system.
03C9            LD   (#3DE4),A           Signal 'System loaded'.
03CC            XOR  A
03CD            PUSH AF
03CE            LD   HL,#2080
03D1            LD   BC,#197F            Calculate checksum.
03D4 RUN_CHKSUM POP  AF
03D5            ADD  A,(HL)
03D6            PUSH AF
03D7            INC  HL
03D8            DEC  BC
03D9            LD   A,B
03DA            OR   C
03DB            JR   NZ,#03D4,RUN_CHKSUM
03DD            POP  AF
03DE            LD   (HL),A
03DF            XOR  A
03E0            LD   (#3ACF),A           Clear FLAGS3.
03E3            LD   (#2066),A
03E6            RST  #10,CALBAS          Clear the whole display.
03E7            DEFW #0DAF,CL_ALL
03E9            CALL #040C,TAKE_PRTR     If necessary takeover the "P" channel.
03EC            CALL #209B,JMSG3         Print DOS copyright message.
03EF            CALL #042D,INIT_PRTR     If necessary initialize printer.
03F2            LD   IX,#0365,AUTO_UFIA  Point to autoload file ufia.
03F6            CALL #2095,JHXFER        Transfer UFIA to DFCA.
03F9            LD   A,%00001000         Search for a file with specified name
03FB            CALL #09A5,SCAN_CAT      and type.
03FE            JP   NZ,#166C,REP_20     "O.K. G+DOS" if no autoload file found
0401            CALL #1608,SIGN_4        Signal 'loading'.
0404            JP   #2092,JLOAD         Load the file.
 ____________________________
|Previous|Next|Contents|Index|
###### 0407-misc1.html ######
###### 0407-misc1.html ######


 ____________________________
|Previous|Next|Contents|Index|
Miscalleneous routines I

THE '"P" CHANNEL DATA' TABLE
Here follow the '5' bytes that compose the +D "P" channel.

0407 P_CHANNEL  DEFW #0008
0409            DEFW #0008
040B            DEFB "P"

THE 'TAKEOVER PRINTER' SUBROUTINE
If the printer is to be controlled by the +D system, the following subroutine
copies the
"P" channel data into the channel.

040C TAKE_PRTR  CALL #0527,SYSTEM_Z
040F            CALL Z,#208C,JPRTR
0412            LD   A,(#200B)           (ZXPNT)
0415            BIT  0,A
0417            RET  NZ                  Return if the printer isn't to be
0418            AND  A                   handled by the +D.
0419            CALL NZ,#0433,INIT_PRT1  If necessary initialize printer.
041C            LD   HL,(23631)          Get address of channel data. (CHANS)
041F            LD   BC,15               Offset for channel "P".
0422            ADD  HL,BC
0423            EX   DE,HL
0424            LD   HL,#0407,P_CHANNEL
0427            LD   BC,5
042A            LDIR                     Copy the "P" channel data.
042C            RET

THE 'INIT PRINTER' SUBROUTINE
This subroutine initialises the printer, if it's to be handled by the +D and if
it's
attached, by sending the initialisation codes and the permanent setting codes
as
mentioned in the 'Setup' program.

042D INIT_PRTR  LD   A,(#200B)
0430            BIT  0,A                 Exit if printer not to be handled
0432            RET  NZ                  by +D.
0433 INIT_PRT1  XOR  A
0434            LD   (#200B),A
0437            IN   A,(247)
0439            BIT  7,A
043B            RET  NZ                  Exit if the printer is busy.
043C            LD   DE,#2012,INIT_PRT   Send initialisation codes to printer.
043F            CALL #140B,PO_ESC_SEQ
0442            LD   DE,#201A,CHAR_PITCH Set character pitch.
0445            CALL #140B,PO_ESC_SEQ
0448            LD   DE,#2022,N/72_LSPC  Set line spacing to (#2007)/72 inch.
044B            CALL #140B,PO_ESC_SEQ
044E            LD   A,(#2007)
0451            CALL #15C9,PNTP
0454            LD   DE,#2032,INIT_PRT2  Set other permanent printer settings.
0457            JP   #140B,PO_ESC_SEQ

THE 'CHECK SYSTEM CHECKSUM' ROUTINE
This subroutine calculates the checksum of the system file in RAM. Its is used
to check
if the system isn't corrupted.

045A SYSTEM_OK  XOR  A
045B            PUSH AF                  Calculate checksum.
045C            LD   HL,#2080
045F            LD   BC,#197F
0462 SYS_OK1    POP  AF
0463            ADD  A,(HL)
0464            PUSH AF
0465            INC  HL
0466            DEC  BC
0467            LD   A,B
0468            OR   C
0469            JR   NZ,#0462,SYS_OK1
046B            POP  AF
046C            CP   (HL)                Exit with Zero set if checksums
046D            RET                      match.

THE 'END OF STATEMENT' ROUTINE
After the syntax of the 'new' commands has been checked, a jump is made here to
confirm
that the statement is finished. An error report is given if it isn't finished.
A return
to the calling routine is made only during runtime, otherwise the control
returns to the
'main' ROM interpreter.

046E ST_END     CALL #002C,GET_C         Get current character.
0471            CP   13
0473            JR   Z,#047A,ST_END1     Jump if the statement ends with ENTER.
0475            CP   58,":"              Give an error if statement doesn't end
0477            JP   NZ,#1648,REP_2      with a colon.
047A ST_END1    RST  #30,SYNTAX_Z
047B            RET  NZ                  Return during runtime.

THE 'RETURN TO THE INTERPRETER' ROUTINE
The control is returned to the BASIC interpreter for interpretation of the next
statement.

047C END        LD   SP,(23613)          Clear machine stack. (ERR_SP)
0480            LD   (IY+0),#FF          Clear error code. (ERR_NR)
0484            LD   HL,#1BF4,STMT_NEXT  Return address to 'main' ROM is
0487            RST  #30,SYNTAX_Z        'STMT_NEXT' if syntax is being
checked.
0488            JP   Z,#004F,UNPAGE_HL
048B            CALL #168E,BORD_REST     Restore border color.
048E            CALL #0497,TST_BREAK     Test for BREAK.
0491            LD   HL,#1B7D,STMT_R_1   Return address during runtime is
0494            JP   #004F,UNPAGE_HL     'STMT_R_1'.

THE 'TEST_BREAK' SUBROUTINE
The BREAK key is checked and the appropriate error is given if it is pressed.

0497 TST_BREAK  LD   A,#7F
0499            IN   A,(254)
049B            RRA
049C            RET  C                   Return if SPACE wasn't pressed.
049D            LD   A,#FE
049F            IN   A,(254)
04A1            RRA
04A2            RET  C                   Return if CAPS wasn't pressed.
04A3            JP   #164A,REP_3

THE 'CALBAS_2' ROUTINE
This routine calls the required 'main' ROM routine.

04A6 CALBAS_2   LD   (#3AC5),DE          Free DE and HL.
04AA            LD   (#3AC8),HL
04AD            POP  HL                  Get return address, points to address
04AE            LD   E,(HL)              of 'main' ROM routine to be called.
04AF            INC  HL                  Fetch address of routine to be called.
04B0            LD   D,(HL)
04B1            INC  HL
04B2            PUSH HL                  Restack return address.
04B3            LD   HL,#3DE5
04B6            LD   (HL),#47            Signal 'CALBAS executing'.
04B8            LD   HL,#0066            Return address to +D system is
04BB            PUSH HL                  'NMI_RAM'.
04BC            PUSH DE                  Push address of routine to be called.
04BD            LD   HL,(#3AC8)          Restore HL and DE.
04C0            LD   DE,(#3AC5)
04C4            JP   #0050,UNPAGE_1      Do the CALBAS.

THE 'POKE @' COMMAND ROUTINE
The POKE @ command allows a value between 0 and 255 to be stored in the +D
system
variables. But if the value is between 256 and 65535 the POKE @ behaves as a
DPOKE.
Because the +D system vars have a offset of #2000 (or 8192) this value has to
be
subtracted if the POKE @ is to be made directly to the given address. So POKE
@60000-8192,1000 to DPOKE 60000,1000.

04C7 POKE@      CALL #0527,SYSTEM_Z      Maybe there is an alternative routine
04CA            CALL Z,#2089,JPOKE       in the system file.
04CD            RST  #28,NEXT_C          Get next character.
04CE            CP   64,"@"
04D0            JP   NZ,#1644,REP_0      If it isn't "@" give error.
04D3            RST  #10,CALBAS          Evaluate the two following numeric
04D4            DEFW #1C79,NEXT_2NUM     expressions.
04D6            CALL #046E,ST_END        Confirm end of statement and exit
04D9            RST  #10,CALBAS          during syntax checking.
04DA            DEFW #1E99,FIND_INT2     Fetch value to be POKEd in BC.
04DC            PUSH BC
04DD            RST  #10,CALBAS
04DE            DEFW #1E99,FIND_INT2     Fetch POKE address.
04E0            LD   HL,#2000            Offset for +D system variables.
04E3            ADD  HL,BC
04E4            POP  BC
04E5            LD   (HL),C              POKE address,low byte.
04E6            LD   A,B
04E7            AND  A
04E8            JP   Z,#047C,END         Exit if 8 bit value.
04EB            INC  HL                  Otherwise POKE address+1,high byte
04EC            LD   (HL),B              before exiting.
04ED            JP   #047C,END

THE 'SPECTRUM ERROR' ROUTINE
This routine must be entered with the error code in (ERR_NR), and does the same
as the
'main' ROM  'ERROR' restart, except when error messages are to be supressed.
This is
indicated by a non zero value in 23728.

04F0 SPEC_ERR   LD   HL,(#3DD6)          Fetch D_CH_ADD.
04F3            LD   (23645),HL          Restore CH_ADD.
04F6            LD   (23647),HL          Restore X_PTR.
04F9 SPEC_ERR1  LD   HL,#0058
04FC            RST  #30,SYNTAX_Z        RETurn to #58, which is in ERROR_2, in
04FD            JP   Z,#004F,UNPAGE_HL   the Spectrum ROM when checking syntax.
0500            LD   A,(23728)
0503            AND  A                   Also RETurn to #58 in 'main' ROM when
0504            JP   Z,#004F,UNPAGE_HL   error messages aren't to be supressed.
0507            SET  7,(IY+0)            Otherwise signal 'Spectrum error'.
050B            LD   HL,#1B7D,STMT_R_1   And RETurn to STMT_R_1 in the Spectrum
050E            JP   #004F,UNPAGE_HL     ROM.

THE 'RESTORE PRINTER BUFFER' SUBROUTINE
This subroutine restores the printer buffers 10 bytes which were destroyed by
the
'?_ROMBANK' subroutine.

0511 REST_PBUF  LD   HL,#3BE6
0514            LD   DE,23296
0517            LD   BC,10
051A            LDIR
051C            RET

THE 'DETERMINE 48K OR 128K ROM' ROUTINE
This small routine is copied to 23296, it returns with the Zero flag set if
address
#0001 in the 'main' ROM contains 175, that is when the 48K ROM bank is paged
in.

051D DET_ROM    OUT  (231),A             Page +D out.
051F            LD   A,(#0001)
0522            CP   175
0524            JP   #0066,NMI           Page +D in.

THE 'SYSTEM_Z' SUBROUTINE
This subroutine returns with the Zero flag set when the system file is present
in RAM.

0527 SYSTEM_Z   LD   (#3DEA),A
052A            LD   A,(#3DE4)
052D            CP   #44
052F            LD   A,(#3DEA)
0532            RET

THE 'POWER_UP2' ROUTINE
The routine continues, with the proper register contents, in the 'main' ROM
'START/NEW'
routine.

0533 POWER_UP2  LD   A,#02               Red instead of black border.
0535            OUT  (254),A
0537            LD   A,#3F               Set interrupt vector.
0539            LD   I,A
053B            NOP
053C            NOP
053D            NOP
053E            NOP
053F            NOP
0540            NOP
0541            NOP
0542            NOP
0543            LD   HL,#7FFF            The stackpointer has to point into
RAM,
0546            LD   SP,HL               otherwise: trouble (for the
                                         UNPAGE_HL routine).
0547            IM   1                   Set interrupt mode 1.
0549            XOR  A                   Restore registers for 'main' ROM
054A            LD   DE,#FFFF            'START/NEW'.
054D            LD   HL,#11CB
0550            JP   #004F,UNPAGE_HL     Jump to 'START/NEW' in the 'main' ROM.
 ____________________________
|Previous|Next|Contents|Index|
###### 0553-disk.html ######
###### 0553-disk.html ######


 ____________________________
|Previous|Next|Contents|Index|
The disk routines

THE 'STORE INTERRUPT STATE' SUBROUTINE
This subroutine stores the Interrupt Flip Flop of the Z80 and returns with
interrupts
disabled. Whenever the +D needs the interrupts to be disabled with disk
operations the
status of the IFF (DI or EI) is stored. When the disk operation is finished the
IFF is
restored to the state it was in before the interrupts were disabled.
NOTE: As a result of a bug in the Z80 itself the stored state of the IFF can be
wrong if
interrupts are enabled. The problem occurs when an interrupt is accepted
(implying: interrupts
enabled) during the execution of the 'LD A,R' or 'LD A,I' instruction. A
solution to this
problem is a second test if the IFF indicates interrupts disabled. With a
Spectrum it is
unlikely that two interrupts follow each other within a very short time, so a
second test should
cure the problem. A better method can be found in the 'Zilog Z80 Family Data
Book'. The best
method is replacing the Z80 with a CMOS version, the bug has been fixed in that
Z80 type.

0553 STORE_IFF  PUSH AF
0554            LD   A,I                 Set the P/V flag according to the
state
0556            PUSH AF                  of the IFF2.
0557            DI
0558            EX   (SP),HL             Get the Flag register in L while
saving
                                         HL.
0559            LD   (#3E50),HL          Store it. (IFF)
055C            POP  HL                  Restore HL and AF.
055D            POP  AF
055E            RET                      Finished.

THE 'RESTORE INTERRUPT STATE' SUBROUTINE
This subroutine restores the interrupt state to the original state (DI or EI)
(see NOTE
above).

055F REST_IFF   PUSH AF                  Save the contents of the needed
0560            PUSH HL                  registers.
0561            LD   HL,(#3E50)          Fetch the previous IFF state.
0564            EX   (SP),HL             Restore HL and store IFF state.
0565            POP  AF                  The IFF state is now contained in the
                                         P/V flag.
0566            JP   PO,#056A,REST_IFF1  Jump if interrupts were disabled.
0569            EI                       Otherwise enable interrupts.
056A REST_IFF1  POP  AF
056B            RET                      Finished.

THE 'WRITE PRECOMPENSATION' SUBROUTINE
This subroutine is called before a write command is send to the Floppy Disk
Controller
(FDC). Its task is to enable write precompensation on the inner tracks to get a
more
reliable working of the data transfers. On entry C holds the FDC command.

056C PRECOMP    LD   C,%10100010         Write a single sector, enable spin-up
                                         sequence, no settling delay, disable
                                         precompensation, normal data mark.
056E PRECOMP1   LD   B,64                Start write precomp. at track 64.
0570            CALL #0985,DRV_CAP       Get drive capacity in A.
0573            AND  #7F                 Keep only the number of tracks.
0575            CP   80
0577            JR   Z,#057B,PREC_1      Jump if drive has 80 tracks.
0579            SRL  B                   Otherwise precomp. starts at track 32.
057B PREC_1     LD   A,D                 Fetch current track.
057C            AND  B
057D            JR   Z,#0581,PREC_2      Jump if not at tracks above 63 or 31.
057F            RES  1,C                 Otherwise enable write precompensation
                                         (reset bit 1 of the command).
0581 PREC_2     JP   #06F7,LD_COM_REG    Give the command to the FDC.

THE 'WRITE SECTOR' SUBROUTINE
This subroutine writes the contents of the data buffer to sector E on track D.

0584 WSAD       XOR  A                   Reset retry counter.
0585            LD   (#3DDB),A
0588 WSAD_1     CALL #0667,SET_TRKSEC    Select drive, side, density and sector
                                         and position the head above the
correct
                                         track.
058B            CALL #056C,PRECOMP       Enable precompensation when neccesary
                                         and give the command to the FDC.
058E            CALL #0D86,HL_BUFFER     Make HL point to the data buffer.
0591            CALL #0599,WR_OP         Write the sector.
0594            CALL #060D,SECTOR_ERR    Check if there was an error, report it
                                         if retried often enough. Otherwise
exit
0597            JR   #0588,WSAD_1        Try again if no succes.

THE 'SEND DATA TO FDC' SUBROUTINE
This subroutine handles the actual saving of a sector. It keeps sending a byte
at a time
to the FDC as long as it asks for one (sector length doesn't matter).

0599 WR_OP      CALL #0553,STORE_IFF     Store maskable interrupt state and
                                         disable maskable interrupts.
059C            LD   BC,251              BC holds the I/O port address of the
                                         data register of the FDC.
059F            JR   #05A4,WR_TST_DRQ    Jump into the save loop.

05A1 WR_LOOP    OUTI                     Send a byte to the FDC (port BC) then
                                         increment HL (and decrement B).
05A3            NOP                      Waste some time.
05A4 WR_TST_DRQ IN   A,(227)             Fetch FDC status.
05A6            BIT  1,A                 Test Data ReQuest bit.
05A8            JR   NZ,#05A1,WR_LOOP    Jump if FDC requests a byte.
05AA            IN   A,(227)             Otherwise fetch FDC status again.
05AC            BIT  1,A
05AE            JR   NZ,#05A1,WR_LOOP    Jump if FDC requests a byte.
05B0            IN   A,(227)
05B2            BIT  1,A
05B4            JR   NZ,#05A1,WR_LOOP
05B6            IN   A,(227)
05B8            BIT  1,A
05BA            JR   NZ,#05A1,WR_LOOP
05BC            BIT  0,A                 Test Busy bit.
05BE            JR   NZ,#05A4,WR_TST_DRQ Repeat until FDC is ready.
05C0            CALL #055F,REST_IFF      Restore the interrupt state.
05C3            BIT  6,A                 Test Write Protected bit.
05C5            RET  Z                   Return if not write protected.
05C6            CALL #0B56,DEC_MAPUSE    Decrease (MAPUSED), the number of
files
                                         using the disk bitmap.
05C9            JP   #1672,REP_23        Otherwise give 'Disc WRITE protected'
                                         error.

THE 'READ SECTOR' SUBROUTINE
This subroutine loads the contents of the data buffer from sector E on track D.

05CC RSAD       XOR  A                   Clear retry counter.
05CD            LD   (#3DDB),A
05D0 RSAD_1     CALL #0667,SET_TRKSEC    Set drive, side, density, sector and
                                         position the head above the correct
                                         track.
05D3            LD   C,%10000000         Read a single sector, enable spin-up
                                         sequence, no settling delay.
05D5            CALL #06F7,LD_COM_REG    Give the command to the FDC.
05D8            CALL #0D86,HL_BUFFER     Make HL point to the data buffer.
05DB            CALL #05E3,RD_OP         Read the sector.
05DE            CALL #060D,SECTOR_ERR    Check if there was an error, report it
                                         if retried often enough. Otherwise
exit
05E1            JR   #05D0,RSAD_1        Try again if no succes.

THE 'GET DATA FROM FDC' SUBROUTINE
This subroutine handles the actual loading of a sector. It keeps fetching a
byte at a
time from the FDC as long as it asks to get one (sector length doesn't matter).

05E3 RD_OP      CALL #0553,STORE_IFF     Store the maskable interrupt state and
                                         disable interrupts.
05E6            LD   BC,251              I/O address of the FDCs data register.
05E9            JR   #05EE,RD_TEST_DRQ   Jump into the load loop.

05EB RD_LOOP    INI                      Get a byte from the FDC and increment
                                         HL (and decrement B).
05ED            NOP                      Wait for a moment.
05EE RD_TST_DRQ IN   A,(227)             Fetch FDC status.
05F0            BIT  1,A                 Test Data ReQuest bit.
05F2            JR   NZ,#05EB,RD_LOOP    Jump if FDC has read a byte.
05F4            IN   A,(227)             Otherwise fetch FDC status again.
05F6            BIT  1,A
05F8            JR   NZ,#05EB,RD_LOOP    Jump if FDC has read a byte.
05FA            IN   A,(227)
05FC            BIT  1,A
05FE            JR   NZ,#05EB,RD_LOOP
0600            IN   A,(227)
0602            BIT  1,A
0604            JR   NZ,#05EB,RD_LOOP
0606            BIT  0,A                 Test Busy bit.
0608            JR   NZ,#05EE,RD_TST_DRQ Repeat until FDC is ready.
060A            JP   #055F,REST_IFF      Restore interrupt state and exit.

THE 'CHECK SECTOR ERROR' SUBROUTINE
This subroutine checks if the FDC reported an error, on entry A holds the FDC
status
byte. If there wasn't one HL points to the start of the data buffer and the RPT
is reset.
If there was an positioning error the routine moves the head to the correct
track. With
other errors the head is repositioned above the current track, unless ten
retries have
been made, then an error is reported.

060D SECTOR_ERR AND  %00011100           Mask the non error bits.
060F            JR   NZ,#0618,SEC_ERR1   Jump with an error.
0611            CALL #0DAA,RES_RPT       Otherwise reset the data buffer
pointer
                                         (RPT).
0614            POP  HL                  Drop return address and exit with
0615            JP   #0D86,HL_BUFFER     HL pointing to the data buffer.

0618 SEC_ERR1   PUSH AF                  Save error.
0619            LD   A,(#3DDB)           Increment the retry counter.
061C            INC  A
061D            LD   (#3DDB),A
0620            CP   10                  If 10 retries have been made 'SECTOR
0622            JP   NC,#164C,REP_4      error' is given.
0625            POP  AF
0626            BIT  4,A
0628            JR   NZ,#0636,SEC_ERR2   Jump with positioning error.
062A            CALL #0DCF,STEP_IN       Otherwise shake the the dust out of
062D            CALL #0DCB,STEP_OUT      the drive.
0630            CALL #0DCB,STEP_OUT
0633            JP   #0DCF,STEP_IN

The routine now checks whether the head is above the right track. The current
tracknumber is found by reading the ID Field of the first encountered sector on
this
track. The track number is then stored into the track register of the FDC. When
no ID
Field can be found the retry counter is incremented, when this reaches 16 the
'FORMAT
data lost' error is given.

0636 SEC_ERR2   LD   C,%11000000         Read Address, disable spinup, no
delay.
0638            CALL #06F7,LD_COM_REG    Execute the command.
063B            LD   HL,#3DDC            Address where the ID Field is loaded.
063E            CALL #05E3,RD_OP         Get the six byte ID Field of the first
                                         sector encountered.
0641            AND  %00011100
0643            JR   NZ,#064B,SEC_ERR3   Jump if there was an error.
0645            LD   A,(#3DDC)           Otherwise store the current track
0648            OUT  (235),A             number into the FDC's track register.
064A            RET
064B SEC_ERR3   LD   A,(#3DDB)
064E            INC  A                   Increment retry counter.
064F            LD   (#3DDB),A
0652            CP   16                  Give up if tried 16 times, 'FORMAT
0654            JP   Z,#164E,REP_5       data lost'.
0657            CP   10
0659            JR   NZ,#0662,SEC_ERR4   After 10 times try something
different.
065B            PUSH DE
065C            CALL #06A4,TRACK_0       Start from the beginning of the disk.
065F            POP  DE
0660            JR   #0636,SEC_ERR2
0662 SEC_ERR4   CALL #0DCF,STEP_IN       Take one small step.
0665            JR   #0636,SEC_ERR2      And retry again.

THE 'SET TRACK AND SECTOR' SUBROUTINE
This subroutine is used to select the required drive, side, density, sector to
be
handled and to position the drive head above the required track.
NOTE: The head is moved relative to the current position (fetched from the FDCs
track
register), when the drive selected is not the same as the previous one the +D
can get confused.

0667 SET_TRKSEC LD   A,D
0668            OR   E
0669            JR   NZ,#0676,SET_TRK1   Jump if DE<>0.
066B            CALL #1626,TEST_2        Test the .. flag.
066E            JP   Z,#167A,REP_27      Give 'END of file' error when reset.
0671            LD   SP,(#2066)          Otherwise clear the machine stack.
0675            RET
0676 SET_TRK1   CALL #071C,SET_DRVSD     Select drive, side and density.
0679            LD   A,E                 Store the required sector number into
067A            OUT  (243),A             the FDC's sector register.
067C            CALL #1684,FLASH_REST    Change the border colour when wanted.
067F SET_TRK2   LD   A,D                 Track to A.
0680            AND  #7F                 Mask highest bit which indicates side.
0682            LD   B,A
0683            CALL #06E6,FDC_READY     Wait until FDC is ready, test BREAK.
0686            IN   A,(235)             Fetch contents of FDC's track
register.
0688            CP   B                   Compare against required track.
0689            RET  Z                   Exit if already on right track.
068A            CALL NC,#0DCB,STEP_OUT   Step out if required track lies
                                         outwards (more towards track 0).
068D            CALL C,#0DCF,STEP_IN     Otherwise step in.
0690            JR   #067F,SET_TRK2      Continue until on the right track.

THE 'STEP DELAY' SUBROUTINE
This subroutine does the waiting between the executing of two step commands. By
altering
the value of the (STPRAT) system variabele (POKE @3,n) the time being
waited can be altered.

0692 STEP_DELAY LD   A,(#2003)           Fetch (STPRAT).
0695            AND  A
0696 STEP_D1    RET  Z                   Exit if 'msec-counter' reaches zero.
0697 WAIT_1MSEC PUSH AF
0698            LD   BC,135              With this value the following loop
                                         takes 3505 T states (about 1msec) to
                                         complete.
069B WAIT_1M1   DEC  BC
069C            LD   A,B
069D            OR   C
069E            JR   NZ,#069B,WAIT_1M1   Repeat until counter reaches zero.
06A0            POP  AF
06A1            DEC  A                   Decrease 'msec-counter'.
06A2            JR   #0696,STEP_D1

THE 'TRACK_0' SUBROUTINE
This subroutine resets the head of the current drive to track 0. It has two
entry
points, the first is used by the ROM located routines, while the second (at
#06B6) is
used by the 'REST' command code (code 64 or #40). After the head has been
resetted, a
test is made whether there is a disk in the drive.

06A4 TRACK_0    LD   A,(#2003)
06A7            RLCA                     Double (STPRAT).
06A8            LD   (#2003),A
06AB            CALL #06B6,REST          Move head to track 0.
06AE            LD   A,(#2003)
06B1            RRCA                     Restore original (STPRAT) value.
06B2            LD   (#2003),A
06B5            RET

06B6 REST       LD   DE,#0001            Signal 'track 0, sector 1'.
06B9            CALL #071C,SET_DRVSD     Set drive, side and density.

The following code resets the drive head to track 0.

06BC            LD   C,%11010000         Terminate all operations.
06BE            CALL #06FA,LD_COM_R1     Execute the FDC command.
06C1            LD   B,0                 Wait about 1 msec.
06C3 REST_1     DJNZ #06C3,REST_1

The routine now checks whether there is a disk in the drive. The bug present in
the
DISCiPLE ROM is corrected, the +D doesn't wait forever for an INDEX pulse.

06C5            LD   HL,0                The INDEX signal has to become low
                                         and high again within about 1.4 sec.
06C8 REST_2     IN   A,(227)             Fetch FDC status.
06CA            BIT  1,A
06CC            CALL NZ,#06F0,REST_5     Call if INDEX signal is high.
06CF            JR   NZ,#06C8,REST_2     Wait for it to become low.
06D1 REST_3     IN   A,(227)             Fetch FDC status.
06D3            CPL                      Invert the bits.
06D4            BIT  1,A
06D6            CALL NZ,#06F0,REST_5     Call if INDEX signal is low.
06D9            JR   NZ,#06D1,REST_3     Wait for it to become high again.
06DB REST_4     IN   A,(227)             Fetch the FDC status register.
06DD            BIT  2,A
06DF            JR   NZ,#06E6,FDC_READY  Exit if head is above track 0.
06E1            CALL #0DCB,STEP_OUT      Otherwise, step-out and continue
06E4            JR   #06DB,REST_4        the loop.

THE 'WAIT UNTIL FDC IS READY' SUBROUTINE
This small subroutine waits until the FDC is ready. When the BREAK key is
pressed during
the waiting, an error is reported.

06E6 FDC_READY  IN   A,(227)             Fetch the FDC status.
06E8            BIT  0,A
06EA            RET  Z                   Exit if it's indicating 'FDC ready'.
06EB            CALL #0497,TST_BREAK     Test for BREAK.
06EE            JR   #06E6,FDC_READY     Repeat until FDC is ready.

THE 'TRACK_0' ROUTINE CONTINUED

06F0 REST_5     DEC  HL                  Decrease time limit.
06F1            LD   A,H
06F2            OR   L
06F3            RET  NZ                  Return if limit isn't exceeded.
06F4            JP   #1650,REP_6         Otherwise 'NO DISC in drive'.

THE 'LOAD FDC COMMAND REG.' SUBROUTINE
This subroutine loads the FDC command register with the command held in the
Z80's C
register. The entry point 'LD_COM_R1' is used to give the 'terminate all
operations'
command to the FDC, it makes no sense to wait for the FDC to get ready if the
current
command is to be aborted.

06F7 LD_COM_REG CALL #06E6,FDC_READY     Wait until FDC is ready, test BREAK.
06FA LD_COM_R1  LD   A,C                 Load the command in the FDC's command
06FB            OUT  (227),A             register.
06FD            LD   B,20                Wait for 73 µsec.
06FF LD_COM_R2  DJNZ #06FF,LD_COM_R2     Waste some time.
0701            RET                      Finished.

THE 'TEST DRIVE' SUBROUTINE
This subroutine checks if the specified drive is defined (only if it's number
isn't 1,
then it is accepted right away). The entry point at #0702 is used when the
drive is
specified in UFIA1. The entry point at #0705 is used whenever the drive is
specified in
the A register. On exit (IX+11) holds the hardware representation of the drive
to be
used.

0702 TEST_DRV   LD   A,(#3E01)           Fetch drive number from UFIA1.
0705 TEST_DRV1  CP   1
0707            JR   Z,#0718,TEST_DRV2   Jump if drive one is to be used.
0709            CP   2                   Otherwise give 'Wrong DRIVE' error if
070B            JP   NZ,#1670,REP_22     drive isn't drive two.
070E            LD   A,(#2002)           Fetch (TRAKS2) system variable.
0711            CP   0
0713            JP   Z,#1670,REP_22      Give error if drive isn't defined.
0716            LD   A,2                 Select drive two.
0718 TEST_DRV2  LD   (IX+11),A           Store hardware representation.
071B            RET

THE 'SET DRIVE PARAMETERS' SUBROUTINE
This subroutine selects the drive, side and density by setting the right bits
in the
control port (I/O address 239).

071C SET_DRVSD  LD   B,(IX+11)           Fetch hardware drive representation.
071F            LD   A,(#3DDA)           Fetch current control port status.
0722            AND  %00000011           Keep only drive 1&2 select bits.
0724            CP   B                   Set Zero flag if drive isn't changed.
0725            PUSH AF
0726            LD   A,(#3DDA)           Fetch current control port status
0729            AND  %01111100           again. Mask drive and side select
bits.
072B            LD   C,A                 Store result temporary.
072C            LD   A,D                 Fetch track.
072D            AND  %10000000           Only keep side select.
072F            OR   B                   Include drive select.
0730            OR   C                   Include all other bits.
0731            LD   (#3DDA),A           Set current control port status.
0734            OUT  (239),A             Activate settings.
0736            POP  AF                  Get Zero flag.
0737            RET  Z                   Exit if drive hasn't changed.

NOTE: This would have been a nice place to update the FDC's track register, it
is very
unlikely that both drives are on the same track all the time.

0738            LD   A,128               Otherwise wait for 128 msec.
073A            JP   #0697,WAIT_1MSEC    Exit via 'WAIT_1MSEC'.

THE 'PROGRAM NUMBER' SUBROUTINE
This subroutine calculates the program number from track and sector number and
the
contents of RPT-high (which holds 0 for odd program numbers and 1 for even
ones). It is
used to get the program number printed in the extended CATalogue.

073D PROG_NUM   PUSH DE                  Track and sector to BC.
073E            POP  BC
073F            XOR  A                   Clear A.
0740            DEC  B
0741            JP   M,#074A,PROG_N2     Jump with track 0, B now holds -1.
0744 PROG_N1    ADD  A,10                Otherwise set A to 10*track number.
0746            DEC  B
0747            JP   P,#0744,PROG_N1     Repeat until B gets below zero.
074A PROG_N2    LD   B,A
074B            SLA  B                   Otherwise double number of tens.
074D            SLA  C                   Together with the next instruction the
074F            DEC  C                   effect is 'INC C'.
0750            LD   A,(IX+14)           Fetch high byte of RPT.
0753            ADD  A,C                 Add adjusted sector.
0754            ADD  A,B                 Add adjusted track.
0755            RET                      Exit with A holding the program
number.

THE 'SECT_END_Z' SUBROUTINE
This subroutine returns with the Zero flag set if RPT has reached the sector
end, that
is if RPT points to the next track and sector numbers present in each sector.

0756 SECT_END_Z CALL #0D97,RPT_HL1       Get RPT in HL and the disk buffer
0759            LD   A,C                 position in BC.
075A            CP   254                 Exit if disk buffer position 510 (or
075C            RET  NZ                  254) hasn't been reached, Zero reset.
075D            LD   A,B                 Position 510 has to be reached before
075E            CP   1                   returning with Zero set.
0760            RET

THE 'SAVE A BYTE TO DISK' SUBROUTINE
This subroutine saves the byte in A in the data buffer at the location pointed
to by RPT
(the disk buffer pointer). If the buffer is full, an automatic sector save to
disk will
take place, RPT will be reset to the start of the buffer and the value will
then be
saved.

0761 SBYT       PUSH BC
0762            PUSH DE
0763            PUSH HL
0764            PUSH AF
0765            CALL #0756,SECT_END_Z    Check if the data buffer is full.
0768            JR   NZ,#0777,SBYT_1     Jump if data buffer not full.
076A            CALL #0925,MK_ALLOC      Allocate the first free sector.
076D            LD   (HL),D              Store it's track and sector number
into
076E            INC  HL                  the last two bytes of the data buffer.
076F            LD   (HL),E
0770            EX   DE,HL
0771            CALL #0DC1,GET_SECTOR    Fetch track and sector number of the
                                         current sector into DE, store the next
                                         track and sector number.
0774            CALL #0584,WSAD          Write the sector to disk.
0777 SBYT_1     POP  AF
0778            LD   (HL),A              Store value.
0779            POP  HL
077A            POP  DE
077B            POP  BC
077C            JP   #0DA2,INC_RPT       Exit while increasing RPT.

THE 'LOAD A BYTE FROM DISK' SUBROUTINE
This subroutine loads the byte pointed to by RPT from the data buffer, and
returns with
it in A and RPT updated. If the buffer is empty, another sector is read from
the disk.

077F LBYT       PUSH BC
0780            PUSH DE
0781            PUSH HL
0782            CALL #0756,SECT_END_Z    Check if the data buffer is empty.
0785            JR   NZ,#078D,LBYT_1     Jump if data buffer not empty.
0787            LD   D,(HL)              Otherwise fetch track and sector
number
0788            INC  HL                  of next sector into DE.
0789            LD   E,(HL)
078A            CALL #05CC,RSAD          Load the next sector.
078D LBYT_1     LD   A,(HL)              Get a byte.
078E            POP  HL
078F            POP  DE
0790            POP  BC
0791            JP   #0DA2,INC_RPT       Exit while increasing RPT.

THE 'LOAD FILE' ROUTINE
This very important routine handles the loading of any file from disk. The
entry point
is at address #079E. On entry HL holds the load address, while DE holds the
number of
bytes to be loaded. The routine first empties the data buffer, which was loaded
with the
first sector to obtain the 9 byte file header. When the data buffer is empty
the routine
loads all sectors, but the last, into the memory directly. The last sector is
loaded into
the data buffer again and then the remaining bytes are loaded from it.

0794 LD_BUF     LD   A,(HL)              Fetch a byte from the data buffer.
0795            CALL #0DA2,INC_RPT       Increment RPT.
0798            LD   HL,(#3AC8)          Fetch load address.
079B            LD   (HL),A              Load the byte into memory.
079C            INC  HL
079D            DEC  DE
079E LOAD_FILE  LD   (#3AC8),HL          Store load address into (FILEADDR).
07A1            LD   A,D
07A2            OR   E
07A3            RET  Z                   Exit if no more bytes left.
07A4 LD_BUF1    CALL #0756,SECT_END_Z    The data buffer has to be empty before
07A7            JR   NZ,#0794,LD_BUF     sectors can be loaded directly into
                                         memory. Jump if data buffer not empty.
07A9            LD   (#3AC5),DE          Store the number of bytes left to load
                                         into (BYTESLEFT).
07AD            LD   D,(HL)              Fetch next track and sector.
07AE            INC  HL
07AF            LD   E,(HL)
07B0            CALL #0833,STO_BUFLEN    Store the data buffer length.
07B3 LD_OP      CALL #083B,LAST_SEC_C    Check if this sector is the last one.
07B6            JP   C,#0829,LD_LAST     Jump if last sector.
07B9            INC  HL                  Balance the Carry flag subtracted in
                                         'LAST_SEC_C'.
07BA            LD   (#3AC5),HL          Store number of bytes left after this
                                         sector has been loaded.
07BD            XOR  A                   Clear retry counter.
07BE            LD   (#3DDB),A
07C1            CALL #0DBA,STORE_SEC     Store track and sector.
07C4 LD_AGAIN   CALL #0667,SET_TRKSEC    Set drive, side, density, sector and
                                         track.
07C7            LD   C,%10000000         Read a single sector, enable spin-up,
                                         no settling delay.
07C9            CALL #06F7,LD_COM_REG    Execute the FDC command.
07CC            CALL #0553,STORE_IFF     Store interrupt state and disable.
07CF            EXX                      HL' has to be rescued because the
07D0            PUSH HL                  'main' ROM needs it.
07D1            LD   BC,251              I/O address of FDC's data register.
07D4            LD   DE,2                DE' holds the length of the next
sector
                                         address in each sector.
07D7            CALL #0D86,HL_BUFFER     HL' points to the data buffer.
07DA            EXX
07DB            LD   BC,251              I/O address of FDC's data register.
07DE            LD   DE,(#3ACA)          DE holds length of data buffer. DE +
                                         DE' hold the length of a sector.
07E2            LD   HL,(#3AC8)          HL holds the load address.
07E5            JR   #07EF,LD_TST_DRQ    Jump into the load loop.

07E7 LD_LOOP    INI                      Get a byte from the FDC, increment HL.
07E9            DEC  DE                  Decrement byte counter.
07EA            LD   A,D
07EB            OR   E
07EC            JR   NZ,#07EF,LD_TST_DRQ Jump if not zero.
07EE            EXX                      Otherwise select the other HL and DE.
07EF LD_TST_DRQ IN   A,(227)             Fetch FDC status.
07F1            BIT  1,A                 Test Data ReQuest bit.
07F3            JR   NZ,#07E7,LD_LOOP    Jump if FDC has read a byte.
07F5            IN   A,(227)             Otherwise fetch FDC status again.
07F7            BIT  1,A
07F9            JR   NZ,#07E7,LD_LOOP    Jump if FDC has read a byte.
07FB            IN   A,(227)
07FD            BIT  1,A
07FF            JR   NZ,#07E7,LD_LOOP
0801            IN   A,(227)
0803            BIT  1,A
0805            JR   NZ,#07E7,LD_LOOP
0807            BIT  0,A                 Test Busy bit.
0809            JR   NZ,#07EF,LD_TST_DRQ Repeat until FDC is ready.
080B            EXX                      When the FDC is ready, DE and DE' both
080C            POP  HL                  are 0, and the 'EXX' at #07EE has been
080D            EXX                      executed twice, so to restore HL'
                                         a 'EXX' has to be executed first.
080E            CALL #055F,REST_IFF      Restore interrupt state.
0811            AND  %00011100           Mask non error bits of FDC status.
0813            JR   Z,#081D,LD_OK       Jump with no errors.
0815            CALL #0DB3,FETCH_SEC     Otherwise fetch track and sector
again.
0818            CALL #0618,SEC_ERR1      Check if there was a sector error.
081B            JR   #07C4,LD_AGAIN      Try to load the sector again.

If there are no errors the next sector can be loaded.

081D LD_OK      LD   (#3AC8),HL          Store the load address into
(FILEADDR).
0820            CALL #0D86,HL_BUFFER     Make HL point to the data buffer.
0823            LD   D,(HL)              Fetch the next track and sector
number.
0824            INC  HL
0825            LD   E,(HL)
0826            JP   #07B3,LD_OP         Load the next sector.

The last sector is loaded into the data buffer.

0829 LD_LAST    CALL #05CC,RSAD          Load the last sector.
082C            LD   DE,(#3AC5)          Fetch number of bytes left (BYTESLEFT)
0830            JP   #07A4,LD_BUF1       and copy them to 'main' RAM.

THE 'STORE BUFFER LENGTH' SUBROUTINE
This subroutine stores the length of the data buffer into (#1ACA). Because the
+D only
uses double density this is always 510.

0833 STO_BUFLEN LD   BC,510              Length of DD data buffer.
0836            LD   (#3ACA),BC          Store the length into (BUFLEN).
083A            RET

THE 'LAST_SEC_C' SUBROUTINE
This subroutine returns with the Carry flag set if the last sector is to be
loaded.

083B LAST_SEC_C LD   HL,(#3AC5)          Fetch the number of bytes left to be
                                         loaded from (BYTESLEFT).
083E            LD   BC,(#3ACA)          Fetch the data buffer length from
                                         (BUFLEN).
0842            SCF                      Set the Carry flag, now the Carry flag
                                         will be set after the 'SBC' if HL=BC.
0843            SBC  HL,BC               Exit with Carry set signalling 'last
0845            RET                      sector to be loaded'.

THE 'SAVE FILE' ROUTINE
This is the opposite of the 'LOAD_FILE' routine above. The entry address is
#0850, on
entry HL holds the save address and DE holds the number of bytes to be saved.
The routine
first fills up the data buffer, which contains the 9 byte file header already.
The data
buffer is saved to disk, after which a sector address table is build for all
but the last
sector. All sectors, the addresses of which are contained in the table, are
saved
directly from memory. The last sector is saved into the data buffer again after
which the
file should be closed.

0846 SA_BUF     LD   (HL),D              Save the byte in the data buffer.
0847            CALL #0DA2,INC_RPT       Increment RPT.
084A            LD   HL,(#3AC8)          Fetch save address from (FILEADDR).
084D            INC  HL
084E            POP  DE
084F            DEC  DE
0850 HSVBK_2    LD   A,D
0851            OR   E
0852            RET  Z                   Exit if no more bytes to save.
0853            PUSH DE
0854            LD   D,(HL)              Fetch a byte from memory.
0855            LD   (#3AC8),HL          Store save address into (FILEADDR).
0858            CALL #0756,SECT_END_Z    The data buffer has to be full before
085B            JR   NZ,#0846,SA_BUF     the sector can be saved. Jump if data
                                         buffer isn't full.
085D            POP  DE                  Fetch number of bytes left to save and
085E            LD   (#3AC5),DE          store it into (BYTESLEFT).
0862            CALL #0925,MK_ALLOC      Allocate the first free sector.
0865            LD   (HL),D              Store track and sector number into the
0866            INC  HL                  data buffer.
0867            LD   (HL),E
0868            EX   DE,HL
0869            CALL #0DC1,GET_SECTOR    Fetch track and sector number of the
                                         current sector in DE, store the next
                                         track and sector number.
086C            CALL #0584,WSAD          Write the sector to disk.
086F            XOR  A                   Clear sector counter.
0870            LD   (#3DEA),A
0873            CALL #0833,STO_BUFLEN    Store the data buffer length.
0876            CALL #083B,LAST_SEC_C    Check if this is the last sector.
0879            JP   C,#0918,SA_LAST     Jump if it is.
087C            CALL #0D86,HL_BUFFER     HL points to the data buffer.
087F SA_ALLOC   PUSH HL                  Store data buffer address.
0880            CALL #083B,LAST_SEC_C    Check if this is the last sector.
0883            PUSH HL                  DE now holds the number of bytes left
0884            POP  DE                  -1.
0885            POP  HL                  Restore data buffer pointer.
0886            JR   C,#089D,SA_OP       Jump if all but last sector allocated.
0888            INC  DE                  Balance the Carry subtracted in
0889            LD   (#3AC5),DE          'LAST_SEC_C' before storing the number
                                         of bytes left into (BYTESLEFT).
088D            CALL #0925,MK_ALLOC      Allocate a sector.
0890            LD   (HL),D              Store its track and sector number into
0891            INC  HL                  the data buffer.
0892            LD   (HL),E
0893            INC  HL
0894            LD   A,(#3DEA)           Increase sector counter.
0897            INC  A
0898            LD   (#3DEA),A
089B            JR   NZ,#087F,SA_ALLOC   Repeat until all sectors have been
                                         allocated or the sector counter
                                         overflows.
089D SA_OP      XOR  A                   Reset retry counter.
089E            LD   (#3DDB),A
08A1            CALL #0DB3,FETCH_SEC     Fetch the sector to be saved.
08A4 SA_AGAIN   CALL #0667,SET_TRKSEC    Set drive, side, etc.
08A7            CALL #056C,PRECOMP       Enable precompensation when neccesary
                                         and execute the write sector command.
08AA            CALL #0553,STORE_IFF     Store interrupt state and disable.
08AD            EXX                      HL' has to be stored because the
08AE            PUSH HL                  'main' ROM needs it.
08AF            CALL #0D97,RPT_HL1       HL' points to the sector address
                                         table, build up in the data buffer.
08B2            LD   DE,2                DE' holds the length of the next
                                         sector address in each sector.
08B5            LD   BC,251              BC' holds the I/O address of the FDC's
                                         data register.
08B8            EXX
08B9            LD   HL,(#3AC8)          HL holds the save address.
08BC            LD   DE,(#3ACA)          DE holds the length of the data space
                                         inside a sector. DE+DE' hold the
                                         length of a complete sector.
08C0            LD   BC,251              BC holds the same as BC'.
08C3            JR   #08CD,SA_TST_DRQ    Jump into the save loop.

08C5 SA_LOOP    OUTI                     Send a byte to the FDC, increment HL.
08C7            DEC  DE                  Decrement byte counter.
08C8            LD   A,D
08C9            OR   E
08CA            JR   NZ,#08CD,SA_TST_DRQ Jump if not zero.
08CC            EXX                      Otherwise select the other HL and DE.
08CD SA_TST_DRQ IN   A,(227)             Fetch FDC status.
08CF            BIT  1,A                 Test Data ReQuest bit.
08D1            JR   NZ,#08C5,SA_LOOP    Jump if FDC requests a byte.
08D3            IN   A,(227)             Otherwise fetch FDC status again.
08D5            BIT  1,A
08D7            JR   NZ,#08C5,SA_LOOP    Jump if FDC requests a byte.
08D9            IN   A,(227)
08DB            BIT  1,A
08DD            JR   NZ,#08C5,SA_LOOP
08DF            IN   A,(227)
08E1            BIT  1,A
08E3            JR   NZ,#08C5,SA_LOOP
08E5            BIT  0,A                 Test Busy bit.
08E7            JR   NZ,#08CD,SA_TST_DRQ Repeat until FDC is ready.
08E9            CALL #055F,REST_IFF      Restore interrupt state.
08EC            AND  %00011100           Mask non error bits of FDC status.
08EE            JR   Z,#08FB,SA_OK       Jump with no errors.
08F0            EXX
08F1            POP  HL                  Restore HL'.
08F2            EXX
08F3            CALL #0DB3,FETCH_SEC     Fetch track and sector again.
08F6            CALL #0618,SEC_ERR1      Check if there was a sector error.
08F9            JR   #08A4,SA_AGAIN      Try to save the sector again.

If there are no errors the next sector can be saved, but first its track and
sector
number have to be retrieved.

08FB SA_OK      LD   (#3AC8),HL          Store the save address into (FILEADDR)
08FE            EXX
08FF            DEC  HL                  Fetch track and sector number of next
0900            LD   E,(HL)              sector.
0901            DEC  HL
0902            LD   D,(HL)
0903            CALL #0DA2,INC_RPT       Update RPT.
0906            CALL #0DA2,INC_RPT
0909            CALL #0DBA,STORE_SEC     Store the next sector's track and
                                         sector number.
090C            POP  HL                  Restore HL'.
090D            EXX
090E            LD   A,(#3DEA)           Decrease sector counter.
0911            DEC  A
0912            LD   (#3DEA),A           Save the next sector as long as it
0915            JP   NZ,#089D,SA_OP      isn't the last one.
0918 SA_LAST    CALL #0DAA,RES_RPT       The bytes of the last sector are saved
091B            LD   DE,(#3AC5)          into the data buffer again. Fetch the
091F            LD   HL,(#3AC8)          number of bytes left and the save
0922            JP   #0850,HSVBK_2       address. Then save the bytes into the
                                         data buffer.

THE 'ALLOCATE SECTOR' SUBROUTINE
This subroutine allocates the first free sector, which track and sector number
are
returned in the DE register pair. The routine searches the disk bitmap at #1A00
for a
free sector, if there isn't one an error is reported.

0925 MK_ALLOC   PUSH HL
0926            PUSH BC
0927            LD   HL,#3A00            Address where disk bitmap is located.
092A            LD   DE,#0401            Start with track 4, sector 1.
092D            LD   C,0                 Clear bitmap offset.
092F MK_ALL1    LD   A,(HL)
0930            CP   #FF
0932            JR   NZ,#0946,MK_ALL3    Jump if there is a free sector here.
0934            LD   A,E                 Otherwise update sector number.
0935            ADD  A,8                 Each byte holds 8 sectors.
0937            LD   E,A
0938            SUB  10                  But each track holds 10.
093A            JR   C,#0942,MK_ALL2     Jump if still on the same track, i.e.
093C            JR   Z,#0942,MK_ALL2     with sectors <=9 and 10.
093E            LD   E,A                 Otherwise the next sector has been
093F            CALL #0956,NEXT_TRACK    computed, next track is computed now.
0942 MK_ALL2    INC  C                   Increase bitmap offset.
0943            INC  HL                  Next byte of bitmap.
0944            JR   #092F,MK_ALL1       Find a free sector.

Now the routine continues to find which sector is free.

0946 MK_ALL3    LD   B,1                 Reset bit pointer.
0948 MK_ALL4    LD   A,(HL)
0949            AND  B
094A            JR   Z,#0968,MK_ALLOC5   Jump if free sector has been found.
094C            CALL #0D7E,NEXT_SEC      Increase sector number.
094F            CALL Z,#0956,NEXT_TRACK  Next track if sector is on it.
0952            RLC  B                   Test next sector.
0954            JR   #0948,MK_ALL4

THE 'NEXT TRACK' SUBROUTINE
This subroutine checks whether the next track (current track held in D) still
exists and
returns holding the next track in D when it does exist. If the drive capacity
is
exceeded, the 'Not enough SPACE on disc' error is given.

0956 NEXT_TRACK INC  D                   Increase track.
0957            CALL #0985,DRV_CAP       Get number of tracks on current drive
                                         in the A register.
095A            CP   D                   Decrement 'number of files using the
095B            CALL Z,#0B56,DEC_MAPUSE  disk bitmap' and give an error if
095E            JP   Z,#1674,REP_24      drive capacity is exceeded.
0961            AND  #7F                 Mask off side bit.
0963            CP   D
0964            RET  NZ                  Return if side 0 isn't full.
0965            LD   D,128               Otherwise return with track 0, side 1.
0967            RET

THE 'ALLOCATE SECTOR' ROUTINE CONTINUED
Now the 'ALLOCATE SECTOR' routine continues by unfreeing the found sector.

0968 MK_ALL5    LD   A,(HL)              Make found sector unfree in disk
0969            OR   B                   bitmap.
096A            LD   (HL),A
096B            LD   A,B
096C            LD   B,0
096E            PUSH IX
0970            ADD  IX,BC               Add bitmap offset.
0972            OR   (IX+34)             Set new sector in file bitmap.
0975            LD   (IX+34),A
0978            POP  IX                  Restore disk channel pointer.
097A            INC  (IX+31)             Increment number of sectors used.
097D            JR   NZ,#0982,MK_ALL6
097F            INC  (IX+30)
0982 MK_ALL6    POP  BC
0983            POP  HL
0984            RET                      Finished.

THE 'GET DRIVE CAPACITY' SUBROUTINE
This small subroutine returns with the A register holding the capacity of the
selected
drive, as found in the system variables.

0985 DRV_CAP    PUSH HL
0986            LD   HL,#2001            This is TRAKS1, drive 1's capacity.
0989            LD   A,(#3DDA)           Fetch current control port state.
098C            BIT  0,A
098E            JR   NZ,#0991,DRV_CAP1   Jump if drive 1 selected.
0990            INC  HL                  Otherwise point to TRAKS2.
0991 DRV_CAP1   LD   A,(HL)              Fetch drive capacity.
0992            POP  HL
0993            RET                      Finished.

THE 'PRINT NAME' SUBROUTINE
This subroutine is used to print the name of a file during a 'CAT' command and
when the
'overwrite' message is printed.

0994 PRT_NAME   LD   (IX+13),1           Point to the first character of the
                                         name.
0998            CALL #0D97,RPT_HL1       Make HL point to it.
099B            LD   B,10                A name has 10 characters.
099D PRT_NAM1   LD   A,(HL)              Fetch a character.
099E            CALL #1799,PRT_A         Print it.
09A1            INC  HL
09A2            DJNZ #09A2,PRT_NAM1      Repeat for all 10 characters.
09A4            RET

THE 'SCAN CATALOGUE' SUBROUTINE
This very important subroutine scans the CATalogue of a disk, whether this is
for a free
entry, a matching filename, or for printing the directory. On entry all needed
parameters
other than the A register should be contained in UFIA1. The A register
determines where
to scan for as follows: (bits set)
    - bit 0 : Search for the file with the specified program number.
    - bit 1 : Print a 'names only' CATalogue to the current stream. A filename
              must be specified.
    - bit 2 : Print an 'extended' CATalogue to the current stream. A filename
              has to be specified.
    - bit 3 : Search for a file with the specified type and name.
    - bit 4 : Search for a file with the specified filename.
    - bit 5 : Produce the disk bitmap.
    - bit 6 : Find the first unused entry.
Note that some functions exclude others. A return is made with DE holding the
track and
sector number of the found entry, the data buffer holding the sector, RPT
pointing to the
entry and the Zero flag signalling 'success' when set.

09A5 SCAN_CAT   LD   IX,#3AC3            IX points to the disk channel.
09A9            LD   (IX+4),A            Store scan-type.
09AC            XOR  A                   Clear column counter.
09AD            LD   (#3DEB),A
09B0            CALL #06B6,REST          Reset drive head to track 0, DE = 1.
09B3 EACH_ENTRY CALL #05CC,RSAD          Load a CATalogue sector.
09B6 EACH_E1    CALL #0D93,RPT_HL        HL points to the start of data buffer.
09B9            LD   A,(HL)              Fetch file type.
09BA            AND  A                   Jump if it's an unused entry (could be
09BB            JP   Z,#0AA7,SCAN_FREE   ERASEd).
09BE            BIT  0,(IX+4)
09C2            JR   Z,#09D0,NO_PRGNUM   Jump if not searching for a filenumber
09C4            CALL #073D,PROG_NUM      Otherwise load program number into A.
09C7            LD   B,A
09C8            LD   A,(#3E02)           Fetch specified program number.
09CB            CP   B
09CC            RET  Z                   Exit if they are equal.
09CD            JP   #0A88,SCAN_NEXT     Otherwise continue scanning.

NOTE: All entries with numbers below the specified one are considered, this
isn't really
needed.

09D0 NO_PRGNUM  BIT  1,(IX+4)            Jump if a short CATalogue should be
09D4            JR   NZ,#09DC,PRINT_CAT  printed.
09D6            BIT  2,(IX+4)
09DA            JR   Z,#0A55,NO_CAT      Jump if no CATalogue is desired.
09DC PRINT_CAT  LD   (IX+13),11          RPT points to number of sectors used.
09E0            CALL #0D97,RPT_HL1       Make HL hold RPT.
09E3            LD   B,(HL)              Fetch number of sectors used.
09E4            INC  HL
09E5            LD   C,(HL)
09E6            LD   (#3AC3),BC          Store it for printing.
09EA            LD   HL,(#3DD8)          Add it to total number of sectors used
09ED            ADD  HL,BC
09EE            LD   (#3DD8),HL
09F1            BIT  7,A
09F3            JP   NZ,#0A88,SCAN_NEXT  Jump if this entry is hidden.
09F6            CALL #0AB0,MATCH_NAME
09F9            JP   NZ,#0A88,SCAN_NEXT  Jump if filename doesn't match.
09FC            BIT  1,(IX+4)
0A00            JR   NZ,SCAN_1           Jump with short CAT.
0A02            CALL #073D,PROG_NUM      Calculate program number.
0A05            PUSH DE
0A06            LD   H,0                 Program number to HL.
0A08            LD   L,A
0A09            LD   A,32                Use leading spaces.
0A0B            CALL #1758,PRT_N10       Print the program number.
0A0E            POP  DE                  Restore sector address.
0A0F            CALL #1797,PRT_SPACE     Print a space.
0A12 SCAN_1     CALL #0994,PRT_NAME      Print filename.
0A15            BIT  1,(IX+4)
0A19            JR   Z,#0A3F,EXT_CAT     Jump with extended CAT.
0A1B            LD   B,3                 Otherwise print three columns wide.
0A1D            LD   A,(#3E03)           Except when using stream 3.
0A20            CP   3
0A22            JR   NZ,#0A26,SCAN_2
0A24            SLA  B                   Then print six columns wide.
0A26 SCAN_2     LD   A,(#3DEB)           Increment column counter.
0A29            INC  A
0A2A            CP   B
0A2B            JR   Z,#0A34,SCAN_3      Jump if last column reached.
0A2D            LD   (#3DEB),A           Otherwise store column counter and
0A30            LD   A,32                separate the columns with a SPACE.
0A32            JR   #0A3A,SCAN_4

This line is full, the next entry will be printed on the next line.

0A34 SCAN_3     XOR  A                   Clear column counter.
0A35            LD   (#3DEB),A
0A38            LD   A,13                Print a NEWLINE.
0A3A SCAN_4     CALL #1799,PRT_A
0A3D            JR   #0A88,SCAN_NEXT     Continue with the next entry.

With an extended CAT there has to be printed somewhat more.

0A3F EXT_CAT    PUSH DE                  Store track and sector number.
0A40            LD   HL,(#3AC3)          Fetch length of file in sectors.
0A43            LD   A,32                Print it with leading spaces.
0A45            CALL #1752,PRT_N100
0A48            CALL #1797,PRT_SPACE     Print a trailing space.
0A4B            CALL #0D93,RPT_HL        HL points to the start of the entry.
0A4E            LD   A,(HL)              Fetch file type
0A4F            CALL #169B,PRT_TYPE      and print it.
0A52            POP  DE                  Restore track and sector number.
0A53            JR   #0A88,SCAN_NEXT     Continue with the next entry.

Now the routine continues with the search part.

0A55 NO_CAT     BIT  3,(IX+4)
0A59            JR   NZ,#0A61,SCAN_NAME  Jump if searching for name and type.
0A5B            BIT  4,(IX+4)
0A5F            JR   Z,#0A65,SCAN_5      Jump if not searching for name alone.
0A61 SCAN_NAME  CALL #0AB0,MATCH_NAME    Return with Zero flag set to signal
0A64            RET  Z                   'matching name (and type) found'.
0A65 SCAN_5     BIT  5,(IX+4)
0A69            JR   Z,#0A88,SCAN_NEXT   Jump if no disk map wanted.

This part of the routine builds up the bitmap.

0A6B            PUSH IX
0A6D            LD   (IX+13),15          RPT points to the start of file bitmap
0A71            CALL #0D97,RPT_HL1       Make HL hold RPT.
0A74            LD   IX,#3A00            Start of disk bitmap.
0A78            LD   B,195               There are 1560 bits in the bitmap.
0A7A SCAN_MAP   LD   A,(IX+0)            Fetch a disk map byte.
0A7D            OR   (HL)                Incorporate the corresponding file map
0A7E            LD   (IX+0),A            byte.
0A81            INC  IX                  Point to the next map bytes.
0A83            INC  HL
0A84            DJNZ #0A7A,SCAN_MAP      Repeat for all map bytes.
0A86            POP  IX                  Restore disk channel pointer.

Another entry has been handled, go on with the next.

0A88 SCAN_NEXT  LD   A,(IX+14)           Fetch RPT-hi.
0A8B            CP   1                   Jump if the second entry has been
0A8D            JR   Z,#A098,SCAN_6      handled.
0A8F            CALL #0DAA,RES_RPT       Reset RPT.
0A92            INC  (IX+14)             Point to the second entry.
0A95            JP   #09B6,EACH_E1       Repeat for this entry.

The next CAT sector has to be retrieved (if there is one).

0A98 SCAN_6     CALL #0D7E,NEXT_SEC      Calculate next sector.
0A9B            JP   NZ,#09B3,EACH_ENTRY Jump if on same track.
0A9E            INC  D                   Otherwise next track.
0A9F            LD   A,D
0AA0            CP   4
0AA2            JP   NZ,#09B3,EACH_ENTRY Jump if still a CATalogue track.
0AA5            AND  A                   Otherwise signal 'unsuccessfull' and
0AA6            RET                      exit.

An unused entry was found, so if we are searching for one then exit else
continue.

0AA7 SCAN_FREE  LD   A,(IX+4)            Fetch scan-type.
0AAA            CPL                      Invert all bits.
0AAB            BIT  6,A
0AAD            RET  Z                   Return if searching for a free entry.
0AAE            JR   #0A88,SCAN_NEXT     Otherwise continue with next entry.

THE 'MATCH NAME' SUBROUTINE
This subroutine checks whether the filename and, when needed, directory
description of
the current entry matches the specification. If they don't match the Zero flag
is
returned reset.

0AB0 MATCH_NAME PUSH IX                  Store disk channel pointer.
0AB2            CALL #0D93,RPT_HL        HL points to the start of the entry.
0AB5            LD   B,11                Length of file description.
0AB7            BIT  3,(IX+4)
0ABB            LD   IX,#3E05            IX points to the file description in
                                         UFIA1.
0ABF            JR   Z,#0AD1,MATCH_N2    Jump if directory description doesn't
                                         need to match.
0AC1 MATCH_N1   LD   A,(IX+0)            Fetch character of search string.
0AC4            CP   42,"*"              Jump if it's a '*', then all other
0AC6            JR   Z,#0AD6,MATCH_N3    characters don't matter.
0AC8            CP   63,"?"              Jump if it's a '?', then this
0ACA            JR   Z,#0AD1,MATCH_N2    character doesn't matter.
0ACC            XOR  (HL)                Compare with entries character.
0ACD            AND  #DF                 Capitalize.
0ACF            JR   NZ,#0AD6,MATCH_N3   Jump if they don't match.
0AD1 MATCH_N2   INC  IX                  Next character.
0AD3            INC  HL
0AD4            DJNZ #0AC1,MATCH_N1      Repeat for all characters.
0AD6 MATCH_N3   POP  IX                  Restore disk channel pointer.
0AD8            RET                      Return with Zero set signalling
                                         'match'.

THE 'OPEN A FILE FOR SAVE' SUBROUTINE
This subroutine opens a file, with the specified filename, for saving. If the
filename
wasn't used the file is opened, a return is made with the Zero flag set to
signal
'successfull'. If the filename was used, the 'OVERWRITE' message is printed,
when the 'Y'
key is pressed the existing file is ERASEd and the opening is retried.
Otherwise the
routine returns with the Zero flag reset to signal 'unsuccessfull'.

0AD9 OFSM_2     PUSH IX                  Store disk channel pointer.
0ADB            LD   A,(#3DEF)           This is (MAPUSED), the (in)famous
                                         @7663. It holds the number of files
                                         which are using the disk bitmap.
0ADE            CP   0
0AE0            LD   A,%00010000         Scan catalogue for specified filename.
0AE2            JR   NZ,#0AF0,OFSM_SCAN  Jump if (@7663)<>0, the disk bitmap
                                         isn't to be rebuild.
0AE4            LD   HL,#3A00            Otherwise clear the disk bitmap.
0AE7            LD   B,195
0AE9 OFSM_CLR   LD   (HL),0
0AEB            INC  HL
0AEC            DJNZ #0AE9,OFSM_CLR
0AEE            LD   A,%00110000         Scan catalogue for specified filename
                                         and produce a disk bitmap.
0AF0 OFSM_SCAN  CALL #09A5,SCAN_CAT
0AF3            JR   NZ,#0B1C,OFSM_FREE  Jump if filename not used.
0AF5            PUSH DE                  Otherwise store sector address.
0AF6            RST  #10,CALBAS          Clear the lower part of the screen by
0AF7            DEFW #0D6E,CLS_LOWER     calling 'CLS_LOWER' in 'main' ROM.
0AF9            SET  5,(IY+2)            Signal 'lower screen has to be
                                         cleared'. (TV_FLAG)
0AFD            CALL #17FE,MESG_1        Print 'OVERWRITE' message.
0B00            CALL #0994,PRT_NAME      Print filename.
0B03            CALL #1823,MESG_3        Print 'Y/N' message.
0B06            CALL #0B60,TEST_Y        Test the 'Y' key.
0B09            JR   Z,#0B0F,OFSM_ERASE  Jump if 'Y' was pressed.
0B0B            POP  DE                  When any other key was pressed the
0B0C            POP  IX                  routine returns with Zero reset to
0B0E            RET                      signal 'unsuccessfull'.

The filename existed already, the user wants it to be overwritten, so ERASE it.

0B0F OFSM_ERASE POP  DE                  Restore track and sector number.
0B10            CALL #0D93,RPT_HL        Make HL point to the entry to be
                                         overwritten.
0B13            LD   (HL),0              ERASE this file.
0B15            CALL #0584,WSAD          Write the entry back to disk.
0B18            POP  IX                  Restore disk channel pointer.
0B1A            JR   #0AD9,OFSM_2        Retry opening the file.

The filename wasn't used so now the file can be opened.

0B1C OFSM_FREE  POP  IX                  Restore disk channel pointer.
0B1E            PUSH IX
0B20            LD   B,0                 Clear the file entry space in the disk
0B22 OFSM_CLR   LD   (IX+19),0           channel.
0B26            INC  IX
0B28            DJNZ #0B22,OFSM_CLR
0B2A            POP  IX                  Restore disk channel pointer.
0B2C            PUSH IX
0B2E            LD   HL,#3E05            HL points to the file descriptor in
                                         UFIA1.
0B31            LD   B,11                Length of file descriptor.
0B33 OFSM_FDESC LD   A,(HL)              Copy file descriptor to the file entry
0B34            LD   (IX+19),A           space in the disk channel.
0B37            INC  HL
0B38            INC  IX
0B3A            DJNZ #0B33,OFSM_FDESC
0B3C            POP  IX                  Restore disk channel pointer.
0B3E            CALL #0925,MK_ALLOC      Allocate a sector.
0B41            CALL #0DBA,STORE_SEC     Store its track and sector number.
0B44            LD   (IX+32),D           Store its sector address also into the
0B47            LD   (IX+33),E           file entry space.
0B4A            CALL #0DAA,RES_RPT       Reset RPT.
0B4D            LD   A,(#3DEF)           Increment (MAPUSED), there is one more
0B50            INC  A                   file which uses the disk bitmap.
0B51            LD   (#3DEF),A
0B54            XOR  A                   Return with Zero flag set to signal
0B55            RET                      'successfull'.

THE 'DECREMENT MAPUSE' SUBROUTINE
This small subroutine decrements the MAPUSED system variable. This variable
keeps track
of the number of files using the disk bitmap. When it reaches 0 the bitmap has
to be
rebuild.

0B56 DEC_MAPUSE PUSH AF
0B57            LD   A,(#3DEF)           Decrease (MAPUSED), the number of
0B5A            DEC  A                   files using the disk bitmap.
0B5B            LD   (#3DEF),A
0B5E            POP  AF
0B5F            RET

THE 'TEST FOR YES' SUBROUTINE
This subroutine tests whether the 'Y'-key is pressed, it returns with the Zero
flag set
if it was, reset otherwise.

0B60 TEST_Y     CALL #0B75,BEEP          Produce a 'middle C' for one second.
0B63 TEST_Y1    RST  #10,CALBAS          The 'main' ROM is called to scan the
0B64            DEFW #028E,KEY_SCAN      keyboard.
0B66            RST  #10,CALBAS          It is also called to determine if a
0B67            DEFW #031E,KEY_TEST      key was pressed.
0B69            JR   NC,#0B63,TEST_Y1    Repeat scanning and testing until a
                                         key has been pressed.
0B6B            AND  #DF                 Capitalize.
0B6D            CP   89,"Y"              Set the Zero flag if it was the
0B6F            PUSH AF                  'Y'-key.
0B70            RST  #10,CALBAS          Again the 'main' ROM is called, this
0B71            DEFW #0D6E,CLS_LOWER     time for clearing the lower screen.
0B73            POP  AF                  Retrieve Zero flag.
0B74            RET                      Finished.

THE 'MAKE A BEEP' SUBROUTINE
This subroutine produces a beep (the note 'middle C' in fact) for one second.

0B75 BEEP       PUSH HL
0B76            PUSH DE
0B77            PUSH BC
0B78            PUSH IX
0B7A            LD   HL,1642             Parameters needed by 'BEEPER' to
0B7D            LD   DE,261              produce a 'middle C'.
0B80            RST  #10,CALBAS          Produce the note.
0B81            DEFW #03B5,BEEPER
0B83            POP  IX
0B85            POP  BC
0B86            POP  DE
0B87            POP  HL
0B88            RET

THE 'CLOSE A SAVE FILE' SUBROUTINE
This subroutine closes a save file, by writing the last sector (contained in
the data
buffer) to disk and by writing the CATalogue entry.

0B89 CFSM       CALL #0D97,RPT_HL1       HL points to the first unused position
                                         in the data buffer.
0B8C            LD   A,C                 C holds buffer offset-lo.
0B8D            AND  A
0B8E            JR   NZ,#0B95,CFSM_FILL  Jump if buffer isn't full yet.
0B90            LD   A,B                 B holds buffer offset-hi.
0B91            CP   2
0B93            JR   Z,#0B9C,CFSM_SAVE   Jump if buffer is full.
0B95 CFSM_FILL  LD   (HL),0              Otherwise fill up buffer with zero's.
0B97            CALL #0DA2,INC_RPT       Increment RPT.
0B9A            JR   #0B89,CFSM          And close the file.

The last sector is ready to be saved, it has been filled up with zero's if
needed.

0B9C CFSM_SAVE  CALL #0DB3,FETCH_SEC     Fetch last sector's track and sector
0B9F            CALL #0584,WSAD          number and save it to disk.
0BA2            CALL #0B56,DEC_MAPUSE    One file less uses the disk bitmap.
0BA5            PUSH IX                  Store disk channel pointer.
0BA7            LD   A,%01000000         Search the CATalogue for an unused
0BA9            CALL #09A5,SCAN_CAT      entry.
0BAC            JP   NZ,#1676,REP_25     If none found report 'Directory FULL'.
0BAF            CALL #0D93,RPT_HL        HL points to the entry.
0BB2            LD   (#3ACA),IX          Store disk channel pointer 2, this one
                                         points to the DFCA.
0BB6            POP  IX                  Restore disk channel pointer 1, this
                                         one can point to 'main' RAM (OPENTYPE)
0BB8            PUSH IX                  Store it again.
0BBA            LD   B,0                 Copy the file entry to the CAT entry
0BBC
CFSM_ENTRY LD   A,(IX+19)           in the data buffer.
0BBF            LD   (HL),A
0BC0            INC  IX
0BC2            INC  HL
0BC3            DJNZ #0BBC,CFSM_ENTRY
0BC5            LD   IX,(#3ACA)          Restore disk channel pointer 2.
0BC9            CALL #0584,WSAD          Write the sector to disk.
0BCC            POP  IX                  Restore disk channel pointer 1.
0BCE            RET                      Finished.

THE 'OPEN A FILE FOR LOAD' SUBROUTINE
This subroutine opens a file, with the specified filename, for loading. If the
filename
isn't found an error is given. If the filename is found it is opened and the
first sector
is loaded into the data buffer.

0BCF HGFLE_2    LD   A,(#3E04)           Fetch device description from UFIA1.
0BD2            AND  #DF                 Capitalize.
0BD4            CP   80,"P"
0BD6            JR   NZ,#0BFC,HGFL_NONUM Jump if no program number specified.
0BD8            LD   A,%00000001         Search for the specified program
0BDA            CALL #09A5,SCAN_CAT      number.
0BDD            JP   NZ,#1678,REP_26     If file isn't found report 'File NOT
                                         FOUND'.
0BE0            CALL #0D93,RPT_HL        HL points to the entry.
0BE3            LD   DE,#3E05            Copy the 11 byte file descriptor to
0BE6            LD   BC,11               UFIA1.
0BE9            LDIR
0BEB            LD   (IX+13),211         RPT points to the file header of the
                                         file.
0BEF            CALL #0D97,RPT_HL1       Make HL point to it.
0BF2            LD   DE,#3E10            Copy the 9 byte file header to UFIA1.
0BF5            LD   BC,9
0BF8            LDIR
0BFA            JR   #0C04,LOAD_1ST      Jump forward to load the first sector.

Now search for the file with the given name.

0BFC HGFL_NONUM LD   A,%00010000         Search for the specified filename.
0BFE            CALL #09A5,SCAN_CAT      If file isn't found report 'File NOT
0C01            JP   NZ,#1678,REP_26     FOUND'.
                                         Otherwise the first sector is loaded
                                         by entering the 'LOAD FIRST SECTOR'
                                         subroutine below.

THE 'LOAD FIRST SECTOR' SUBROUTINE
When the CAT entry of the file to be loaded is found, this routine can be used
to fetch
the first sector of the file. The first sector holds the 9 byte file header
(with certain
filetypes) which should be identical to the 9 byte file header present in the
CAT entry.

0C04 LOAD_1ST   CALL #0D93,RPT_HL        HL points to the entry.
0C07            LD   DE,#3E1E            Copy the 11 byte file descriptor to
0C0A            LD   BC,11               UFIA2.
0C0D            LDIR
0C0F            LD   (IX+13),220         RPT points to the SNAPSHOT registers,
                                         that is when they are present.
0C13            CALL #0D97,RPT_HL1       Make HL point to it.
0C16            LD   DE,#3FEA            Copy the 22 SNAPSHOT values to the
0C19            LD   BC,22               internal stack bottom.
0C1C            LDIR
0C1E            LD   (IX+13),13          RPT points to track and sector number.
0C22            CALL #0D97,RPT_HL1       Now HL points to it also.
0C25            LD   D,(HL)              Fetch track and sector number.
0C26            INC  HL
0C27            LD   E,(HL)
0C28            JP   #05CC,RSAD          And exit while loading the first
                                         sector.

THE 'FORMAT A DISK' ROUTINE
This routine formats a disk by writing one track at a time to disk. The track
is first
build up in 'main' RAM. After the formatting is completed, the other disk is
completely
copied (cloned) or the disk is checked for bad sectors.

0C2B FORMAT_RUN CALL #0702,TEST_DRV      See if the drive is defined.
0C2E            CALL #071C,SET_DRVSD
0C31            LD   B,20                First step 20 times inward.
0C33 FRMT_1     PUSH BC
0C34            CALL #0DCF,STEP_IN
0C37            POP  BC
0C38            DJNZ #0C33,FRMT_1
0C3A            CALL #06A4,TRACK_0       Then position the head above track 0.
0C3D            LD   IX,#3AC3            IX points to the DFCA.
0C41 FRMT_TRK   CALL #0CF5,MK_TRK_DD     Build up a double density track.
0C44            LD   C,%11110000         Write track, disable spin-up sequence,
                                         no delay, enable precompensation.
0C46            CALL #056E,PRECOMP1      Why call this routine ? The precomp.
                                         has already been enabled.
0C49            LD   HL,49152            HL points to the track build up in
                                         'main' memory.
0C4C            CALL #0599,WR_OP         Write the track.
0C4F            CALL #0692,STEP_DELAY    Wait a moment.
0C52            INC  D                   Next track.
0C53            CALL #0985,DRV_CAP       Get drive capacity in A.
0C56            CP   D
0C57            JR   Z,#0C79,FRMT_DONE   Jump if all tracks have been formatted
0C59            AND  #7F                 Mask off side.
0C5B            CP   D
0C5C            JR   Z,#0C6E,FRMT_SIDE1  Jump if side1 hasn't been formatted.
0C5E            CALL #0DCF,STEP_IN       Next track.

The following code determines the skew, i.e. the shifting between the sectors
of a track
and the previous track. The +D uses a skew of +2, so sector 1 on track T lies
adjacent to
sector 9 on track T+1.

0C61            DEC  E
0C62            JR   NZ,#0C66,FRMT_2     Jump if sector >= 1.
0C64            LD   E,10                Sector numbers have range 1..10.
0C66 FRMT_2     DEC  E
0C67            JR   NZ,#0C6B,FRMT_3     Jump if sector >= 1.
0C69            LD   E,10                This instruction is never reached ??
0C6B FRMT_3     JP   #0C41,FRMT_TRK      Format the next track.

If a double sided drive is used, the formatting continues on track 0 side 1.

0C6E FRMT_SIDE1 CALL #06A4,TRACK_0       Reset drive head.
0C71            LD   D,128               Track 0, side 1.
0C73            CALL #071C,SET_DRVSD     Set drive, side, density, etc.
0C76            JP   #0C41,FRMT_TRK      Continue formatting.

When the formatting of all tracks is completed, the routine checks whether it
is
supposed to copy another disk to this one, or to verify the disk.

0C79 FRMT_DONE  CALL #06B6,REST          Reset drive head.
0C7C            LD   A,(#3E1A)
0C7F            CP   #FF
0C81            JR   Z,#0CD3,FRMT_CHK    Jump if UFIA2 is empty.

When the disk in the other drive is to be cloned, it will be copied a track at
a time.

0C83 FRMT_COPY  LD   HL,49152            Address of track buffer.
0C86            LD   (#3AC5),HL          Store load address.
0C89            LD   (#3AC8),HL          Store save address.
0C8C            LD   A,(#3E1A)           Fetch source drive number from UFIA2.
0C8F            CALL #0705,TEST_DRV1     Check and set drive.
0C92 FRMT_C1    CALL #05CC,RSAD          Load a sector.
0C95            PUSH DE                  Store track and sector number.
0C96            LD   HL,#3BD6            DRAM sector buffer address.
0C99            LD   DE,(#3AC5)          Fetch load address.
0C9D            LD   BC,512              BC holds sector length.
0CA0            LDIR                     Copy the contents of the buffer to
                                         'main' RAM.
0CA2            LD   (#3AC5),DE          Store new load address.
0CA6            POP  DE                  Restore track and sector number.
0CA7            CALL #0D7E,NEXT_SEC      Compute next sector number.
0CAA            JR   NZ,#0C92,FRMT_C1    Jump if there is still a sector on
this
                                         track.
0CAC            LD   A,(#3E01)           Fetch destination drive from UFIA1.
0CAF            CALL #0705,TEST_DRV1     Check and set drive.
0CB2 FRMT_C2    PUSH DE                  Store track and sector number.
0CB3            LD   HL,(#3AC8)          Fetch save address.
0CB6            LD   DE,#3BD6            DRAM sector buffer address.
0CB9            LD   BC,512              BC holds sector length.
0CBC            LDIR                     Copy a sector to the sector buffer.
0CBE            LD   (#3AC8),HL          Store new save address.
0CC1            POP  DE                  Restore track and sector number.
0CC2            CALL #0584,WSAD          Save the sector.
0CC5            CALL #0D7E,NEXT_SEC      Compute next sector number.
0CC8            JR   NZ,#0CB2,FRMT_C2    Jump if not all sectors on this track
                                         have been written.
0CCA            CALL #0CE4,NXT_TRK       Compute next track number.
0CCD            JR   NZ,#0C83,FRMT_COPY  Jump if not all tracks have been
                                         copied.
0CCF            EI                       Enable interrupts and exit via
0CD0            JP   #06B6,REST          'REST'.

The routine now verifies if all sectors are readable. An error is given if a
sector
can't be read, it would have been more usefull if a 'badsectors' file was
saved.

0CD3 FRMT_CHK   CALL #05CC,RSAD          Load a sector.
0CD6            CALL #0D7E,NEXT_SEC      Compute next sector number.
0CD9            JR   NZ,#0CD3,FRMT_CHK   Jump if not all sectors on one track
                                         have been loaded.
0CDB            CALL #0CE4,NXT_TRK       Compute next track number.
0CDE            JR   NZ,#0CD3,FRMT_CHK   Jump if not all tracks on the disk
have
                                         been verified.
0CE0            EI                       Enable interrupts and exit via
0CE1            JP   #06B6,REST          'REST'.

THE 'NXT_TRK' SUBROUTINE
This subroutine is almost the same as the 'NEXT_TRACK' subroutine at #0956. But
the
differences are essential. No error is given when a non existent track is
reached and the
Zero flag is used to signal 'no more tracks on this side' when set.

0CE4 NXT_TRK    INC  D                   Increase track number.
0CE5            CALL #0985,DRV_CAP       Get drive capacity in A.
0CE8            CP   D
0CE9            RET  Z                   Return with Zero set if last track
                                         reached.
0CEA            AND  #7F                 Mask off side bit.
0CEC            CP   D
0CED            RET  NZ                  Return with Zero reset if last track
                                         on side0 hasn't been reached.
0CEE            CALL #06B6,REST          Reset drive head.
0CF1            LD   D,128               Track 0, side 1.
0CF3            CP   D                   Reset Zero flag.
0CF4            RET

THE 'BUILD UP A DD TRACK' SUBROUTINE
This subroutine builds up a double density track in the 'main' memory starting
at
address 49152.

0CF5 MK_TRK_DD  LD   HL,49152            Start of track buffer.
0CF8            LD   BC,#3C4E            Store 60 bytes #4E. GAP I.
0CFB            CALL #0D79,B_TIMES_C
0CFE            LD   B,10                Number of sectors on a track.
0D00 MK_TRK_DD1 PUSH BC
0D01            LD   BC,#0C00            12 bytes #00. Last part of GAP III.
0D04            CALL #0D79,B_TIMES_C
0D07            LD   BC,#03F5            3 bytes #F5 (written as #A1).
0D0A            CALL #0D79,B_TIMES_C
0D0D            LD   BC,#01FE            1 byte  #FE (ID field ID).
0D10            CALL #0D79,B_TIMES_C
0D13            LD   A,D                 Fetch track number.
0D14            AND  #7F                 Mask side bit.
0D16            LD   C,A
0D17            LD   B,1                 1 byte  track number.
0D19            CALL #0D79,B_TIMES_C
0D1C            LD   A,D                 Fetch track again.
0D1D            AND  #80                 Keep only side bit.
0D1F            RLCA                     Rotate it to bit 0.
0D20            LD   C,A
0D21            LD   B,1                 1 byte  side number.
0D23            CALL #0D79,B_TIMES_C
0D26            LD   C,E                 Fetch sector number.
0D27            CALL #0D7E,NEXT_SEC      Increment sector number.
0D2A            LD   B,1                 1 byte  sector number.
0D2C            CALL #0D79,B_TIMES_C
0D2F            LD   BC,#0102            1 byte  #02 (sector length = 512).
0D32            CALL #0D79,B_TIMES_C
0D35            LD   BC,#01F7            1 byte  #F7 (two CRC bytes written).
0D38            CALL #0D79,B_TIMES_C
0D3B            LD   BC,#164E            22 bytes #4E. GAP II.
0D3E            CALL #0D79,B_TIMES_C
0D41            LD   BC,#0C00            12 bytes #00.
0D44            CALL #0D79,B_TIMES_C
0D47            LD   BC,#03F5            3 bytes #F5 (written as #A1).
0D4A            CALL #0D79,B_TIMES_C
0D4D            LD   BC,#01FB            1 byte  #FB (data field ID).
0D50            CALL #0D79,B_TIMES_C
0D53            LD   BC,#0000            512 bytes #00. Data bytes.
0D56            CALL #0D79,B_TIMES_C
0D59            CALL #0D79,B_TIMES_C
0D5C            LD   BC,#01F7            1 byte  #F7 (two CRC bytes written).
0D5F            CALL #0D79,B_TIMES_C
0D62            LD   BC,#184E            24 bytes #4E. First part of GAP III.
0D65            CALL #0D79,B_TIMES_C
0D68            POP  BC                  Retrieve sector counter.
0D69            DEC  B                   Repeat until all 10 sectors have been
0D6A            JP   NZ,#0D00,MK_TRK_DD1 build up.
0D6D            LD   BC,#004E            768 bytes #00. GAP IV.
0D70            CALL #0D79,B_TIMES_C
0D73            CALL #0D79,B_TIMES_C
0D76            JP   #0D79,B_TIMES_C

THE 'STORE B TIMES BYTE C' SUBROUTINE
This subroutine is used in the construction of a track in memory, it stores the
byte
held in the C register, B times.

0D79 B_TIMES_C  LD   (HL),C              Store C.
0D7A            INC  HL                  Next address.
0D7B            DJNZ #0D79,B_TIMES_C     Repeat until B=0.
0D7D            RET

THE 'NEXT SECTOR' SUBROUTINE
This subroutine computes the next sector number in E, it returns with the Zero
flag set
indicating 'next track'.

0D7E NEXT_SEC   INC  E                   Increment sector number.
0D7F            LD   A,E
0D80            CP   11
0D82            RET  NZ                  Return with Zero reset signalling
                                         'same track'.
0D83            LD   E,1                 Otherwise start with sector 1 again.
0D85            RET                      Return with Zero set signalling 'next
                                         track'.

THE 'MAKE HL POINT TO BUFFER' SUBROUTINE
This subroutine returns with HL holding the start of the data buffer. On entry
IX must
point to the start of the disk channel.

0D86 HL_BUFFER  PUSH BC
0D87            PUSH IX                  Disk channel pointer to BC.
0D89            POP  BC
0D8A            LD   L,(IX+15)           Fetch data buffer offset.
0D8D            LD   H,(IX+16)
0D90            ADD  HL,BC               HL now points to the data buffer.
0D91            POP  BC
0D92            RET

THE 'FETCH RPT INTO HL' SUBROUTINE
This subroutine returns with HL holding the RAM PoinTer, which points to the
next data
byte in the data buffer. When entering at #0D97, RPT-lo is first reset.

0D93 RPT_HL     LD   (IX+13),0           Reset RPT-lo.
0D97 RPT_HL1    CALL #0D86,HL_BUFFER     HL points to the data buffer.
0D9A            LD   B,(IX+14)           Fetch RPT offset into BC.
0D9D            LD   C,(IX+13)
0DA0            ADD  HL,BC               Add the offset to the start of the
                                         data buffer.
0DA1            RET                      Finished.

THE 'INCREMENT RPT' SUBROUTINE
This small subroutine increments the RAM PoinTer offset.

0DA2 INC_RPT    INC  (IX+13)             Increment RPT-lo.
0DA5            RET  NZ
0DA6            INC  (IX+14)             Increment RPT-hi when necessary.
0DA9            RET

THE 'RESET RPT' SUBROUTINE
This small subroutine resets the RAM PoinTer offset.

0DAA RES_RPT    LD   (IX+13),0           Clear RPT offset.
0DAE            LD   (IX+14),0
0DB2            RET

THE 'FETCH SECTOR ADDRESS' SUBROUTINE
This subroutine returns with DE holding the stored track and sector number.

0DB3 FETCH_SEC  LD   D,(IX+18)
0DB6            LD   E,(IX+17)
0DB9            RET

THE 'STORE SECTOR ADDRESS' SUBROUTINE
This subroutine stores the track and sector number held in DE into the disk
channel.

0DBA STORE_SEC  LD   (IX+18),D
0DBD            LD   (IX+17),E
0DC0            RET

THE 'GET SECTOR ADDRESS' SUBROUTINE
This subroutine returns with DE holding the stored track and sector number and
the track
and sector number held in HL stored into the disk channel.

0DC1 GET_SECTOR CALL #0DB3,FETCH_SEC     Fetch the stored track and sector
0DC4            LD   (IX+18),H           number. And store the track and sector
0DC7            LD   (IX+17),L           number held in HL.
0DCA            RET

THE 'STEP' SUBROUTINES
These two small subroutines are used to move the drive head one step in or out.

0DCB STEP_OUT   LD   C,%01111000         Step-out, update track register,
0DCD            JR   STEP                disable spin-up sequence, no verify,
                                         step rate 6 ms.
0DCF STEP_IN    LD   C,%01011000         Step-in, update track register,
                                         disable spin-up sequence, no verify,
                                         step rate 6 ms.
0DD1 STEP       CALL #06F7,LD_COM_REG    Execute the command, move one track.
0DD4            JP   #0692,STEP_DELAY    Wait for the number of msec's
                                         specified by (STPRAT).
 ____________________________
|Previous|Next|Contents|Index|
###### 0dd7-hookcode.html ######
###### 0dd7-hookcode.html ######


 ____________________________
|Previous|Next|Contents|Index|
The 'Hook code' routines

The following routines are called by the 'hook and command code' routine at
#228E (in
RAM) whenever a hook code was used.

THE 'HOOK CODE ADDRESSES' TABLE
This jump table consists of the 24 addresses of the routines called by using
the various
'hook codes' in the range #1B..#32 (27..50).

0DD7 IF1_HOOK   DEFW #0E08,CONS_IN       Hook code #1B, 27.
0DD9            DEFW #0E1B,CONS_OUT      Hook code #1C, 28.
0DDB            DEFW #0E07,BCHAN_IN      Hook code #1D, 29.
0DDD            DEFW #0E07,BCHAN_OUT     Hook code #1E, 30.
0DDF            DEFW #0E2B,PRT_OUT       Hook code #1F, 31.
0DE1            DEFW #0E30,KBD_TEST      Hook code #20, 32.
0DE3            DEFW #0E38,SEL_DRIVE     Hook code #21, 33.
0DE5            DEFW #0E52,OP_TEMP_M     Hook code #22, 34.
0DE7            DEFW #1102,CLOSE_M2      Hook code #23, 35.
0DE9            DEFW #111E,ERASE         Hook code #24, 36.
0DEB            DEFW #11A1,READ_SEQ      Hook code #25, 37.
0DED            DEFW #11E1,WR_RECD       Hook code #26, 38.
0DEF            DEFW #11AD,RD_RANDOM     Hook code #27, 39.
0DF1            DEFW #1269,RD_SECTOR     Hook code #28, 40.
0DF3            DEFW #126A,RD_NEXT       Hook code #29, 41.
0DF5            DEFW #126B,WR_SECTOR     Hook code #2A, 42.
0DF7            DEFW #0EF4,SET_T_MCH     Hook code #2B, 43.
0DF9            DEFW #126C,DEL_M_BUF     Hook code #2C, 44.
0DFB            DEFW #1276,OP_TEMP_N     Hook code #2D, 45.
0DFD            DEFW #1277,CLOSE_NET     Hook code #2E, 46.
0DFF            DEFW #1278,GET_PACK      Hook code #2F, 47.
0E01            DEFW #1279,SEND_PACK     Hook code #30, 48.
0E03            DEFW #127A,HOOK_31       Hook code #31, 49.
0E05            DEFW #12C1,HOOK_32       Hook code #32, 50.

THE 'RS232 NOT SUPPORTED' SUBROUTINE
The 'BCHAN_IN' and 'BCHAN_OUT' 'hook codes' are not supported (the +D has no
RS232 link).

0E07 UNDEFINED1 RET

THE 'CONSOLE INPUT' SUBROUTINE
Called by using 'hook code' 27 (#1B), it simply waits until a key is pressed. A
return
is made with the A register holding the character code.

0E08 CONS_IN    RES  5,(IY+1)            Signal 'ready for a new key'.
0E0C WTKEY      EI                       Enable interrupts.
0E0D            HALT                     Wait for an interrupt.
0E0E            RST  #10,CALBAS          Call the keyboard scan routine in the
0E0F            DEFW #02BF,KEYBOARD      'main' ROM.
0E11            BIT  5,(IY+1)            Repeat the scan until a key has been
0E15            JR   Z,#0E0C,WTKEY       pressed.
0E17            LD   A,(23560)           Fetch the character code from (LAST_K)
0E1A            RET

THE 'CONSOLE OUTPUT' SUBROUTINE
By using 'hook code' 28 (#1C) the character held in the A register is printed
on the
screen, with scroll suppressed.

0E1B CONS_OUT   PUSH AF
0E1C            LD   A,254               Use stream '-2' (attached to "S" the
                                         channel).
0E1E OUT_CODE   LD   HL,23692            This is SCR_CT.
0E21            LD   (HL),#FF            Set scroll counter.
0E23            RST  #10,CALBAS          Call 'CHAN_OPEN' in the 'main' ROM to
0E24            DEFW #1601,CHAN_OPEN     make stream -2 the current.
0E26            POP  AF
0E27            RST  #10,CALBAS          Print the character to the current
0E28            DEFW #0010,PRINT_A_1     stream.
0E2A            RET

THE 'PRINTER OUTPUT' SUBROUTINE
This subroutine is called by using 'hook code' 31 (#1F). It is identical to the
preceding one, but the output is directed to stream 3 (normally the printer).

0E2B PRT_OUT    PUSH AF
0E2C            LD   A,3                 Select stream 3.
0E2E            JR   #0E1E,OUT_CODE

THE 'KEYBOARD TEST' SUBROUTINE
This is called using 'hook code' 32 (#20). A return is made with the Zero flag
reset if
a key is pressed.

0E30 KBD_TEST   XOR  A                   Clear A, allowing for the whole
                                         keyboard to be examined.
0E31            IN   A,(254)             Read the keyboard.
0E33            AND  #1F                 Keep only the keyboard bits.
0E35            SUB  #1F                 Return with sign negative and Zero
0E37            RET                      flag reset if a key is pressed.

THE 'SELECT DRIVE' SUBROUTINE
This subroutine is called by using 'hook code' 33 (#21). On entry, A holds the
drive
number; if A isn't equal to 1 or 2 nothing is done.

0E38 SEL_DRIVE  CP   1
0E3A            JR   Z,#0E42,SEL_DRIVE1  Jump if drive 1 is to be selected.
0E3C            CP   2
0E3E            JR   Z,#0E42,SEL_DRIVE1  Jump if drive 2 is to be selected.
0E40            XOR  A
0E41            RET                      Otherwise exit.
0E42 SEL_DRIVE1 LD   B,A
0E43            LD   (#3ACE),A
0E46            LD   A,(#3DDA)           Fetch current control port state.
0E49            AND  #FC                 Drop the drive select bits.
0E4B            OR   B                   Use the new drive.
0E4C            LD   (#3DDA),A           Exit setting both current control port
0E4F            OUT  (239),A             state and the control port itself.
0E51            RET

THE 'OPEN TEMP. "M" CHANNEL' SUBROUTINE
This subroutine is used to open a temporary "M" channel in the CHANS area. It
is called
by using 'hook code' 34 (#22). First a temporary "M" channel is created, then
the drive
whose number is held into 'D_STR1' is searched for a file whose name is held
into
'N_STR1'. A sector map is created with each reset bit indicating a free sector.
Various
flags are returned as follows:
    - bit 0 of CHFLAG                    set with 'write' files.
    - bit 1 of RECFLG                    set with 'EOF' block.
    - bit 2 of RECFLG                    set with PRINT-type files.
On exit, HL holds a 'stream data' displacement that may be used to attach the
channel to
a stream.

0E52 OP_TEMP_M  CALL #0EF4,SET_T_MCH     Create a temporary "M" channel.
0E55            PUSH HL                  Save 'stream displacement'.
0E56            LD   A,(IX+25)           Fetch the drive number (CHDRIV).
0E59            CALL #0E38,SEL_DRIVE     Select the drive.
0E5C            PUSH IX
0E5E            LD   DE,14               Make IX point to CHNAME, the name of
0E61            ADD  IX,DE               the wanted file.
0E63            CALL #1146,FIND_FILE     Search for the filename.
0E66            JR   NZ,#0E98,OP_T_2     Jump if not found.
0E68            INC  HL                  Skip number of sectors used.
0E69            INC  HL
0E6A            LD   D,(HL)              Fetch first track and sector.
0E6B            INC  HL
0E6C            LD   E,(HL)
0E6D            LD   IX,#3AC3            Point to the DRAM channel.
0E71            CALL #05CC,RSAD          Read the first sector.
0E74            POP  IX                  Restore channel pointer (in 'main'
0E76            PUSH IX                  RAM).
0E78            LD   DE,540              Microdrive type files consist of
                                         records with a length of 540 bytes
                                         each.
0E7B OP_T_1     PUSH IX                  Store data buffer pointer (in 'main'
                                         RAM).
0E7D            LD   IX,#3AC3            Point to the DRAM channel again.
0E81            CALL #077F,LBYT          Fetch a byte.
0E84            POP  IX                  Restore data buffer pointer.
0E86            LD   (IX+55),A           Loading starts with the data block
                                         preamble (offset 55).
0E89            INC  IX
0E8B            CALL #1265,DEC_DE        Decrement DE.
0E8E            JR   NZ,#0E7B,OP_T_1     Repeat until DE=0.
0E90            POP  IX
0E92            RES  0,(IX+24)           Signal 'read file'.
0E96            POP  HL                  Restore stream 'stream data'.
0E97            RET                      Finished.

0E98 OP_T_2     LD   HL,#3A00            Clear the disk bitmap.
0E9B            LD   B,195
0E9D OP_T_3     LD   (HL),0
0E9F            INC  HL
0EA0            DJNZ #0E9D,OP_T_3
0EA2            LD   A,%00100000         Make new disk bitmap.
0EA4            CALL #09A5,SCAN_CAT
0EA7            POP  IX
0EA9            PUSH IX
0EAB            LD   HL,#3AD6            Points to dir. descr. of DFCA.
0EAE            LD   (HL),6              File is a 'Microdrive file'.
0EB0            INC  HL
0EB1            LD   B,10                Copy the 10 characters of the name.
0EB3 OP_T_4     LD   A,(IX+14)
0EB6            LD   (HL),A
0EB7            INC  IX
0EB9            INC  HL
0EBA            DJNZ #0EB3,OP_T_4
0EBC            LD   B,245               Clear the rest of the CATalogue entry
0EBE OP_T_5     LD   (HL),0              of this file.
0EC0            INC  HL
0EC1            DJNZ #0EBE,OP_T_5
0EC3            LD   HL,#0000            Reset RPT.
0EC6            LD   (#3AD0),HL
0EC9            LD   HL,#3BD6            Clear the first 256 bytes of the data
0ECC            LD   B,0                 buffer.
0ECE OP_T_6     LD   (HL),0
0ED0            INC  HL
0ED1            DJNZ #0ECE,OP_T_6
0ED3            LD   IX,#3AC3
0ED7            CALL #0925,MK_ALLOC      Allocate the first free sector.
0EDA            LD   (#3AD4),DE          Store the track and sector number.
0EDE            LD   IX,#3AD6            Store them also into the CATalogue
0EE2            LD   (IX+13),D           entry.
0EE5            LD   (IX+14),E
0EE8            POP  IX
0EEA            RES  1,(IX+67)           Signal 'Not the EOF block' (RECFLG).
0EEE            RES  2,(IX+67)           Signal 'PRINT-type file' (opened for
0EF2            POP  HL                  writing). Restore stream 'stream data'
0EF3            RET                      Finished.

THE 'SET A TEMP. "M" CHANNEL' SUBROUTINE
This subroutine is also called by using 'hook code' 43 (#2B). It sets a
temporary "M"
channel in the CHANS area. The subroutine returns with IX pointing to the start
of the
channel and HL holding a suitable displacement to be eventually inserted in the
STRMS
area to attach the channel to a stream.

0EF4 SET_T_MCH  LD   IX,(23631)          Fetch (CHANS), the start of the
                                         channel area.
0EF8            LD   DE,20               Make IX point to the start of the
0EFB            ADD  IX,DE               'new' channels.
0EFD SET_T_1    LD   A,(IX+0)
0F00            CP   128
0F02            JR   Z,#0F34,SET_T_3     Jump if the CHANS area is finished.
0F04            LD   A,(IX+4)            Fetch the channel specifier.
0F07            AND  #7F                 Clear bit 7 (drop temporary/permanent
                                         flag).
0F09            CP   "M"
0F0B            JR   NZ,#0F2A,SET_T_2    Jump if not a "M" channel.
0F0D            LD   A,(23766)           Fetch drive number (D_STR1).
0F10            CP   (IX+25)             Compare it with (CHDRIV).
0F13            JR   NZ,#0F2A,SET_T_2    Jump if this channel uses a different
                                         drive.
0F15            LD   BC,(23770)          Fetch length of filename (NSTR_1).
0F19            LD   HL,(23772)          And its startaddress (NSTR_1+2).
0F1C            CALL #0FCC,CHK_NAME      Check name against 'CHNAME' of this
                                         channel.
0F1F            JR   NZ,#0F2A,SET_T_2    Jump if not the same file.
0F21            BIT  0,(IX+24)
0F25            JR   Z,#0F2A,SET_T_2     Jump if it's a 'read file'.
0F27            JP   #12C3,MD_ERROR      Exit if the file is already opened for
                                         writing.
0F2A SET_T_2    LD   E,(IX+9)            Fetch the length of the channel.
0F2D            LD   D,(IX+10)
0F30            ADD  IX,DE               Point to the next channel.
0F32            JR   #0EFD,SET_T_1       Check next channel.

Now the space for the new channel is created at the end of the CHANS area.

0F34 SET_T_3    LD   HL,(23635)          Calculate end of CHANS area ((PROG)-1)
0F37            DEC  HL                  i.e. the start of the channel.
0F38            PUSH HL
0F39            LD   BC,595              Length is '595' bytes.
0F3C            RST  #10,CALBAS          Create the required space by calling
0F3D            DEFW #1655,MAKE_ROOM     'MAKE_ROOM'.
0F3F            POP  DE                  Restore start address of the channel.
0F40            PUSH DE
0F41            LD   HL,#10E9,MCHAN_DATA Start of "M" channel data.
0F44            LD   BC,25
0F47            LDIR                     Store channel data into the channel.
0F49            LD   A,(23766)           Fetch drive number (D_STR1).
0F4C            LD   (IX+25),A           Store it into the channel (CHDRIV).
0F4F            LD   BC,595              Length of the channel.
0F52            PUSH IX                  Make HL point to the start of the
0F54            POP  HL                  channel.
0F55            CALL #0FA3,REST_F_AD     Restore 'start of filename' possibly
                                         moved during the 'insertion' of the
                                         channel.
0F58            EX   DE,HL               The start address of the filename goes
                                         to HL.
0F59            LD   BC,(23770)          Fetch length of filename (N_STR1).
0F5D            BIT  7,B                 Jump if the name doesn't exist
0F5F            JR   NZ,#0F6F,SET_T_5    (N_STR1 = #FFFF).

The channel name is transferred into CHNAME.

0F61 SET_T_4    LD   A,B
0F62            OR   C
0F63            JR   Z,#0F6F,SET_T_5     Jump if no more bytes left.
0F65            LD   A,(HL)              Transfer a character of the name into
0F66            LD   (IX+14),A           (CHNAME).
0F69            INC  HL                  Point to next locations.
0F6A            INC  IX
0F6C            DEC  BC                  One byte less.
0F6D            JR   #0F61,SET_T_4       Continue with next character.

Now the 'preambles' are stored into the channel.

0F6F SET_T_5    POP  IX                  Restore start address of channel.
0F71            LD   DE,28               Offset for header block preamble.
0F74            CALL #0F89,SETUP_PRE     Set-up header preamble.
0F77            LD   DE,55               Offset for data block preamble.
0F7A            CALL #0F89,SETUP_PRE     Set-up data block preamble.
0F7D            PUSH IX                  Make HL point to the start of the
0F7F            POP  HL                  channel.
0F80            LD   DE,(23631)          Calculate the required 'stream offset'
0F84            OR   A                   into HL (i.e. channel start-(CHANS)+1)
0F85            SBC  HL,DE
0F87            INC  HL
0F88            RET                      Finished.

THE 'SET-UP A PREAMBLE' SUBROUTINE
The following subroutine passes a preamble to the specified channel position.
On entry
IX points to the start of the channel and DE holds the required offset.

0F89 SETUP_PRE  PUSH IX                  Pass start of channel to HL.
0F8B            POP  HL
0F8C            ADD  HL,DE               Add the offset.
0F8D            EX   DE,HL               DE now points to the preamble area.
0F8E            LD   HL,#0F97            Start of 'preamble' data.
0F91            LD   BC,12               Preamble is 12 bytes long.
0F94            LDIR
0F96            RET

THE 'PREAMBLE DATA' TABLE
The header and data block preambles consist of the following bytes:

0F97 PREAMBLE   DEFB #00,#00,#00,#00,#00
0F9C            DEFB #00,#00,#00,#00,#00
0FA1            DEFB #FF,#FF

The Microdrive needs these bytes to fetch the start of a block of bytes when
reading a
cartridge.

THE 'RESTORE FILENAME ADDRESS' ROUTINE
After the 'insertion' of some space, the 'filename' whose start addresses are
held into
(N_STR1+2) and (N_STR2+2) have been moved up in the workspace area. This
routine is
entered with HL holding the channel start address, and with BC holding the
number of
'inserted' bytes. The addresses held into (N_STR1+2) and (N_STR2+2) are then
updated,
unless the filenames are stored into 'no-dynamic' areas (i.e. before the
channel or after
STKEND).

0FA3 REST_F_AD  PUSH HL                  Save 'start of channel' twice.
0FA4            PUSH HL
0FA5            LD   DE,(23780)          Restore start address of the second
0FA9            CALL #0FBE,TST_PLACE     filename.
0FAC            LD   (23780),DE
0FB0            POP  HL                  Restore channel start address.
0FB1            LD   DE,(23772)          Restore start address of the first
0FB5            CALL #0FBE,TST_PLACE     filename.
0FB8            LD   (23772),DE
0FBC            POP  HL                  Restore channel start address.
0FBD            RET                      Finished.

The following subroutine calculates the new filename address.

0FBE TST_PLACE  SCF                      Allow for a further byte.
0FBF            SBC  HL,DE               No action is made if the filename is
0FC1            RET  NC                  before the channel.
0FC2            LD   HL,(23653)          Or if it is after (STKEND).
0FC5            SBC  HL,DE
0FC7            RET  C
0FC8            EX   DE,HL               Add to DE the number of 'inserted'
0FC9            ADD  HL,BC               bytes, so returning the new filename
0FCA            EX   DE,HL               address.
0FCB            RET                      Finished.

THE 'CHECK NAME' SUBROUTINE
Whenever a 'filename' is to be compared against the channel name CHNAME, this
subroutine
is called. On entry, HL must point to the filename to be compared, while C must
contain
its length. If the comparision is succesful, the Zero flag is returned set.

0FCC CHK_NAME   PUSH IX                  Save start of channel.
0FCE            LD   B,10                Length of a filename.
0FD0 CHK_NAME1  LD   A,(HL)              Fetch a byte from the name.
0FD1            CP   (IX+14)
0FD4            JR   NZ,#0FEC,CHK_NAME3  Jump if it doesn't match.
0FD6            INC  HL                  Point to the next character.
0FD7            INC  IX
0FD9            DEC  B                   One byte less.
0FDA            DEC  C                   Repeat until all bytes of the name
have
0FDB            JR   NZ,#0FD0,CHK_NAME1  been matched.
0FDD            LD   A,B                 CHNAME remaining length.
0FDE            OR   A
0FDF            JR   Z,#0FEC,CHK_NAME3   Exit if all bytes of CHNAME matched.
0FE1 CHK_NAME2  LD   A,(IX+14)           Otherwise the remaining characters of
0FE4            CP   32                  CHNAME have to be spaces.
0FE6            JR   NZ,#0FEC,CHK_NAME3  Exit if not a space.
0FE8            INC  IX                  Repeat until all bytes of CHNAME have
0FEA            DJNZ #0FE1,CHK_NAME2     been examined.
0FEC CHK_NAME3  POP  IX                  Restore channel start address.
0FEE            RET                      Finished.

THE 'CALL INP' ROUTINE
This routine is the same as the Interface 1 'CALL_INP' routine which handles
all IF1's
channels. The +D uses this routine only for "M" channels, for "D" channels a
similar
routine located in RAM is used. (The only difference is the test of FLAGS3,
i.e. IY+124
while emulating the IF1, #1ACF otherwise.) On entry HL holds the address of the
service
'input' routine. The routine handles both INPUT and INKEY$ commands.

0FEF CALL_INP   RES  3,(IY+2)            Signal 'the mode is to be considered
                                         as being unchanged'.
0FF3            PUSH HL                  Store address of service routine.
0FF4            LD   HL,(23613)          HL points to error address (ERR_SP).
0FF7            LD   E,(HL)              Fetch the error address.
0FF8            INC  HL
0FF9            LD   D,(HL)
0FFA            AND  A
0FFB            LD   HL,#107F,ED_ERROR   If the error address is 'ED_ERROR'
0FFE            SBC  HL,DE               ('main' ROM) then an INPUT command was
1000            JR   NZ,INKEY$           used. Jump if unequal to 'ED_ERROR'.

Now deal with an 'INPUT #' command referring to a "M" channel.

1002            POP  HL                  Restore address of service routine.
1003            LD   SP,(23613)          Clear the machine stack (ERR_SP).
1007            POP  DE                  Remove 'ED_ERROR'.
1008            POP  DE
1009            LD   (23613),DE          Restore the old value of ERR_SP.
100D IN_AGAIN   PUSH HL                  Store address of service routine.
100E            LD   DE,#1013,INPUT_END  Return address is 'INPUT_END' below.
1011            PUSH DE
1012            JP   (HL)                Jump to the service routine.

When the byte has been read from the required channel, a return is made here to
add the
byte to the INPUT line, or to return if the byte is equal to CHR$ 13, i.e.
ENTER.

1013 INPUT_END  JR   C,#101D,ACC_CODE    Jump with acceptable codes.
1015            JR   Z,#101A,NO_READ     Jump with no data read.
1017 INPUT_ERR  JP   #12C3,MD_ERROR      Otherwise jump to the 'hook code'
                                         error routine.
101A NO_READ    POP  HL                  Restore address of service routine and
101B            JR   #100D,IN_AGAIN      try again.

An acceptable code was received, it is added to the INPUT line.

101D ACC_CODE   CP   13
101F            JR   Z,#1027,END_INPUT   Jump if the code is ENTER.
1021            RST  #10,CALBAS          Otherwise the byte is to be added to
1022            DEFW #0F85,ADD_CHAR0     the INPUT line. This is done by call-
                                         ing into the 'ADD_CHAR' subroutine.
1024            POP  HL                  Restore address of the service routine
1025            JR   #100D,IN_AGAIN      and read the next byte.

1027 END_INPUT  POP  HL                  Drop the address of the service
1028            JP   #0050,UNPAGE_1      routine and page-out the +D.

Enter here to deal with the INKEY$ function (a single character is returned).

102B INKEY$     POP  HL                  Restore address of the service routine
102C            LD   DE,#1031,INK$_END   Return address is 'INK$_END' below.
102F            PUSH DE
1030            JP   (HL)                Jump to the service routine.

1031 INK$_END   RET  C                   Return with acceptable codes or
1032            RET  Z                   with no byte read.
1033            BIT  4,(IY+124)          Otherwise EOF was reached, so jump to
1037            JR   Z,#1017,INPUT_ERR   the error routine except when
                                         executing a 'MOVE' command.
1039            OR   1                   Then return with Zero and Carry flags
103B            RET                      both reset.

THE '"M" CHANNEL INPUT' ROUTINE
The actual 'input' is handled via 'CALL_INP' above. The service routine is
'MCHAN_IN'
below.

103C M_INPUT    LD   IX,(23633)          Make IX point to start of channel.
1040            LD   HL,#1046,MCHAN_IN   Address of the service routine.
1043            JP   #0FEF,CALL_INP      Jump to the control routine.

THE '"M" CHANNEL INPUT' SERVICE ROUTINE
This is the actual read a byte from the "M" channel routine. The byte is read
from the
data buffer in the channel, if it is empty the next sector is loaded from disk
(provided
that the 'current' data block is not the EOF one) before reading the byte.

1046 MCHAN_IN   BIT  0,(IX+24)           Jump to the 'hook code' error routine
104A            JP   NZ,#12C3,MD_ERROR   if (CHFLAG) indicates 'read' file.
104D TEST_M_BUF LD   E,(IX+11)           Fetch current byte counter from
1050            LD   D,(IX+12)           (CHBYTE).
1053            LD   L,(IX+69)           Fetch record length from (RECLEN).
1056            LD   H,(IX+70)
1059            SCF                      Include byte to be read.
105A            SBC  HL,DE
105C            JR   C,#1071,CHK_M_EOF   Jump if all bytes have been read.
105E            INC  DE                  Include byte to be read in the byte
                                         counter.
105F            LD   (IX+11),E           And store it.
1062            LD   (IX+12),D
1065            DEC  DE                  Position of character to be read.
1066            PUSH IX                  Save start address of channel.
1068            ADD  IX,DE               IX now points to 'byte to be
                                         read - 82'.
106A            LD   A,(IX+82)           Fetch the byte.
106D            POP  IX                  Restore start of channel.
106F            SCF                      Signal 'acceptable code'.
1070            RET                      Finished.

If all bytes in the data block have been read, a check is made to see if it is
the 'end
of file' block, i.e. the last one.

1071 CHK_M_EOF  BIT  1,(IX+67)           Jump if (RECFLG) indicates 'not the
1075            JR   Z,#107B,NEW_BUFF    End Of File' block.
1077            XOR  A                   Otherwise Zero and Carry flag are
                                         reset to signal 'EOF'.
1078            ADD  A,13                Returned byte is CHR$ 13, i.e. ENTER.
107A            RET                      Finished.

A new data block is now read from the disk drive.

107B NEW_BUFF   LD   DE,0                Clear the byte counter.
107E            LD   (IX+11),E
1081            LD   (IX+12),D
1084            INC  (IX+13)             Increment (CHREC), i.e. record number.
1087            CALL #108C,GET_RECD      Fetch a new data block.
108A            JR   #104D,TEST_M_BUF    Read the byte.

THE 'GET A RECORD' SUBROUTINE
This subroutine is used to load a record of a 'MICRODRIVE'-type file.

108C GET_RECD   LD   C,3                 Three retries will be made before the
                                         routine is exitted when an error
                                         occurs.
108E            BIT  1,(IX+67)
1092            JR   NZ,#10BD,GET_R3     Jump if (RECFLG) indicates 'EOF' block
1094 GET_R1     PUSH IX                  Store channel pointer (in 'main' RAM).
1096            LD   DE,540              Microdrive file records have 540 bytes
                                         each.
1099 GET_R2     PUSH IX                  Store data buffer pointer.
109B            LD   IX,#3AC3            Point to the DRAM channel.
109F            CALL #077F,LBYT          Fetch a byte.
10A2            POP  IX                  Restore data buffer pointer.
10A4            LD   (IX+55),A           Loading starts with the data block
                                         preamble (offset 55).
10A7            INC  IX
10A9            CALL #1265,DEC_DE        Decrement DE.
10AC            JR   NZ,#1099,GET_R2     Repeat until DE=0.
10AE            POP  IX                  Restore channel pointer.
10B0            LD   A,(IX+68)           Fetch number of this record (RECNUM).
10B3            CP   (IX+13)             Test it against wanted record number
10B6            RET  Z                   (CHREC), exit if they are equal.
10B7            BIT  1,(IX+67)           Jump to load the next record if
10BB            JR   Z,#1094,GET_R1      (RECFLG) indicates that this isn't the
                                         EOF one.
10BD GET_R3     DEC  C                   Decrement retry counter.
10BE            JR   Z,#10E6,MD_ERROR1   Exit via the 'hook code' error routine
                                         when three retries have been made.

Now the routine reloads the first sector of the file. With 'MICRODRIVE'-type
files it is
possible to have a 'read' channel attached to a file to which is also a 'write'
channel
attached. So the last record could have been read into the 'read' channels data
buffer
after which a new record was added by the 'write' channel. The reason why three
retries
are made is probably because of the ignoring of errors, signalled by a set
Carry flag
(remember this is a 'hook code' executing), reported by 'LBYT' and 'RSAD'. The
routine
does some retrying before quitting.

10C0            PUSH HL                  Store the registers needed by the
10C1            PUSH IX                  routine above.
10C3            PUSH BC
10C4            LD   A,(IX+25)           Fetch the drive number from CHDRIV.
10C7            CALL #0E38,SEL_DRIVE     Select the drive.
10CA            LD   DE,14               Make IX point to CHNAME, the name of
10CD            ADD  IX,DE               the requested file.
10CF            CALL #1146,FIND_FILE     Search for the filename.
10D2            JR   NZ,#10E6,MD_ERROR1  Jump if not found.
10D4            INC  HL                  Skip 'number of sectors used'.
10D5            INC  HL
10D6            LD   D,(HL)              Fetch first track and sector.
10D7            INC  HL
10D8            LD   E,(HL)
10D9            LD   IX,#3AC3            Point to the DRAM channel.
10DD            CALL #05CC,RSAD          Read the first sector.
10E0            POP  BC                  Restore registers.
10E1            POP  IX
10E3            POP  HL
10E4            JR   #1094,GET_R1        Try to find the right record again.

THE 'JUMP TO ERROR ROUTINE'
Because this jump is only two times 'jump relatived to', it wastes one byte.

10E6 MD_ERROR1  JP   #12C3,MD_ERROR      Jump to the 'hook code' error routine.

THE '"M" CHANNEL DATA' TABLE
The '25' bytes that compose the initial part of an "M" channel are as follows:

10E9 MCHAN_DATA DEFW #0008               Main ROM 'output' routine.
10EB            DEFW #0008               Main ROM 'input' routine.
10ED            DEFB "M"+128             Channel specifier.
10EE            DEFW #11BB,MCHAN_OUT     +D ROM 'output' routine.
10F0            DEFW #103C,M_INPUT       +D ROM 'input' routine.
10F2            DEFW 595                 Channel length.
10F4            DEFW #0000               Default for CHBYTE.
10F6            DEFB #00                 Default for CHREC.
10F7            DEFM "          "        Default for CHNAME (10 spaces).
1101            DEFB #FF                 Default for CHFLAG ('write' channel).

THE 'CLOSE FILE' SUBROUTINE
By using 'hook code' 35 (#23) the following subroutine is called. It CLOSEs an
"M"
channel which start adddress is held in the IX register. If the channel is used
for
reading, then it is reclaimed; but if it is used for writing, any unsent data
in the
buffer is written to disk before reclaiming the channel.

1102 CLOSE_M2   BIT  0,(IX+24)           Jump if (CHFLAG) indicates that this
1106            JR   Z,#111A,CLOSE_M1    is a 'read' channel.
1108            SET  1,(IX+67)           Otherwise signal 'EOF record',
110C            CALL #11E1,WR_RECD       and save it on disk.
110F            PUSH IX                  Save channel pointer.
1111            LD   IX,#3AC3            Point to the DRAM channel.
1115            CALL #0B89,CFSM          Close the File Sector Map.
1118            POP  IX                  Restore channel pointer.
111A CLOSE_M1   CALL #126C,DEL_M_BUF     Reclaim the channel.
111D            RET

THE 'ERASE' SUBROUTINE
This subroutine is called using 'hook code' 36 (#24). It deals with the
ERASEing of all
file types. It differs from the +D's ERASE 'command code': this routine uses a
temporary
channel and the IF1's extra system variables to ERASE a file. On entry 'D_STR1'
must hold
the drive number and 'N_STR1' the length and the start of the filename.

111E ERASE      CALL #0EF4,SET_T_MCH     Create a temporary "M" channel.
1121            PUSH IX                  Store channel pointer.
1123            LD   DE,14               Make IX point to CHNAME, the name of
1126            ADD  IX,DE               the file to be ERASEd.
1128            CALL #1146,FIND_FILE     Search for the file.
112B            POP  IX                  Restore channel pointer.
112D            PUSH AF                  Save flags.
112E            JR   NZ,#1141,ERASE_1    Jump if the file wasn't found.
1130            LD   HL,#3BD6            Point to the start of the disk buffer.
1133            ADD  HL,BC               BC holds the directory entries offset
                                         (i.e. 0 for first, 256 for second).
1134            LD   (HL),0              Signal 'ERASEd file'.
1136            PUSH IX                  Store channel pointer.
1138            LD   IX,#3AC3            Point to the DRAM channel.
113C            CALL #0584,WSAD          Write sector DE.
113F            POP  IX                  Restore channel pointer.
1141 ERASE_1    CALL #126C,DEL_M_BUF     Reclaim the channel.
1144            POP  AF                  Exit with Zero reset indicating 'file
1145            RET                      not found'.

THE 'FIND A FILE' SUBROUTINE
This routine searches the disk CATalogue for the filename pointed to by the IX
register.
On exit, Zero reset signals 'file not found'.

1146 FIND_FILE  CALL #06B6,REST          Reset drive to track 0.
1149            LD   (#3ACA),IX          Store the pointer to filename
                                         requested.
114D FIND_F1    LD   IX,#3AC3            Point to the DRAM channel.
1151            CALL #05CC,RSAD          Load a sector to the disk buffer.
1154            LD   BC,0                First entry's offset.
1157 FIND_F2    LD   HL,#3BD6            Point to the start of the disk buffer.
115A            ADD  HL,BC               Point to directory entry.
115B            LD   A,(HL)
115C            CP   0
115E            JR   Z,#1117F,FIND_F4    Jump if the file is ERASEd.
1160            INC  HL                  Point to the filename.
1161            LD   IX,(#3ACA)          Fetch pointer to filename requested.
1165            LD   A,10                Length of filename.
1167            LD   (#3DF3),A
116A FIND_F3    LD   A,(IX+0)            Fetch a byte from requested name.
116D            XOR  (HL)                Compare against found name.
116E            AND  #DF                 Capitalize.
1170            JR   NZ,#117F,FIND_F4    Jump if they don't match.
1172            INC  IX                  Next characters.
1174            INC  HL
1175            LD   A,(#3DF3)
1178            DEC  A
1179            LD   (#3DF3),A
117C            JR   NZ,#116A,FIND_F3    Repeat for all characters in the name.
117E            RET                      Return with Zero set to indicate 'file
                                         found'.

The requested filename wasn't found yet, so examine the next file.

117F FIND_F4    LD   A,B
1180            CP   1
1182            JR   Z,#1190,FIND_F5     Jump if second entry handled.
1184            LD   A,(#3DDA)
1187            AND  #04                 Jump if using single density, i.e.
1189            JR   NZ,#1190,FIND_F5    each sector holds one entry.
118B            LD   BC,256              Otherwise examine second entry.
118E            JR   #1157,FIND_F2

The next CATalogue sector has to be loaded, if present.

1190 FIND_F5    INC  E                   Next sector.
1191            LD   A,E
1192            CP   11                  Jump if last sector on current track
1194            JR   NZ,#114D,FIND_F1    hasn't been loaded yet.
1196            LD   E,1                 Otherwise start with sector 1
1198            INC  D                   on the next track.
1199            LD   A,D
119A            CP   4                   Jump if last track in CATalogue hasn't
119C            JR   NZ,#114D,FIND_F1    been handled yet.
119E            CP   0                   Otherwise reset Zero flag to signal
11A0            RET                      'file not found' and exit.

THE 'READ SEQUENTIAL' SUBROUTINE
This is called by using 'hook code' 37 (#25). The subroutine reads into the
data block
of the current "M" channel, the next record of a named PRINT-type file. On
entry IX must
hold the "M" channel start address, and CHREC the number of the current record.
CHREC
will be automatically incremented. CHDRIV must hold the drive number and CHNAME
must hold
the filename.

11A1 READ_SEQ   BIT  1,(IX+67)           Jump if (RECFLG) indicates that the
11A5            JR   Z,#11AA,INCREC      current record isn't the EOF one.
11A7            JP   #12C3,MD_ERROR      Otherwise exit via the 'hook code'
                                         error routine.
11AA INCREC     INC  (IX+13)             Increment the record number (CHREC)
                                         and continue into 'RD_RANDOM'.

THE 'READ RANDOM' SUBROUTINE
This subroutine is called by using 'hook code' 39 (#27). The record number
CHREC of a
PRINT-type file is loaded into the data block. The other variables are to be
set as for
'READ_SEQ' above.

11AD RD_RANDOM  CALL #108C,GET_RECD      Load CHREC record.
11B0            BIT  2,(IX+67)           Return only if (RECFLG) indicates that
11B4            RET  Z                   it is a PRINT-type file.
11B5            CALL #126C,DEL_M_BUF     Otherwise reclaim the channel and exit
11B8            JP   #12C3,MD_ERROR      via the 'hook code' error routine.

THE '"M" CHANNEL OUTPUT' ROUTINE
This routine handles the "M" channel output. The byte stored in the A register
is stored
into the 512-byte buffer. When it is filled, the record is written onto disk.

11BB MCHAN_OUT  LD   IX,#FFFA            This is -6.
11BF            ADD  IX,DE               Point to the start of the channel.
11C1            BIT  0,(IX+24)           Continue only if (CHFLAG) indicates
11C5            JP   Z,#12C3,MD_ERROR    that this is a 'write' file.
11C8            LD   E,(IX+11)           Fetch the byte pointer (CHBYTE).
11CB            LD   D,(IX+12)
11CE            PUSH IX                  Save start address of channel.
11D0            ADD  IX,DE               Point to 'first free byte in
                                         buffer'-82.
11D2            LD   (IX+82),A           Store the byte into the buffer.
11D5            POP  IX                  Restore start of channel.
11D7            INC  DE                  Update (CHBYTE).
11D8            LD   (IX+11),E
11DB            LD   (IX+12),D
11DE            BIT  1,D                 Return if the buffer is not filled
11E0            RET  Z                   (position 512 has not been reached).

If the buffer is filled, the routine continues into 'WR_RECD' below.

THE 'WRITE RECORD' SUBROUTINE
This subroutine is called by using 'hook code' 38 (#26). The record held in the
"M"
channel pointed by the IX register (with name CHNAME and number CHREC), is
written onto
the disk inserted into drive CHDRIV.

11E1 WR_RECD    LD   A,(IX+25)           Fetch the drive number (CHDRIV).
11E4            CALL #0E38,SEL_DRIVE     Select the drive.
11E7            PUSH IX                  Save start address of channel.
11E9            LD   B,10                Counts ten characters.
11EB CP_NAME    LD   A,(IX+14)           Copy CHNAME into RECNAM.
11EE            LD   (IX+71),A
11F1            INC  IX
11F3            DJNZ #11EB,CP_NAME
11F5            POP  IX                  Restore start of channel.
11F7            LD   C,(IX+11)           Copy CHBYTE into RECLEN.
11FA            LD   (IX+69),C
11FD            LD   A,(IX+12)
1200            LD   (IX+70),A
1203            LD   A,(IX+13)           Copy CHREC into RECNUM.
1206            LD   (IX+68),A
1209            PUSH IX                  Make HL point to the start of the data
120B            POP  HL                  workspace,
120C            LD   DE,67               i.e. RECFLG.
120F            ADD  HL,DE
1210            CALL #122A,CHKS_HD_R     Calculate DESCHK checksum.
1213            LD   DE,15               Make HL point to the start of the
1216            ADD  HL,DE               512-byte buffer.
1217            CALL #122F,CHKS_BUF      Calculate DCHK checksum.
121A            CALL #1248,SAVE_RECD     Save the record to disk.
121D            LD   DE,0                Clear CHBYTE.
1220            LD   (IX+11),E
1223            LD   (IX+12),D
1226            INC  (IX+13)             Increment the record number (CHREC).
1229            RET                      Finished.

THE 'CALCULATE/COMPARE CHECKSUM' ROUTINE
This routine is used to calculate DESCHK and DCHK checksums, or to compare the
previous
checksum against the current one; the Zero flag is returned set if the
checksums match.
The entry point is CHK_HD_R for DESCHK, or CHKS_BUFF for DCHK checksum. On
entry in both
cases HL must contain the start address of the block for which the checksum is
to be
obtained.

122A CHKS_HD_R  LD   BC,14               The block length.
122D            JR   #1232,CHKS_ALL      Calculate checksum for the block.

122F CHKS_BUF   LD   BC,512              The block length.
1232 CHKS_ALL   PUSH HL                  The start address is preserved.
1233            LD   E,0                 Clear checksum.
1235 CHKS_1     LD   A,E                 Add the current byte to the previous
1236            ADD  A,(HL)              sum.
1237            INC  HL                  Point to next location.
1238            ADC  A,1                 Include also the carry + 1.
123A            JR   Z,#123D,CHKS_2      Jump if A reaches zero.
123C            DEC  A                   Otherwise balance the 'ADC' above.
123D CHKS_2     LD   E,A                 Update sum.
123E            DEC  BC                  One byte less to add.
123F            LD   A,B
1240            OR   C
1241            JR   NZ,#1235,CHKS_1     Repeat until all bytes have been added
1243            LD   A,E
1244            CP   (HL)                Compare with previous checksum.
1245            LD   (HL),A              Store the new one.
1246            POP  HL                  Restore start address.
1247            RET                      Finished.

THE 'SAVE A RECORD' SUBROUTINE
This subroutine saves the 540 byte Microdrive-file record to disk.

1248 SAVE_RECD  PUSH IX                  Save the channel pointer.
124A            PUSH IX
124C            POP  HL                  Calculate the address of the first
124D            LD   DE,55               byte to SAVE, i.e. the data block
1250            ADD  HL,DE               preamble (offset 55).
1251            LD   DE,540              Length of the record to be written.
1254            LD   IX,#3AC3            Point to the DRAM channel.
1258 SAVE_REC1  LD   A,(HL)              Fetch a byte.
1259            CALL #0761,SBYT          Save it to disk.
125C            INC  HL
125D            CALL #1265,DEC_DE        Decrement DE.
1260            JR   NZ,#1258,SAVE_REC1  Repeat until DE=0.
1262            POP  IX                  Restore the channel pointer.
1264            RET                      Finished.

THE 'DECREMENT DE' SUBROUTINE
This very small subroutine decrements DE and returns with the Zero flag
indicating if DE
holds zero on exit. The purpose of this three-byte subroutine is unclear, it
doesn't save
a single byte (a CALL instruction takes also three bytes so this subroutine
makes the
code only longer), and the readability of the code (or the source) doesn't
improve
really.

1265 DEC_DE     DEC  DE                  DE=DE-1.
1266            LD   A,D
1267            OR   E                   Set Zero flag if DE=0.
1268            RET                      Finished.

THE 'READ SECTOR' SUBROUTINE
This subroutine is not implemented, it is called by using 'hook code' 40 (#28).
When
used with an IF1 the sector, which number is held in CHREC, is read into the
channel
area. If the sector doesn't belong to a PRINT-type file the data buffer is
cleared before
returning. On entry the required drive motor has to be turned on.

1269 RD_SECTOR  RET

THE 'READ NEXT SECTOR' SUBROUTINE
This subroutine called by using 'hook code' 41 (#29) isn't implemented either.
It should
load into the channel area the first header and data block that pass through
the
Microdrive head. The required drive motor has to be started before calling this
routine.

126A RD_NEXT    RET

THE 'WRITE SECTOR' SUBROUTINE
Another unimplemented subroutine, called by using 'hook code' 42 (#2A) it
writes the
data block in the current channel (pointed to by IX) to the sector specified by
CHREC.
The required Microdrive has to be started and all channel variables, such as
CHNAME, are
to be set as required before calling the routine.

126B WR_SECTOR  RET

THE 'RECLAIM "M" CHANNEL' SUBROUTINE
This subroutine (also called by using 'hook code' 44 (#2C)) is used to reclaim
the "M"
channel pointed by the IX register. Unlike the IF1 routine this routine neither
closes
the stream(s) attached to this channel, nor updates the stream data for
channels moved
down after the reclaiming.

126C DEL_M_BUF  PUSH IX                  Make HL point to the start of the
126E            POP  HL                  channel.
126F            LD   BC,595              Length of the channel.
1272            RST  #10,CALBAS          Delete the channel area by calling
1273            DEFW #19E8,RECLAIM_2     'RECLAIM_2' in the 'main' ROM.
1275            RET                      Finished.

THE 'OPEN TEMP. "N" CHANNEL' SUBROUTINE
The +D doesn't support the use of "N" channels, temporary or permanent, by the
user.
This routine is called by using 'hook code' 45 (#2D).

1276 OP_TEMP_N  RET

THE 'CLOSE NETWORK CHANNEL' SUBROUTINE
Because the +D doesn't support "N" channels, the CLOSEing of them isn't
supported either
('hook code' 46 (#2E)).

1277 CLOSE_NET  RET

THE 'GET PACKET FROM NETWORK' SUBROUTINE
Called by using 'hook code' 47 (#2F), this subroutine to fetch a header and
data block
from the network isn't implemented.

1278 GET_PACK   RET

THE 'SEND PACKET' SUBROUTINE
The +D doesn't support the sending of a header and data block over the network
('hook
code' 48 (#30)).

1279 SEND_PACK  RET

THE 'CREATE IF1 VARIABLES' SUBROUTINE
This subroutine (called by using 'hook code' 49 (#31)) has the task of creating
the
IF1's new system variables if nonexistent. Many variables are initialised to
their
default values.

127A HOOK_31    LD   HL,(23631)          Fetch start of channel area (CHANS).
127D            LD   DE,#A349            This is -23735.
1280            ADD  HL,DE               The Carry flag is now set if the CHANS
                                         area starts after address 23734, i.e.
                                         the 'new' variables exist already.
1281            JR   C,#12A9,VAR_EXIST   Jump if they exist already.
1283            LD   HL,(23651)          Clear the calculator stack by copying
1286            LD   (23653),HL          (STKBOT) into (STKEND).
1289            LD   HL,23698            Set (MEM) with the address of the
128C            LD   (23656),HL          MEMBOT area.
128F            LD   HL,23733            One location before the new space is
                                         needed.
1292            LD   BC,58               There are 58 new variables.
1295            RST  #10,CALBAS          Use 'main' ROM 'MAKE_ROOM' to create
1296            DEFW #1655,MAKEROOM      the space.
1297            LD   HL,#12AE,IF1_VARS   Address of 'default values' table.
129B            LD   BC,19               There are 19 default values.
129E            LD   DE,23734            Start of 'new' variables area.
12A1            LDIR                     Store default values.
12A3            LD   A,1                 Set (COPIES) to 1.
12A5            LD   (23791),A
12A8            RET                      Finished.

12A9 VAR_EXIST  RES  1,(IY+124)          Signal 'new variables already exist'.
12AD            RET

THE 'SYSTEM VARS DEFAULT VALUES' TABLE
This table contains the default values of all the 'new' IF1 system variables
from FLAGS3
to SER_FL.

12AE IF1_VARS   DEFB #02                 Default for FLAGS3 (bit 1 is set to
                                         signal that the shadow ROM has been
                                         paged in for the first time).
12AF            DEFW #01F0               Default for VECTOR is the IF1's
                                         'ERR_6' address (nonsense for +D).
12B1            LD   HL,#0000            This short subroutine is used to call
12B4            CALL #0000               'main' ROM routines from the IF1 ROM,
12B7            LD   (23738),HL          it isn't used with the +D.
12BA            RET
12BB            DEFW #000C               Default for BAUD, i.e. 9600 baud.
12BD            DEFB #01                 Default for NSTAT.
12BE            DEFB #00                 Default for IOBORD, the colour during
                                         IF1 I/O (black).
12BF            DEFW #0000               Default for SER_FL.

THE 'CALL IF1 SUBROUTINE' SUBROUTINE
This subroutine, called by using 'hook code' 50 (#32), is designed to call IF1
ROM-routines when the 'main' ROM is paged in. The difference with IF1 is that
the +D uses
DE to pass the address to be called.

12C1 HOOK_32    EX   DE,HL
12C2            JP   (HL)

THE 'HOOK CODE ERROR' ROUTINE
Whenever an error is encountered in the 'hook code' routines a jump is made
here to
signal the error and clear the machine stack when necessary.

12C3 MD_ERROR   CALL #168E,BORD_REST     Restore the border colour.
12C6            LD   HL,(#2066)
12C9            LD   A,H
12CA            OR   L
12CB            JR   Z,#12CE,MD_ERR1     Jump if the stack isn't to be cleared.
12CD            LD   SP,HL               Otherwise clear the stack.
12CE MD_ERR1    XOR  A
12CF            DEC  A
12D0            SCF                      Exit with A holding 255 and Carry flag
12D1            RET                      set.
 ____________________________
|Previous|Next|Contents|Index|
###### 12d2-printer.html ######
###### 12d2-printer.html ######


 ____________________________
|Previous|Next|Contents|Index|
The Printer routines

THE 'NORMAL SCREENDUMP' SUBROUTINE
This routine dumps a normal screendump to the printer. It can be called also by
using
command code 58 (#3A).

12D2 COPS       CALL #0527,SYSTEM_Z      If a system file has been loaded
12D5            CALL Z,#2080,JCOPS       call it's screendump routine.
12D8            LD   HL,16384            Start of screen.
12DB            LD   DE,#2022,N/72_LSPC  Print the escape sequence for n/72
inch
12DE            CALL #140B,PO_ESC_SEQ    line feeds.
12E1            LD   A,8                 Make it 8/72.
12E3            CALL #15C9,PNTP
12E6 C1_LINE    LD   DE,#202A,GRAPH_DPI  Print the escape sequence for a normal
12E9            CALL #140B,PO_ESC_SEQ    screendump. (60 dpi)
12EC            LD   A,0                 Signal '256 dot columns will follow'
12EE            CALL #15C9,PNTP          to the printer.
12F1            LD   A,1
12F3            CALL #15C9,PNTP
12F6            PUSH HL
12F7 C1_CHAR    LD   B,8                 Eight pixels in each byte.
12F9 C1_PIXEL   PUSH HL
12FA C1_PIXROW  CALL #13E3,PIXEL_COL     Get pixel colour.
12FD            AND  #04
12FF            JR   NZ,#1302,C1_ADDDOT  Jump with colour codes 4-7 (no dot).
1301            SCF                      Set a dot for colour codes 0-3.
1302 C1_ADDDOT  LD   A,(#3E4F)           Incorporate one dot in dot column.
1305            RLA
1306            LD   (#3E4F),A
1309            INC  H                   Next pixel row.
130A            LD   A,H
130B            AND  #07
130D            JR   NZ,#12FA,C1_PIXROW  Repeat until all eight pixelrows have
                                         been 'scanned'.
130F            LD   A,(#3E4F)
1312            CALL #15C9,PNTP          Print the dot column.
1315            POP  HL                  Repeat until all eight pixels in a
byte
1316            DJNZ #12F9,C1_PIXEL      have been printed. One character cell
                                         (64 pixels) has been printed now.
1318            INC  L                   Next character position.
1319            LD   A,L
131A            AND  #1F
131C            JR   NZ,#12F7,C1_CHAR    Loop for all 32 character columns.
131E            CALL #132E,ADV_PAPER     Advance printer paper one line.
1321            POP  HL
1322            LD   A,H                 Make HL point to the next screen third
1323            ADD  A,8                 'N_CHARROW' will adjust HL if
1325            LD   H,A                 necessary.
1326            CALL #13FE,N_CHARROW     Calculate the address of the next
1329            JR   NZ,#12E6,C1_LINE    characterrow and loop until end of
                                         pixel area reached.
132B            JP   #13D7,DUMP_EXIT     Exit via 'DUMP_EXIT' to reset printer.

THE 'ADVANCE PRINTER PAPER' SUBROUTINE
This subroutine advances the paper by sending a CR (carriage return) and (when
needed) a
LF (line feed) to the printer.

132E ADV_PAPER  LD   A,13                Send a CR to the printer.
1330            CALL #15C9,PNTP
1333            LD   A,(#2008)           This is 'LFEED'.
1336            AND  A
1337            RET  Z                   Return if no LF has to be printed.
1338            LD   A,10                Otherwise send a LF.
133A            CALL #15C9,PNTP
133D            RET                      Finished.

THE 'GREYSCALE SCREENDUMP' SUBROUTINE
This routine prints a large screendump. It can also be called by using command
code 66
(#42).

133E COPS2      CALL #0527,SYSTEM_Z      If a system file has been loaded
1341            CALL Z,#2083,JCOPS2      call it's screendump routine.
1344            LD   HL,#57E0            Address of the lowest pixelrow of the
                                         charactersquare in bottom left corner.
1347            LD   DE,#2022,N/72_LSPC  Print the escape sequence for n/72
134A            CALL #140B,PO_ESC_SEQ    inch line feeds.
134D            LD   A,6                 Make it 6/72.
134F            CALL #15C9,PNTP
1352            LD   B,128               There are 128 2-pixel columns.
1354            LD   C,8                 8 pixels make one byte. Start with
                                         leftmost bit in a byte.
1356 C2_2PIXCOL PUSH BC
1357            PUSH HL
1358            LD   DE,#2052,GREY_BITIM Print the escape sequence for the
135B            CALL #140B,PO_ESC_SEQ    greyscale bitimage mode.
135E            LD   B,24                There are 24 characterrows.
1360 C2_SCRROW  PUSH BC
1361            PUSH HL
1362            LD   B,8                 A character has 8 pixelrows.
1364 C2_PIXROW  PUSH BC
1365            PUSH HL
1366            LD   DE,#3BD6            Clear the buffer for the 2 pixels.
1369            LD   B,3
136B C2_CLRBUF  XOR  A
136C            LD   (DE),A
136D            INC  DE
136E            DJNZ #136B,C2_CLRBUF
1370            LD   B,2                 The dot columns for 2 pixels are build
                                         up each time.
1372 C2_2PIX    PUSH BC
1373            PUSH HL
1374            LD   B,C
1375            CALL #13E3,PIXEL_COL     Get the colour of the (B-1)th pixel.
1378            AND  #07                 Keep only the least significant 3 bits
137A            INC  A                   Make the range 1..8.
137B            LD   B,A
137C            LD   C,0                 Set the bit in the C register which
137E            SCF                      corresponds to the colour.
137F C2_MK_MASK RL   C
1381            DJNZ #137F,C2_MK_MASK
1383            LD   DE,#205A,GREYSCALE  DE points to the 'GREYSCALE' table.
1386            LD   HL,#3BD6            HL points to the 2-pixel buffer.
1389            LD   B,3                 Each pixel is printed as 3*3 dots.
138B C2_DOTCOL  PUSH BC
138C            LD   B,3
138E C2_DOTROW  LD   A,(DE)              Get colour pattern.
138F            AND  C                   Only keep the bit with the right
1390            LD   A,(HL)              colour.
1391            JR   Z,#1394,C2_ADD_DOT  Jump if bit isn't set.
1393            SCF                      Otherwise set this dot.
1394 C2_ADD_DOT RL   A                   Incorporate this dot.
1396            LD   (HL),A
1397            INC  DE                  Next entry in 'GREYSCALE' table.
1398            DJNZ #138E,C2_DOTROW     Repeat for 3 dotrows.
139A            INC  HL
139B            POP  BC
139C            DJNZ #138B,C2_DOTCOL     Repeat for 3 dotcolumns.
139E            POP  HL
139F            POP  BC
13A0            DEC  C                   Next pixel.
13A1            DJNZ #1372,C2_2PIX       Two pixels are handled at a time.
13A3            LD   B,3                 Three dotcolumns are to be printed.
13A5            LD   HL,#3BD6
13A8 C2_PRT3X3  LD   A,(HL)              Print each dotcolumn in turn.
13A9            CALL #15C9,PNTP
13AC            INC  HL
13AD            DJNZ #13A8,C2_PRT3X3     Repeat for all three.
13AF            POP  HL
13B0            DEC  H                   Next pixelrow.
13B1            POP  BC                  Repeat for the eight pixelrows in a
13B2            DJNZ #1364,C2_PIXROW     character square.
13B4            POP  HL
13B5            LD   A,L                 One character row up.
13B6            SUB  32
13B8            LD   L,A
13B9            JR   NC,#13BF,C2_CHRROW  Jump if still within the same third.
13BB            LD   A,H                 Otherwise update MSB of address.
13BC            SUB  8
13BE            LD   H,A
13BF C2_CHRROW  POP  BC
13C0            DJNZ #1360,C2_SCRROW     Repeat for the 24 rows on the screen.
13C2            CALL #132E,ADV_PAPER     Advance the paper.
13C5            POP  HL
13C6            POP  BC
13C7            DEC  C                   Skip the two pixels which have already
13C8            DEC  C                   been printed.
13C9            JR   NZ,#13CE,C2_BYTE    Jump if not all pixels within this
                                         byte have been printed.
13CB            LD   C,8                 Otherwise reset 'pixels in a byte'
13CD            INC  HL                  counter and point to the next
                                         character position to the right.
13CE C2_BYTE    DJNZ #1356,C2_2PIXCOL    Repeat for the 128 2-pixelcolumns.
13D0            LD   B,4                 Advance the paper for four lines.
13D2 C2_ADVPAP  CALL #132E,ADV_PAPER
13D5            DJNZ #13D2,C2_ADVPAP
13D7 DUMP_EXIT  LD   DE,#2022,N/72_LSPC  Print the escape sequence for n/72
inch
13DA            CALL #140B,PO_ESC_SEQ    line feeds.
13DD            LD   A,(#2007)           Make it (LSPCE)/72.
13E0            JP   #15C9,PNTP          Exit via 'PNTP'.

THE 'PIXEL COLOUR' SUBROUTINE
This routine returns with the low 3 bits of the A register holding the colour
of the Bth
pixel from address HL (i.e. the paper colour for an 'off' pixel and the ink
colour for an
'on' pixel).

13E3 PIXEL_COL  PUSH HL                  Save address of current 8-pixels.
13E4            PUSH BC                  Save pixel number (range 1..8).
13E5            XOR  A
13E6            SCF
13E7 PIXEL_COL1 RLA                      Now set (B-1)th bit of A (range 0..7).
13E8            DJNZ #13E7,PIXEL_COL1
13EA            AND  (HL)                Zero flag now reflects state of pixel
13EB            PUSH AF                  (i.e. set means pixel set).
13EC            LD   A,H                 Calculate attribute address.
13ED            RRCA
13EE            RRCA
13EF            RRCA
13F0            AND  #03
13F2            OR   #58
13F4            LD   H,A
13F5            POP  AF
13F6            LD   A,(HL)              Fetch the attribute.
13F7            POP  BC
13F8            POP  HL
13F9            RET  NZ                  Return if ink colour is to be used.
13FA            RRCA                     Otherwise move paper colour
13FB            RRCA                     to the lower three bits.
13FC            RRCA
13FD            RET

THE 'NEXT CHAR. ROW ADDRESS' SUBROUTINE
This subroutine calculates the address of the next characterrow, if the end of
the pixel
area is reached a return with Zero set will be made.

13FE N_CHARROW  LD   A,L                 Update low address byte to next
                                         character row.
13FF            ADD  A,32                The carry will be reset within display
1401            LD   L,A                 thirds.
1402            CCF                      Invert carry.
1403            SBC  A,A                 A holds #FF within same third, 0 else.
1404            AND  #F8                 A will hold #F8 (i.e. -8) within a
1406            ADD  A,H                 third, but 0 when a new third is
1407            LD   H,A                 reached. Update high byte (which was
                                         already incremented by 8).
1408            CP   #58                 Return with the Zero flag set if
140A            RET                      attributes reached.

THE 'PRINT ESCAPE SEQUENCE' SUBROUTINE
This subroutine is used to send escape sequences to the printer. The start of
the
sequence is held in the DE register, a sequence ends with a CHR$ 128.

140B PO_ESC_SEQ LD   A,(DE)              Fetch a code.
140C            CP   128
140E            RET  Z                   Exit if it's 128.
140F            CALL #15C9,PNTP          Otherwise send it to the printer.
1412            INC  DE                  Continue until the sequence is
1413            JR   #140B,PO_ESC_SEQ    finished.

THE '"P" CHANNEL OUTPUT' ROUTINE
This routine handles the +D's "P" channel, the @6 system variable (PCODE)
signals if
it's to be handled as a "t" or a "b" channel. (As with the Opus Discovery and
the ZX
Interface 1.)

1415 PCHAN_OUT  CALL #0527,SYSTEM_Z      If the system file is loaded call the
1418            CALL Z,#2086,JPCHAN      alternative routine.
141B            LD   A,(#2006)           This is PCODE.
141E            AND  A
141F            LD   A,(#3E4F)           Fetch the code to be send to the
1422            JP   NZ,#15C9,PNTP       printer, send it right away if
                                         (PCODE)=1, i.e. when the +D
                                         mustn't interfere.
1425            LD   HL,(#2063)          Jump to the appropriate 'output'
1428            JP   (HL)                routine.

This is the normal 'output' routine, but a few (control) characters are
followed by one
or two operands, these have to be handled different. This is done by altering
the
'output' routine address.

1429 P_ALL      LD   HL,#2005            This is 'WIDTH'.
142C            CP   32
142E            JP   NC,#1517,P_NOCTRL   Jump if not a control code (>=32).
1431            CP   6                   This is the "PRINT comma" code.
1433            JP   C,#14D2,P_ESCAPE    Jump with codes < 6.
1436            JR   NZ,#1446,P_NOCOMMA  Jump with codes > 6.
1438            LD   A,(HL)              Fetch the number of characters per
1439            SRL  A                   line, divide it by two.
143B            LD   B,A
143C            LD   HL,#3E4E            #3E4E holds the position on the
                                         current line (i.e. the number of
                                         characters already printed on this
143F            SUB  (HL)                line).
1440            JR   C,#1467,P_NEWLINE   Jump if already on 2nd half of line.
1442            LD   H,B                 Otherwise jump with H holding the
1443            JP   #14E9,P_TAB         center position of the line.

1446 P_NOCOMMA  CP   8                   This is "cursor left" or "backspace".
1448            JP   C,#14D2,P_ESCAPE    Jump with codes < 8.
144B            JR   NZ,#1459,P_NOBACK   Jump with codes > 8 (examine further).
144D            LD   HL,#3E4E            Get current position.
1450            LD   A,(HL)
1451            AND  A
1452            RET  Z                   Return if already on leftmost position
1453            DEC  (HL)                Otherwise decrement current position.
1454            LD   A,127               This isn't "BACKSPACE", this is
                                         "DELETE" !
1456            JP   #15C9,PNTP          Print a "DELETE".

1459 P_NOBACK   CP   13                  This is "ENTER" or "CARRIAGE RETURN".
145B            JR   C,#14D2,P_ESCAPE    Jump with codes < 13.
145D            JR   NZ,#1493,P_NOENTER  Jump with codes > 13.
145F            LD   HL,#2065            This flag, when set, indicates that a
1462            BIT  1,(HL)              newline has already been send to the
                                         printer. I.e. the previous line was
                                         full (see #15C0).
1464            RES  1,(HL)              Reset the flag.
1466            RET  NZ                  Return if this newline has been send
                                         already.
1467 P_NEWLINE  LD   HL,#2065            Signal 'newline has been send'.
146A            RES  1,(HL)
146C            LD   HL,#3E4E
146F            LD   (HL),0              Set current position to 0.
1471            LD   A,(#2008)           Fetch (LFEED), the number of line
1474            AND  A                   feeds needed after a carriage return.
1475            JR   Z,#147F,P_CARRET    Jump if it is 0.
1477            LD   B,A                 Otherwise send the line feeds.
1478 P_LFEED    LD   A,10                CHR$ 10 is line feed.
147A            CALL #15C9,PNTP
147D            DJNZ #1478,P_LFEED       Loop until (LFEED) line feeds send.
147F P_CARRET   LD   A,13                Now send the carriage return.
1481            CALL #15C9,PNTP
1484            LD   A,(#2009)           Fetch (LMARG), that is the left margin
1487            AND  A
1488            RET  Z                   Return if it is 0.
1489            LD   B,A                 Otherwise send (LMARG) spaces.
148A            LD   (HL),A              Adjust current print position.
148B P_LMARGE   LD   A,32
148D            CALL #15C9,PNTP
1490            DJNZ #148B,P_LMARGE      Loop until (LMARG) spaces send.
1492            RET                      Finished.

Now the control codes with operands are handled. The control codes from INK to
OVER
(16..21) and ESC (27) require a single operand, whereas the control characters
AT & TAB
are required to be followed by two operands. The following routines leads to
the control
character code being stored in TVDATA-lo, the first operand in TVDATA-hi or the
A
register if there is only a single operand required, and the second operand in
the A
register. The ESC control code is handled separately, the single operand is
send directly
to the printer.

1493 P_NOENTER  CP   16                  This is "INK control".
1495            JR   C,#14D2,P_ESCAPE    Jump with codes < 16.
1497            CP   24                  This is "TAB control"+1.
1499            JR   NC,#14D2,P_ESCAPE   Jump with codes >= 24.
149B            CP   22                  This is "AT control".
149D            JR   NC,#14CD,P_2_OPER   Jump with AT & TAB.
149F            LD   DE,#14AC,P_CONT     Otherwise the '"P" channel output'
                                         routine is to be changed to 'P_CONT'.
14A2 P_TV_1     LD   (23566),A           Store the control character code in
                                         (TVDATA-lo).

The current 'output' routine address is changed temporarily.

14A5 P_CHANGE   LD   HL,#2063            HL points to the 'output' routine
14A8            LD   (HL),E              address. Enter the new 'output'
14A9            INC  HL                  routine address and thereby force the
14AA            LD   (HL),D              next character to be considered as an
14AB            RET                      operand.

Once the operands have been collected the routine continues.

14AC P_CONT     LD   DE,#1429,P_ALL      Restore the original address for
14AF            CALL #14A5,P_CHANGE      'P_ALL'.
14B2            LD   HL,(23566)          Fetch the control code and the first
                                         operand if there are indeed two
                                         operands (TVDATA).
14B5            LD   D,A                 The 'last' operand and the control
14B6            LD   A,L                 code are moved.
14B7            CP   22
14B9            JR   C,#14BF,P_CO_TEMPS  Jump if handling INK to OVER.
14BB            JR   NZ,#14E9,P_TAB      Jump if handling TAB.
14BD            JR   #1514,P_AT          Jump if handling AT.

The control codes INK to OVER are handled by the 'main' ROM 'CO_TEMP' routine.
It is
entered with the control code in the A register and the parameter in the D
register. Note
that all changes are to the 'temporary' system variables.

14BF P_CO_TEMPS LD   HL,#2211,CO_TEMP_5  Return via the calling routine to
14C2            EX   (SP),HL             'CO_TEMP' in the 'main' ROM.
14C3            PUSH HL
14C4            RET

14C5 P_TV_2     LD   DE,#14AC,P_CONT     Store the first operand in TVDATA-hi
14C8            LD   (23567),A           and change the address of the 'output'
14CB            JR   #14A5,P_CHANGE      routine to 'P_CONT'.

Enter here when handling the control codes AT & TAB.

14CD P_2_OPER   LD   DE,#14C5,P_TV_2     The control code will be stored in
14D0            JR   #14A2,P_TV_1        TVDATA-lo and the address of the
                                         'output' routine changed to 'P_TV_2'.

14D2 P_ESCAPE   CP   27
14D4            JR   NZ,#14E5,P_QUEST    Print a '?' if it isn't ESC.
14D6            LD   DE,#14DC,P_ESC      Otherwise change the address of the
14D9            JP   #14A5,P_CHANGE      'output' routine to 'P_ESC'.

Enter here when handling the ESC control code, the character code following the
ESC is
send directly to the printer.

14DC P_ESC      LD   DE,#1429,P_ALL      Restore the original address for
14DF            CALL #14A5,P_CHANGE      'P_ALL'.
14E2            JP   #15C9,PNTP          Send the code following the ESC to the
                                         printer.

A question mark is printed whenever an attempt is made to print an unprintable
character
code.

14E5 P_QUEST    LD   A,63,"?"            The character '?'.
14E7            JR   #1517,P_NOCTRL      Send it to the printer.

Now deal with the TAB control code.

14E9 P_TAB      LD   A,(#2005)           Fetch (WIDTH), that is the line length
14EC            LD   B,A
14ED            LD   A,H                 Fetch the position where to TAB
14EE            SUB  B                   (or AT) to.
14EF            JR   C,#14F7,P_INRANGE   Jump if position is on this line.
14F1            LD   HL,#046C,REPORT_B   Otherwise return to 'REPORT_B' in the
14F4            EX   (SP),HL             'main' ROM ('Integer out of range').
14F5            PUSH HL
14F6            RET
14F7 P_INRANGE  LD   A,(#3E4E)           Fetch current position.
14FA            LD   B,A
14FB            LD   A,H
14FC            SUB  B
14FD            PUSH HL                  Print on a new line if print position
14FE            CALL C,#1467,P_NEWLINE   exceeds TAB position.
1501            POP  HL
1502            LD   A,(#3E4E)           Fetch the current position again.
1505            SUB  H                   Calculate the number of spaces wanted.
1506            RET  Z                   Return if already there.
1507            CPL                      The number is negative so make it
1508            INC  A                   positive.
1509            LD   B,A                 Print the needed spaces.
150A P_SPACE    LD   A,32
150C            PUSH BC
150D            CALL #1429,P_ALL
1510            POP  BC
1511            DJNZ #150A,P_SPACE
1513            RET

Enter here when handling AT.

1514 P_AT       LD   H,D                 Store the second operand and continue
1515            JR   #14E9,P_TAB         in the TAB routine.

The 'not control' characters are divided into four groups: the ordinary
characters, the
tokens, the graphics and the user-defined graphics.

1517 P_NOCTRL   CP   128                 This is the first graphic.
1519            JR   C,#1582,P_ASCII     Jump with ASCII characters (< 128).
151B            CP   144                 This is the first UDG.
151D            JR   NC,#1528,P_TOK&UDG  Jump with UDG's and tokens.
151F            LD   B,A                 Construct the graphic in the
1520            RST  #10,CALBAS          calculator's memory area by calling
1521            DEFW #0B38,PO_GR_1       'PO_GR_1' in the 'main' ROM.
1523            LD   HL,23698            HL points to the start of the graphic
                                         form; i.e. MEMBOT.
1526            JR   #153F,P_GRAPH       Jump to print the graphic character.

1528 P_TOK&UDG  SUB  165                 This is the RND token.
152A            JR   C,P_UDGS            Jump with UDG's (< 165).
152C            LD   HL,#0C10,PO_TOKENS  The routine indirectly jumps to the
152F            EX   (SP),HL             'PO_TOKENS' routine in the 'main' ROM
1530            PUSH HL                  to expand the token. That routine then
1531            RET                      calls recursively the 'P_ALL' routine
                                         above for each character of the token.

1532 P_UDGS     ADD  A,21                Adjust range, UDG's now from 0..20.
1534            LD   BC,(23675)          BC points to the start of the UDG area
1538            LD   H,0                 (UDG).
153A            LD   L,A                 Pass the code to HL.
153B            ADD  HL,HL               Each UDG is made by eight bytes, so
153C            ADD  HL,HL               multiply the code by eight.
153D            ADD  HL,HL
153E            ADD  HL,BC
153F P_GRAPH    LD   DE,#3E3D            Move the eight bytes to the +Ds
1542            LD   BC,8                internal printerbuffer.
1545            LDIR

Now the eight pixelrows are converted to eight dotcolumns.

1547            PUSH IX
1549            LD   IX,#3E4C            The last address of the dotcolumns.
154D            LD   B,8                 Each graphic has eight pixelrows.
154F P_GRAPH1   LD   HL,#3E3D            Address of the graphic's pixelrows.
1552            LD   C,8                 Each pixelrow has eight pixels.
1554 P_GRAPH2   LD   D,(HL)              Each bit is moved in turn into the E
1555            RR   D                   register.
1557            LD   (HL),D
1558            RL   E
155A            INC  HL
155B            DEC  C
155C            JR   NZ,#1554,P_GRAPH2   Repeat for the eight pixels.
155E            LD   (IX+0),E            Store the dotcolumn.
1561            DEC  IX
1563            DJNZ #154F,P_GRAPH1      Repeat for the eight rows.
1565            POP  IX
1567            LD   DE,#202A,GRAPH_DPI  Print the escape sequence for
156A            CALL #140B,PO_ESC_SEQ    graphic images.
156D            LD   A,8                 Signal to the printer 'there follow
156F            CALL #15C9,PNTP          eight bytes of bitimage data'.
1572            LD   A,0
1574            CALL #15C9,PNTP
1577            LD   B,8                 Send the eight bytes to the printer.
1579 P_GRAPH3   LD   A,(HL)
157A            CALL #15C9,PNTP
157D            INC  HL
157E            DJNZ #1579,P_GRAPH3
1580            JR   #15B4,P_UP_POS      Update the current position.

Now deal with the printing of normal ASCII characters.

1582 P_ASCII    LD   HL,#2065
1585            RES  1,(HL)              Reset 'newline already send' flag.
1587            LD   (#3E4F),A
158A            LD   A,(#200A)           Fetch (GRAPH), when it's 1 the +D
158D            AND  A                   has to generate the graphic
158E            LD   A,(#3E4F)           representation of some characters.
1591            JR   Z,#15B1,P_OTHERS    Jump if the normal code has to be send

Because some Spectrum characters aren't supported by all printers the +D can
send the
graphic representation of those characters instead of the original character
code. The
characters supported £, # and (c).

1593            CP   96,"£"
1595            JR   NZ,#159D,P_NOPOUND  Jump if it isn't '£'.
1597            LD   HL,#203A,£_SIGN     Point to the bitimage data for £.
159A            JP   #153F,P_GRAPH       Handle it as an ordinary graphic.
159D P_NOPOUND  CP   35,"#"
159F            JR   NZ,#15A7,P_NOHASH   Jump if it isn't '#'.
15A1            LD   HL,#2042,#_SIGN     Point to the bitimage data for #.
15A4            JP   #153F,P_GRAPH       Handle it as a graphic.
15A7 P_NOHASH   CP   127,"(c)"
15A9            JR   NZ,#15B1,P_OTHERS   Jump to handle all non '(c)'
characters.
15AB            LD   HL,#204A,(c)_SIGN     Point to the bitimage data for (c).
15AE            JP   #153F,P_GRAPH       Handle it as a graphic.

Finally the normal characters can be send to the printer.

15B1 P_OTHERS   CALL #15C9,PNTP          Send the character to the printer.
15B4 P_UP_POS   LD   A,(#3E4E)           Update the current position.
15B7            INC  A
15B8            LD   (#3E4E),A
15BB            LD   HL,#2005            HL points to WIDTH.
15BE            SUB  (HL)
15BF            RET  C                   Return if the line isn't full yet.
15C0            CALL #1467,P_NEWLINE     Otherwise someone has forgotten that
15C3            LD   HL,#2065            printer lines aren't endless, so print
15C6            SET  1,(HL)              a 'NEWLINE' and signal 'ignore next
15C8            RET                      character if it is a CR'.

THE 'SEND A BYTE TO PRINTER' SUBROUTINE
This routine is also called by using command code 57 (#39). It sends the 8 bit
code in
the A register to the printer port, after checking if the printer is busy. The
BREAK key
is tested.

15C9 PNTP       LD   (#3E4F),A           Store the code temporarily.
15CC PNTP_1     CALL #0497,TST_BREAK     Exit if the BREAK key is pressed.
15CF            IN   A,(247)             Test the BUSY line of the printer.
15D1            BIT  7,A
15D3            JR   NZ,#15CC,PNTP_1     Wait until printer isn't BUSY.
15D5            IN   A,(247)
15D7            BIT  7,A
15D9            JR   NZ,#15CC,PNTP_1
15DB            IN   A,(247)
15DD            BIT  7,A
15DF            JR   NZ,#15CC,PNTP_1
15E1            LD   A,(#3E4F)           Send the code to the printer port.
15E4            OUT  (247),A
15E6            LD   A,(#3DDA)           Fetch current control port status.
15E9            OR   #40                 Give a STROBE.
15EB            OUT  (239),A
15ED            AND  #BF                 Reset STROBE.
15EF            OUT  (239),A
15F1            LD   A,(#3E4F)           Return with the A register holding the
                                         outputted byte, 'RET' forgotten?
 ____________________________
|Previous|Next|Contents|Index|
###### 15f4-flags.html ######
###### 15f4-flags.html ######


 ____________________________
|Previous|Next|Contents|Index|
The flag set and test routines

THE 'SIGNAL ..' SUBROUTINES
These subroutines are used to signal various states of the +D. The
corresponding test
routines are located from #161C and onwards. Clearing is done by loading 0 into
FLASG3,
resetting all flags at once.

15F4 SIGN_0     RST  #18,F_ADDR
15F5            SET  0,(HL)
15F7            POP  HL
15F8            RET

15F9 SIGN_1     RST  #18,F_ADDR
15FA            SET  1,(HL)
15FC            POP  HL
15FD            RET

15FE SIGN_2     RST  #18,F_ADDR
15FF            SET  2,(HL)
1601            POP  HL
1602            RET

1603 SIGN_3     RST  #18,F_ADDR
1604            SET  3,(HL)
1606            POP  HL
1607            RET

1608 SIGN_4     RST  #18,F_ADDR
1609            SET  4,(HL)
160B            POP  HL
160C            RET

160D SIGN_5     RST  #18,F_ADDR
160E            SET  5,(HL)
1610            POP  HL
1611            RET

1612 SIGN_6     RST  #18,F_ADDR
1613            SET  6,(HL)
1615            POP  HL
1616            RET

1617 SIGN_7     RST  #18,F_ADDR
1618            SET  7,(HL)
161A            POP  HL
161B            RET

THE 'TEST ..' SUBROUTINES
These subroutines are used to test the various states of the +D system.

161C TEST_0     RST  #18,F_ADDR
161D            BIT  0,(HL)
161F            POP  HL
1620            RET

1621 TEST_1     RST  #18,F_ADDR
1622            BIT  1,(HL)
1624            POP  HL
1625            RET

1626 TEST_2     RST  #18,F_ADDR
1627            BIT  2,(HL)
1629            POP  HL
162A            RET

162B TEST_3     RST  #18,F_ADDR
162C            BIT  3,(HL)
162E            POP  HL
162F            RET

1630 TEST_4     RST  #18,F_ADDR
1631            BIT  4,(HL)
1633            POP  HL
1634            RET

1635 TEST_5     RST  #18,F_ADDR
1636            BIT  5,(HL)
1638            POP  HL
1639            RET

163A TEST_6     RST  #18,F_ADDR
163B            BIT  6,(HL)
163D            POP  HL
163E            RET

163F TEST_7     RST  #18,F_ADDR
1640            BIT  7,(HL)
1642            POP  HL
1643            RET
 ____________________________
|Previous|Next|Contents|Index|
###### 1644-errrst.html ######
###### 1644-errrst.html ######


 ____________________________
|Previous|Next|Contents|Index|
The error restarts

THE 'ERROR' RESTARTS
The following 32 routines consist each of a call to the +D error routine
directly
followed by the error byte.

1644 REP_0      RST  #20,DISC_ERR
1645            DEFB #00                 'Nonsense in G+DOS'
1646 REP_1      RST  #20,DISC_ERR
1647            DEFB #01                 'Nonsense in GNOS'
1648 REP_2      RST  #20,DISC_ERR
1649            DEFB #02                 'Statement END error'
164A REP_3      RST  #20,DISC_ERR
164B            DEFB #03                 'BREAK requested'
164C REP_4      RST  #20,DISC_ERR
164D            DEFB #04                 ',SECTOR error'
164E REP_5      RST  #20,DISC_ERR
164F            DEFB #05                 'FORMAT data lost'
1650 REP_6      RST  #20,DISC_ERR
1651            DEFB #06                 'CHECK DISC in drive'
1652 REP_7      RST  #20,DISC_ERR
1653            DEFB #07                 'No "+ SYS " file'
1654 REP_8      RST  #20,DISC_ERR
1655            DEFB #08                 'Invalid FILE NAME'
1656 REP_9      RST  #20,DISC_ERR
1657            DEFB #09                 'Invalid STATION'
1658 REP_10     RST  #20,DISC_ERR
1659            DEFB #0A                 'Invalid DEVICE'
165A REP_11     RST  #20,DISC_ERR
165B            DEFB #0B                 'VARIABLE not found'
165C REP_12     RST  #20,DISC_ERR
165D            DEFB #0C                 'VERIFY failed'
165E REP_13     RST  #20,DISC_ERR
165F            DEFB #0D                 'Wrong FILE type'
1660 REP_14     RST  #20,DISC_ERR
1661            DEFB #0E                 'MERGE error'
1662 REP_15     RST  #20,DISC_ERR
1663            DEFB #0F                 'CODE error'
1664 REP_16     RST  #20,DISC_ERR
1665            DEFB #10                 'PUPIL set'
1666 REP_17     RST  #20,DISC_ERR
1667            DEFB #11                 'Invalid CODE'
1668 REP_18     RST  #20,DISC_ERR
1669            DEFB #12                 'Reading a WRITE file'
166A REP_19     RST  #20,DISC_ERR
166B            DEFB #13                 'Writing a READ file'
166C REP_20     RST  #20,DISC_ERR
166D            DEFB #14                 'O.K. G+DOS'
166E REP_21     RST  #20,DISC_ERR
166F            DEFB #15                 'Network OFF'
1670 REP_22     RST  #20,DISC_ERR
1671            DEFB #16                 'Wrong DRIVE'
1672 REP_23     RST  #20,DISC_ERR
1673            DEFB #17                 'Disc WRITE protected'
1674 REP_24     RST  #20,DISC_ERR
1675            DEFB #18                 'Not enough SPACE on disc'
1676 REP_25     RST  #20,DISC_ERR
1677            DEFB #19                 'Directory FULL'
1678 REP_26     RST  #20,DISC_ERR
1679            DEFB #1A                 'File NOT FOUND'
167A REP_27     RST  #20,DISC_ERR
167B            DEFB #1B                 'END of file'
167C REP_28     RST  #20,DISC_ERR
167D            DEFB #1C                 'File NAME used'
167E REP_29     RST  #20,DISC_ERR
167F            DEFB #1D                 'NO G+DOS loaded'
1680 REP_30     RST  #20,DISC_ERR
1681            DEFB #1E                 'STREAM used'
1682 REP_31     RST  #20,DISC_ERR
1683            DEFB #1F                 'CHANNEL used'
 ____________________________
|Previous|Next|Contents|Index|
###### 1684-misc2.html ######
###### 1684-misc2.html ######


 ____________________________
|Previous|Next|Contents|Index|
Miscalleneous routines II

THE 'FLASH BORDER' SUBROUTINE
When +D system variable RBCC (address @0) doesn't hold zero, this subroutine
flashes the
border. The border colour is then obtained by masking the E register (holds
sectornumber)
with RBCC.

1684 FLASH_BORD LD   A,(#2000)           Fetch RBCC.
1687            AND  E                   Incorporate sectornumber.
1688            RET  Z                   Return if 'no flashing'.
1689            AND  #07                 Keep border colour only.
168B            OUT  (254),A             Set the border and finished.
168D            RET

THE 'BORDER COLOUR RESTORE' SUBROUTINE
This subroutine is used whenever the border colour was changed during an I/
O operation,
and needs to be restored to its original state.

168E BORD_REST  PUSH AF
168F            LD   A,(23624)           Fetch lower screen attribute (BORDCR).
1692            AND  #38                 Only the border bits.
1694            RRCA                     Move the bits to 0-2.
1695            RRCA
1696            RRCA
1697            OUT  (254),A             Restore colour.
1699            POP  AF
169A            RET

THE 'PRINT DIRECTORY DESCR.' SUBROUTINE
This subroutine is used to print the directory description of a file during an
'extended
CAT' command. On entry the A register holds the directory description.

169B PRT_TYPE   PUSH AF
169C            LD   HL,#16E9,TYPE_TABLE Start of messages table.
169F            LD   BC,85               Length of table excluding 'WHAT?'.
16A2            CPIR                     Make HL point to right message. HL
                                         points to 'WHAT?' with unknown types.
16A4            CALL #18B8,PRT_MSG_HL    Print the message.
16A7            POP  AF                  Restore file type.
16A8            CP   1
16AA            JR   NZ,#16C1,PRT_NOBAS  Jump with no 'BASIC' files.
16AC            LD   (IX+13),219         Make RPT point to autostart line high.
16B0            CALL #0D97,RPT_HL1       HL points to it now.
16B3            LD   A,(HL)
16B4            AND  192
16B6            JR   NZ,#16E4,PRT_EXIT   Jump if no autostart line present.
16B8            LD   D,(HL)              Otherwise fetch it.
16B9            DEC  HL
16BA            LD   E,(HL)
16BB            EX   DE,HL
16BC            CALL #1744,PRT_NUM       Print it.
16BF            JR   #16E4,PRT_EXIT

Now the other directory descriptions are handled.

16C1 PRT_NOBAS  CP   4
16C3            JR   NZ,#16E4,PRT_EXIT   Jump with no 'CODE' files.
16C5            LD   (IX+13),215         RPT points to file address high byte.
16C9            CALL #0D97,RPT_HL1       Make HL hold RPT.
16CC            LD   D,(HL)              Fetch file address.
16CD            DEC  HL
16CE            LD   E,(HL)
16CF            EX   DE,HL
16D0            PUSH DE
16D1            CALL #1744,PRT_NUM       Print file address.
16D4            LD   A,44                Print a ','.
16D6            CALL #1799,PRT_A
16D9            POP  HL
16DA            DEC  HL
16DB            LD   D,(HL)              Fetch file length.
16DC            DEC  HL
16DD            LD   E,(HL)
16DE            EX   DE,HL
16DF            LD   A,0                 Ignore leading zero's.
16E1            CALL #1746,PRT_N10000    Print the length.
16E4 PRT_EXIT   LD   A,13                Print a NEWLINE and exit.
16E6            JP   #1799,PRT_A

THE 'DIRECTORY DESCRIPTION' TABLE
This table contains the directory description messages as printed with an
'extended
CAT'. Each message is preceeded by is description value.

16E9 TYPE_TABLE DEFB 1
16EA            DEFM "BAS "
16EE            DEFB 2
16EF            DEFM "D.ARRAY"
16F6            DEFB 3
16F7            DEFM "$.ARRAY"
16FE            DEFB 4
16FF            DEFM "CDE "
1703            DEFB 5
1704            DEFM "SNP 48k"
170B            DEFB 6
170C            DEFM "MD.FILE"
1713            DEFB 7
1714            DEFM "SCREEN$"
171B            DEFB 8
171C            DEFM "SPECIAL"
1723            DEFB 9
1724            DEFM "SNP 128k"
172C            DEFB 10
172D            DEFM "OPENTYPE"
1735            DEFB 11
1736            DEFM "EXECUTE"
173D            DEFB 12
173E            DEFM "WHAT?"
1743            DEFB 0

THE 'PRINT NUMBER' SUBROUTINE
This subroutine prints the number held in the HL register. Entering the routine
at #1744
prints leading spaces, while the other entry points prints the character held
in the A
register in place of leading zero's. A value of 0 means don't print anything.

1744 PRT_NUM    LD   A,32                Spaces are printed in place of leading
                                         zero's.
1746            LD   DE,10000            Start printing with tens-of-thousands.
1749            CALL #1763,PRT_DIGIT
174C PRT_N1000  LD   DE,1000             Start printing with thousands.
174F            CALL #1763,PRT_DIGIT
1752 PRT_N100   LD   DE,100              Start printing with hundreds.
1755            CALL #1763,PRT_DIGIT
1758 PRT_N10    LD   DE,10               Start printing with tens.
175B            CALL #1763,PRT_DIGIT
175E            LD   A,L                 Print units.
175F            ADD  A,"0"               Add ASCII offset for digits.
1761            JR   #1799,PRT_A

THE 'PRINT DIGIT' SUBROUTINE
This subroutine is used to print a digit, the HL register holds the number and
the DE
register the value for 'repeated subtraction'.

1763 PRT_DIGIT  PUSH AF                  Preserve leading character.
1764            XOR  A                   Clear Carry and counter.
1765 PRT_DIG1   SBC  HL,DE               The 'trial' subtraction.
1767            JR   C,#176C,PRT_DIG2    Jump if exhausted.
1769            INC  A                   Count each trial.
176A            JR   #1765,PRT_DIG1      Jump back for next try.

The A register now holds the digit to be printed.

176C PRT_DIG2   ADD  HL,DE               Restore last subtraction.
176D            AND  A
176E            JR   NZ,#1775,PRT_DIG3   Jump if a non zero value is to be
                                         printed.
1770            POP  DE                  Retrieve the leading character into D.
1771            ADD  A,D                 Add it to zero.
1772            RET  Z                   Return if nothing has to be printed.
1773            JR   #1799,PRT_A         Otherwise print the leading character.

Now print the digit.

1775 PRT_DIG3   ADD  A,"0"               Add ASCII offset for digits.
1777            CALL #1799,PRT_A         Print the digit.
177A            POP  DE                  Balance the stack.
177B            LD   A,"0"               All zeroes after any non zero digit
177D            RET                      will be printed as '0'.

THE 'PRINT OUT MESSAGE' SUBROUTINE
This subroutine handles the printing of messages directly following the 'CALL'
instruction to this routine. When the +D's own error stack pointer (D_ERR_SP)
holds a
non-zero value, i.e during hook and command codes, no printing has to take
place. The
carry flag is set and the A register then holds 32, signalling 'error during
hook/command
code execution' as usual.

177E PO_MSG     LD   HL,(#2066)          Fetch (D_ERR_SP).
1781            LD   A,H
1782            OR   L
1783            JR   Z,#178A,PO_MSG1     Jump if it isn't used.
1785            LD   SP,HL               Clear machine stack.
1786            LD   A,32                Signal 'error 32'.
1788            SCF
1789            RET                      Exit.

Now the message can be printed.

178A PO_MSG1    POP  HL                  HL points to the message to be printed
178B PO_MSG2    LD   A,(HL)              Fetch a character.
178C            AND  #7F
178E            CALL #1799,PRT_A         Print it.
1791            BIT  7,(HL)              Bit 7 set signals 'End of message'.
1793            RET  NZ
1794            INC  HL
1795            JR   #178B,PO_MSG2       Repeat for all characters.

THE 'PRINT A SPACE' SUBROUTINE
This subroutine prints a space to the current stream.

1797 PRT_SPACE  LD   A,32                Continue in the 'PRT_A' routine.

THE 'PRINT CHARACTER' SUBROUTINE
This subroutine prints the character held in the A register to the current
stream.

1799 PRT_A      PUSH AF
179A            PUSH BC
179B            PUSH DE
179C            PUSH HL
179D            PUSH IX
179F            RST  #10,CALBAS          Print the character in the A register
17A0            DEFW #0010,PRINT_A_1     by calling the 'main' ROM routine.
17A2            POP  IX
17A4            POP  HL
17A5            POP  DE
17A6            POP  BC
17A7            POP  AF
17A8            RET

THE 'ROM' MESSAGES
Now follow some messages used by the +D system.

17A9 MESG_0     CALL #177E,PO_MSG
17AC            DEFB #0D,#0D,#0D,#0D,#0D,#0D
17B2            DEFM "        "SYSTEM" LOADING"
17CA            DEFB #0D,#0D
17CC            DEFM "          PLEASE  WAIT"
17E2            DEFB #0D,#0D
17E4            DEFM "        (+D ROM Ver 1.A)"
17FC            DEFB #0D,#8D

17FE MESG_1     CALL #177E,PO_MSG
1801            DEFM "OVERWRITE "
180B            DEFB """+128

180C MESG_2     CALL #177E,PO_MSG
180F            DEFM "Are you SURE ? (y/n"
1822            DEFB ")"+128

1823 MESG_3     CALL #177E,PO_MSG
1826            DEFM " (y/n)"
182C            DEFB ")"+128
 ____________________________
|Previous|Next|Contents|Index|
###### 182d-errrout.html ######
###### 182d-errrout.html ######


 ____________________________
|Previous|Next|Contents|Index|
The error routines

THE '+D ERROR' ROUTINE
Whenever a +D error is encountered this routine is executed to handle it.
During syntax
checking the error is handled by the 'main' ROM error handler. Whenever an
error is found
while executing a command code, a return is made with the Carry flag set and
the A
register holding the error number. Only during runtime the error message is
printed.

182D D_ERROR    CALL #168E,BORD_REST     Restore normal border colour.
1830            LD   (#3DED),DE          Track & sector with sector error.
1834            XOR  A
1835            LD   (#3ACF),A           Clear FLAGS3.
1838            POP  HL                  Fetch return address.
1839            LD   DE,(#2066)          Fetch (D_ERR_SP).
183D            LD   A,D
183E            OR   E
183F            LD   A,(HL)              Fetch error code.
1840            JR   Z,#1848,D_ERROR1    Jump if (D_ERR_SP) isn't used.

Whenever hook or command codes are being executed, errors are reported to the
calling
routine by setting the carry flag. The A register holds the error code.

1842            LD   SP,(#2066)          Clear the machine stack.
1846            SCF                      Carry set to signal 'error'.
1847            RET

The routine continues here when an error message is to be printed.

1848 D_ERROR1   LD   (23610),A           Store error code into (ERR_NR).
184B            RES  5,(IY+1)            Signal 'ready for a new key'.
184F            LD   SP,(23613)          Clear machine stack by using (ERR_SP).
1853            RST  #30,SYNTAX_Z        Return via 'main' ROM 'SET_STK'
1854            LD   HL,#16C5,SET_STK    routine to the error handler during
1857            JP   Z,#004F,UNPAGE_HL   syntax checking.
185A            LD   HL,0
185D            LD   (IY+55),H           Clear FLAGX.
1860            LD   (IY+38),H           And X_PTR-hi.
1863            LD   (23563),HL          Clear DEFADD.
1866            INC  L                   Ensure that stream 0 points to channel
1867            LD   (23574),HL          'K'.
186A            RST  #10,CALBAS          Clear all the work areas and the
186B            DEFW #16B0,SET_MIN       calculator stack.
186D            LD   A,(23728)
1870            AND  A                   Exit via 'END' if error messages are
1871            JP   NZ,#047C,END        to be supressed.
1874            RES  5,(IY+55)           Signal 'EDIT mode' FLAGX.
1878            RST  #10,CALBAS          Clear the lower screen.
1879            DEFW #0D6E,CLS_LOWER
187B            SET  5,(IY+2)            Signal 'lower screen will require
                                         clearing'. (TV_FLAG)
187F            RES  3,(IY+2)            Signal 'mode is to be considered
                                         unchanged'.
1883            LD   A,(23610)
1886            CP   4
1888            JR   NZ,#18A5,D_ERROR2   Jump if error isn't 'SECTOR error'.
188A            PUSH AF
188B            LD   DE,(#3DED)          Fetch track and sector where error
188F            LD   H,0                 was signalled.
1891            LD   L,D
1892            PUSH DE
1893            XOR  A                   Print the track number, no leading
1894            CALL #1752,NUM_100       characters.
1897            LD   A,58,":"            Print a colon.
1899            CALL #1799,PRT_A
189C            POP  DE
189D            LD   H,0
189F            LD   L,E
18A0            XOR  A                   Print the sector number, no leading
18A1            CALL #1758,NUM_10        characters.
18A4            POP  AF

The routine now continues with the printing of the error message.

18A5 D_ERROR2   LD   HL,#18C2,ERR_MSGS   HL points to the error message table.
18A8            LD   BC,503              Length of error message table.
18AB            CPIR                     Search for the message.
18AD            CALL #18B8,PRT_MSG_HL    Print it.
18B0            INC  SP                  Drop address of 'main' ROM error
18B1            INC  SP                  handler.
18B2            LD   HL,#1349,MAIN_5A    Print the line and statement number by
18B5            JP   #004F,UNPAGE_HL     jumping into the Spectrum error
                                         handler.

THE 'PRINT MESSAGE HL' SUBROUTINE
This subroutine prints the message pointed to by the HL register.

18B8 PRT_MSG_HL LD   A,(HL)              Fetch a character.
18B9            CP   32
18BB            RET  C                   Exit if it isn't printable, message is
                                         finished.
18BC            CALL #1799,PRT_A         Print the character.
18BF            INC  HL
18C0            JR   PRT_MSG_HL          Continue until message end is reached.

THE 'ERROR MESSAGES' TABLE
The following table contains the +D's error messages. Each message starts with
it's
error number.

18C2 ERR_MSGS   DEFB #00
18C3            DEFM "Nonsense in G+DOS"
18D4            DEFB #01
18D5            DEFM "Nonsense in GNOS"
18E5            DEFB #02
18E6            DEFM "Statement END error"
18F9            DEFB #03
18FA            DEFM "BREAK requested"
1909            DEFB #04
190A            DEFM ",SECTOR error"
1917            DEFB #05
1918            DEFM "FORMAT data lost"
1928            DEFB #06
1929            DEFM "CHECK DISC in drive"
193C            DEFB #07
193D            DEFM "No "+ SYS  " file"
194D            DEFB #08
194E            DEFM "Invalid FILE NAME"
195F            DEFB #09
1960            DEFM "Invalid STATION"
196F            DEFB #0A
1970            DEFM "Invalid DEVICE"
197E            DEFB #0B
197F            DEFM "VARIABLE not found"
1991            DEFB #0C
1992            DEFM "VERIFY failed"
199F            DEFB #0D
19A0            DEFM "Wrong FILE type"
19AF            DEFB #0E
19B0            DEFM "MERGE error"
19BB            DEFB #0F
19BC            DEFM "CODE error"
19C6            DEFB #10
19C7            DEFM "PUPIL set"
19D0            DEFB #11
19D1            DEFM "Invalid CODE"
19DD            DEFB #12
19DE            DEFM "Reading a WRITE file"
19F2            DEFB #13
19F3            DEFM "Writing a READ file"
1A06            DEFB #14
1A07            DEFM "O.K. G+DOS"
1A11            DEFB #15
1A12            DEFM "Network OFF"
1A1D            DEFB #16
1A1E            DEFM "Wrong DRIVE"
1A29            DEFB #17
1A2A            DEFM "Disc write PROTECTED"
1A3E            DEFB #18
1A3F            DEFM "Not enough SPACE on disc"
1A57            DEFB #19
1A58            DEFM "Directory FULL"
1A66            DEFB #1A
1A67            DEFM "File NOT FOUND"
1A75            DEFB #1B
1A76            DEFM "END of file"
1A81            DEFB #1C
1A82            DEFB "File NAME used"
1A90            DEFB #1D
1A91            DEFM "NO G+DOS loaded"
1AA0            DEFB #1E
1AA1            DEFM "STREAM used"
1AAC            DEFB #1F
1AAD            DEFM "CHANNEL used"
1AB9            DEFB #00

1ABA - 1FFF Unused locations (All filled with #FF)
 ____________________________
|Previous|Next|Contents|Index|
###### 2000-rsysvar.html ######
###### 2000-rsysvar.html ######


 ____________________________
|Previous|Next|Contents|Index|
The +D system variables and tables

THE 'SYSTEM VARIABLES'
These variables hold various settings for drives etc. The variables starting at
address
#2000 can be accessed from BASIC with POKE @p,n. Where p is 0 for RBCC at
#2000.

2000 RBCC       DEFB #07                 Flashing borders.
2001 TRAKS1     DEFB 80+128              Drive 1 80 tracks double sided.
2002 TRAKS2     DEFB 80+128              Drive 2 80 tracks double sided.
2003 STPRAT     DEFB 0                   "Steprate" 0 msec.
2004 NSTAT      DEFB 1                   Network on?
2005 WIDTH      DEFB 80                  Printer right margin.
2006 PCODE      DEFB 0                   Expand tokens, etc. before printing.
2007 LSPCE      DEFB 12                  Line spacing 12/72 inch.
2008 LFEED      DEFB 1                   Number of line feeds after CR 1.
2009 LMARG      DEFB 0                   Left margin at 0.
200A GRAPH      DEFB 0                   Print special graphics off.
200B ZXPNT      DEFB 0                   +D printer port on.
200C RESERVED   DEFW #0000
200E ONERR      DEFW #0000               Address of routine called after an
                                         error has occurred.
2010 EVERY_INT  DEFW #208F               Address of routine called at every
                                         interrupt.

THE 'PRINTER CODES' TABLE
Here the printer control codes are stored.

2012 INIT_PRT   DEFB 27,"@",#80,#80
2016            DEFB #80,#80,#80,#80
201A CHAR_PITCH DEFB #80,#80,#80,#80
201E            DEFB #80,#80,#80,#80
2022 N/72_LSPC  DEFB 27,"A",#80,#80
2026            DEFB #80,#80,#80,#80
202A GRAPH_DPI  DEFB 27,"*",5,#80
202E            DEFB #80,#80,#80,#80
2032 INIT_PRT2  DEFB #80,#80,#80,#80
2036            DEFB #80,#80,#80,#80

THE 'GRAPHIC REPRESENTATION' TABLE
This table consists of the graphic representations of the £, # and © signs. The
'GRAPH'
system variable (@10) determines whether the normal code or the graphic
representation is
outputted to the printer.

203A £_SIGN     DEFB %00011000
203B            DEFB %00100000
203C            DEFB %00100000
203D            DEFB %01111000
203E            DEFB %00100000
203F            DEFB %00100000
2040            DEFB %01111100
2041            DEFB %00000000

2042 #_SIGN     DEFB %00000000
2043            DEFB %00100100
2044            DEFB %01111110
2045            DEFB %00100100
2046            DEFB %00100100
2047            DEFB %01111110
2048            DEFB %00100100
2049            DEFB %00000000

204A ©-SIGN     DEFB %01111110
204B            DEFB %10000001
204C            DEFB %10111101
204D            DEFB %10100001
204E            DEFB %10100001
204F            DEFB %10111101
2050            DEFB %10000001
2051            DEFB %01111110

THE 'GREYSCALE' PRINTER CONTROL CODE
This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

2052 GREY_BITIM DEFB 27,"*",5,#40
2056            DEFB #02,#80,#80,#80

THE 'GREYSCALE' TABLE
This table consists of three times three bytes of greyscale info. Each screen
pixel is
converted into 3x3 printer dots during greyscale printing. The printer dots are
ordered
as follows: The first dot row is produced from the first three bytes by taking
the bit,
which number is corresponding with the colour number, from each of the three
bytes. E.g.
for colour 2 (=red) bit 2 is used. In the same way the second and third dot
rows are
produced from the second and third three bytes respectively.
The following eight 3x3 matrices are produced:

 White  Yellow  Cyan  Green Magenta  Red    Blue  Black
  000    000    100    000    100    010    110    111
  000    010    010    101    111    111    111    111
  000    000    001    000    001    010    011    111

Note that some greytones aren't right. E.g. cyan is darker than green, which
isn't so on
the screen.

                       colour
                      76543210

205A GREYSCALE  DEFB %00101011
205B            DEFB %00011111           first row
205C            DEFB %00000001

205D            DEFB %00000111
205E            DEFB %01101111           second row
205F            DEFB %00000111

2060            DEFB %00000001
2061            DEFB %00011111           third row
2062            DEFB %00101011

2063            DEFW #1429,P_ALL         Address of 'output' routine for "P".
2065            DEFB #00                 The 'ENTER' flag.
2066            DEFW #0000               D_ERR_SP
2067            DEFB #00

THE 'SNAPSHOT-FILE' UFIA
The following bytes are the last 20 bytes of a snapshot file UFIA.

2068 SNAP_UFIA  DEFB 0                   Directory description.
2069            DEFM "Snap      "        File name.
2073            DEFB 3                   File type.
2074            DEFW #0000               File length.
2076            DEFW #0000               File address.
2078            DEFW #0000               Not used with Snap's.
207A            DEFW #FFFF               Not used with Snap's.

SOME 'LOST' ASSEMBLER TEXT
Miles-Gordon seem to have lost some of their assembler text.

207C            DEFM "JP"
207E            DEFB #07
207F            DEFB "Z"

THE 'RAM JUMPS'
These 13 'jumps' are used from the ROM to call +D System routines present in
RAM (after
the System file has been loaded).

2080 JCOPS      NOP                      The small dump isn't patched.
2081            NOP
2082            RET
2083 JCOPS2     NOP                      Neither is the greyscale dump.
2084            NOP
2085            RET
2086 JPCHAN     NOP                      Nor the PCHAN_OUT routine.
2087            NOP
2088            RET
2089 JPOKE      NOP                      Nor the POKE routine.
208A            NOP
208B            RET
208C JPRTR      NOP                      Even the TAKE_PRTR routine isn't
208D            NOP                      patched.
208E            RET
208F JJIFFY     NOP                      Called EVERY_INT.
2090            NOP
2091            RET
2092 JLOAD      JP   #28EE,LD_VF_MR1     Load the file.
2095 JHXFER     JP   #2F8B,HXFER         Transfer UFIA to DFCA.
2098 JKSCAN     JP   #2245,JIFFY         Called every interrupt.
209B JMSG3      JP   #3090,MSG_3         Give the copyright message.
209E JHOOK      JP   #228E,HOOK_CODE     Execute the hook or command code.
20A1 JSNAP      JP   #2115,SNAP          Continue with the Snapshot routine.
20A4 JCTRL      JP   #20A7,CTRL          Continue with the control routine.

THE 'CONTROL ROUTINE' CONTINUED
The final part of the control routine determines which command failed the
Spectrum
syntax. If it is a +D command then the apropriate routine is executed.

20A7 CTRL       PUSH AF
20A8            LD   HL,#3DF4
20AB            LD   BC,60
20AE RESET_VARS LD   (HL),255            Reset +D work areas, including UFIA1
20B0            INC  HL                  and UFIA2.
20B1            DEC  BC 20B2            LD   A,B
20B3            OR   C
20B4            JR   NZ,#20AE,RESET_VARS
20B6            LD   (#3ACF),A           Clear FLAGS3.
20B9            LD   IX,#3AC3            Point to +D system variables.
20BD            POP  AF                  Fetch the command.
20BE            LD   (#3DFF),A           Store it.
20C1            CP   207                 Is the command 'CAT' ?
20C3            JP   Z,#245B,CAT         Jump to the CAT routine if so.
20C6            CP   208                 Also for 'FORMAT',...
20C8            JP   Z,#2AB9,FORMAT
20CB            CP   209                 ...'MOVE',...
20CD            JP   Z,#2B03,MOVE
20D0            CP   210                 ...'ERASE',...
20D2            JP   Z,#250C,ERASE
20D5            CP   211                 ...'OPEN #',...
20D7            JP   Z,#2C68,OPEN
20DA            CP   212                 ...'CLOSE #',...
20DC            JP   Z,#2E16,CLOSE
20DF            CP   213                 ...'MERGE',...
20E1            JP   Z,#28E4,MERGE
20E4            CP   214                 ...'VERIFY',...
20E6            JP   Z,#28DF,VERIFY
20E9            CP   239                 ...'LOAD',...
20EB            JP   Z,#28DA,LOAD
20EE            CP   248                 ...'SAVE',...
20F0            JP   Z,#288B,SAVE
20F3            CP   251                 ...'CLS',...
20F5            JP   Z,#2EB9,CLS
20F8            CP   253                 ...'CLEAR',...
20FA            JP   Z,#2E39,CLEAR
20FD            CP   255                 ...'COPY',...
20FF            JP   Z,#3020,COPY
2102            LD   HL,(#200E)          Fetch ONERR address.
2105            LD   A,H
2106            OR   L
2107            RET  Z                   Return if no ON ERROR address.
2108            LD   (#2110),HL          Store it so it can be CALBASsed.
210B            POP  HL                  Drop return address.
210C            LD   A,(#3DFF)           Fetch command which has to be examined
210F            RST  #10,CALBAS          by user-routine (BASIC extensions).
2110            DEFW #0000               CALL the extend BASIC routine(s).
2112            JP   #047C,END           Test end of command and exit.

THE 'SNAPSHOT ROUTINE' CONTINUED
Here the snapshot routine continues with the disk related functions, keys 3-5.

2115 SNAP       LD   HL,16384            start of RAM (also start of SCR$).
2118            BIT  2,E
211A            JR   NZ,#2123,NO_SCR     3: Save SCREEN$.
211C            LD   A,7                 type=SCR$.
211E            LD   DE,6912             length of SCR$.
2121            JR   #2139,SNAP_SAVE

2123 NO_SCR     BIT  3,E
2125            JR   NZ,#212E,NO_SNP48   4: 48K Snapshot.
2127            LD   A,5                 type=48K Snap.
2129            LD   DE,49152            length of 48K RAM.
212C            JR   #2139,SNAP_SAVE

212E NO_SNP48   BIT  4,E
2130            RET  NZ                  Exit if not 5: 128K Snapshot.
2131            LD   A,9                 Type=128K Snap.
2133            LD   DE,16384            Length of a RAM-page.
2136            LD   HL,49152            Start of a RAM-page.
2139 SNAP_SAVE  LD   (#2068),A           Store type in snapshot UFIA.
213C            LD   (#2074),DE          Store length in UFIA.
2140            LD   (#2076),HL          And the start-address.
2143            POP  AF                  Drop return addres.
2144            LD   B,#FE               Key CAPS-V I/O address.
2146            IN   A,(C)
2148            BIT  0,A
214A            JR   NZ,#2154,SNAP_NAME  If CAPS is pressed the Snap goes to
214C            LD   A,(#3ACE)           the other drive.
214F            XOR  #03
2151            LD   (#3ACE),A
2154 SNAP_NAME  LD   A,%01000000
2156            CALL #09A5,SCAN_CAT      Search first free catalogue entry.
2159            RET  NZ                  Exit if catalogue full.
215A            LD   A,D                 Track to A.
215B            AND  #07                 Jump if CAT-entry will be located
215D            JR   Z,#2164,SNAP_N1     on track 0.

The name a snapshot-file is given, depends on the position it's going to occupy
in the
directory. When the entry will be located on the first track the names range
from 'Snap
A' to 'Snap T', if however the entry will be located on track 1 to 3 the
character after
'Snap' will be the track number. I.e. 'Snap1A' to 'Snap1T' for track 1, etc.
Notice that
the character after 'Snap' is never set to a ' '.

215F            ADD  A,48                ASCII offset for '0'.
2161            LD   (#206D),A           Store a 1, 2 or 3 in name-part of
UFIA.
2164 SNAP_N1    LD   L,E                 Store sector in L.
2165            SLA  L                   Two entries per sector.
2167            DEC  L
2168            LD   A,(IX+14)           Is it the first or second entry in the
216B            ADD  A,L                 CAT-sector.
216C            ADD  A,64                Add ASCII 'A' offset.
216E            LD   (#206E),A           Store 'A' to 'T' in name-part of UFIA.
2171            LD   HL,#2068,SNAP_UFIA  Copy UFIA to DFCA.
2174            LD   DE,#3E05
2177            LD   BC,20
217A            LDIR
217C            CALL #0AD9,OFSM_2        Open the file.
217F            LD   HL,#3FEA            Copy snap registers to catalogue
entry.
2182            LD   DE,#3BB2
2185            LD   BC,22
2188            LDIR
218A            LD   A,(#2068)           Get directory description.
218D            CP   9
218F            JP   NZ,#222D,NO_SNP128  Jump if not a 128K Snapshot.
2192            LD   HL,49152            Now the 5 first bytes of the current
2195            LD   DE,#3BD6            RAM-page are saved in the +D RAM
2198            LD   BC,5                and replaced by the "BRUCE" message.
219B            LDIR                     This is done to determine the
currently
219D            LD   HL,#2228,BRUCE      paged in RAM-page.
21A0            LD   DE,49152
21A3            LD   BC,5
21A6            LDIR
21A8            XOR  A                   Signal '128K ROM bank active'.
21A9            LD   (#3E19),A
21AC            CALL #011D,?_ROMBANK     Determine current 'main' ROM bank.
21AF            JR   NZ,#21B6,SNP128_1   Jump if 128K ROM bank.
21B1            LD   A,#10               Signal '48K ROM bank active'.
21B3            LD   (#3E19),A
21B6 SNP128_1   CALL #0511,REST_PBUF     Restore printer buffer contents.
21B9            LD   A,(#3E19)
21BC            CALL #223F,RAMPAGE_A     Page in current ROM bank & RAM page 0.

The code now tests which screen is active. Because it isn't possible to detect
which is
the active screen, the user is consulted. By making nice border stripes the
user is
signalled that 'Y' (meaning: yes, screen changed) or 'N' (meaning: no, screen
hasn't
changed) has to be pressed.

21BF SNP128_2   LD   BC,#DFFE            Keyboard port and I/O address for Y-P.
21C2            IN   E,(C)
21C4            BIT  4,E
21C6            JR   Z,#21D7,CHANGED_$   Jump if 'Y' was pressed, screen
changed
21C8            LD   B,#7F               I/O address for B-SPACE.
21CA            IN   E,(C)
21CC            BIT  3,E
21CE            JR   Z,#21E2,SAME_$      Jump if 'N' was pressed, same screen.
21D0            INC  A
21D1            AND  #07
21D3            OUT  (C),A               Make nice stripes in border again.
21D5            JR   #21BF,SNP128_2      Only 'Y' or 'N' is accepted.

21D7 CHANGED_$  LD   A,(#3E19)
21DA            OR   #08                 Signal 'screen 1'.
21DC ?_RAMBANK  LD   (#3E19),A
21DF            CALL #223F,RAMPAGE_A     Page in active ROM bank and screen.

Now the 'which RAM bank' test is executed. The active RAM bank is determined by
searching which bank has been given the "BRUCE" message.

21E2 SAME_$     LD   DE,49152            Here the message has been placed.
21E5            LD   HL,#2228,BRUCE      Message to be found.
21E8            LD   B,5                 There are five bytes in the message.
21EA BRUCE_1    LD   A,(DE)
21EB            CP   (HL)
21EC            JR   Z,#21F4,BRUCE_2     Jump if characters match.
21EE            LD   A,(#3E19)           Otherwise it has to be one of the
other
21F1            INC  A                   banks.
21F2            JR   ?_RAMBANK

21F4 BRUCE_2    INC  DE
21F5            INC  HL
21F6            DJNZ #21EA,BRUCE_1       All five characters have to match.
21F8            LD   HL,#3BD6            The active RAM bank has been found,
21FB            LD   DE,49152            restore the original five bytes.
21FE            LD   BC,5
2201            LDIR
2203            LD   A,(#3E19)
2206            PUSH AF                  Save the page-configuration byte in
the
2207            CALL #0761,SBYT          snapshot file.
220A            AND  #F8                 Mask RAM bank, start with 0.
220C            LD   B,8                 There are eight RAM banks
220E SAVE_BANK  PUSH AF
220F            PUSH BC
2210            CALL #223F,RAMPAGE_A     Page in RAM bank.
2213            LD   HL,(#2076)
2216            LD   DE,(#2074)
221A            CALL #0850,HSVBK_2       Save DE bytes starting at address HL.
221D            POP  BC
221E            POP  AF
221F            INC  A                   Next RAM bank.
2220            DJNZ #220E,SAVE_BANK     Loop for all eight 16K RAM banks.
2222            POP  AF
2223            CALL #223F,RAMPAGE_A     Page in original RAM bank.
2226            JR   #223C,SNAP_CLOSE

2228 BRUCE      DEFM "BRUCE"

222D NO_SNP128  CP   7                   Copy the 9 header bytes to the file if
222F            CALL Z,#2879,SAVE_HEAD1  it is a SCREEN$.
2232            LD   HL,(#2076)
2235            LD   DE,(#2074)
2239            CALL #0850,HSVBK_2       Save DE bytes starting at address HL.
223C SNAP_CLOSE JP   #0B89,CFSM          Close the file.

THE 'PAGE 128K RAM' ROUTINE
The 128K RAM-bank contained in the A register is paged-in.

223F RAMPAGE_A  LD   BC,#7FFD            128K bank-switch port address.
2242            OUT  (C),A               Select RAM bank.
2244            RET

THE 'JIFFY' CALL
This routine is executed whenever KEY-SCAN in the Spectrum ROM is reached at
#028E. It
can be used to executed a routine with every interrupt.

2245 JIFFY      LD   HL,(#2010)          Call routine which has to be called
2248            JP   (HL)                every 'interrupt'. (Normal #208F)


THE 'MOUSE' ROUTINE
This routine is also present in the DISCiPLE and tests a mouse-like device.
Pointers
which seem to keep track of screen coordinates are updated when necessary.

2249 TEST_MOUSE LD   BC,#03FF            The MGT mouse port?
224C            IN   A,(C)
224E            BIT  7,A
2250            RET  NZ                  Return if no activity.
2251            CPL
2252            AND  #05                 Return if there was no horizontal or
2254            RET  Z                   vertical movement.
2255            LD   HL,#228B,SIGN_MOUSE
2258            PUSH HL
2259            LD   HL,#2275,MOVE_VERT
225C            PUSH HL
225D            IN   D,(C)               Read mouse bits again.
225F            LD   HL,#3DF1            Mouses x-coordinate.
2262            BIT  0,D
2264            RET  NZ                  Return to vertical movement test.
2265            BIT  1,D
2267            JR   Z,#226F,MOVE_RIGHT  Jump if mouse was moved right.
2269            LD   A,0                 Left side of screen.
226B            CP   (HL)
226C            RET  Z                   Return if left movement isn't
possible.
226D            DEC  (HL)                Otherwise decrement x-coordinate.
226E            RET

226F MOVE_RIGHT LD   A,255               Right side of screen.
2271            CP   (HL)
2272            RET  Z                   Return if right movement impossible.
2273            INC  (HL)                Otherwise increment x.
2274            RET

2275 MOVE_VERT  LD   HL,#3DF2            Y-coordinate of mouse.
2278            BIT  2,D
227A            RET  NZ                  Return to signal mouse.
227B            BIT  3,D
227D            JR   NZ,#2285,MOVE_UP    Jump if mouse was moved up.
227F            LD   A,0                 Bottom side of screen.
2281            CP   (HL)
2282            RET  Z                   Return if bottom has been reached.
2283            DEC  (HL)                Otherwise move towards it.
2284            RET

2285 MOVE_UP    LD   A,175               Top side of screen.
2287            CP   (HL)
2288            RET  Z                   Return if top was reached.
2289            INC  (HL)                Otherwise increment y-coordinate.
228A            RET

228B SIGN_MOUSE OUT  (C),D               Give original signal to mouse.
228D            RET
 ____________________________
|Previous|Next|Contents|Index|
###### 228e-rhook.html ######
###### 228e-rhook.html ######


 ____________________________
|Previous|Next|Contents|Index|
The Hook and Command code routine &
   The Command code table

This routine is entered with the A register holding an 'IF1 hook code', a '+D
command
code' or an invalid error code. The routine calls a set of subroutines in the
+D system,
and is intended to help machine-code access to the drives. There are two tables
containing addresses of the routines, the first is located in ROM (at #0DD7)
and consists
of the addresses of the routines for the IF1 hookcodes. The second table is
located at
address #22DE and consists of the addresses of the +D command code routines.

228E HOOK_CODE  LD   (#3AC5),DE
2292            CP   24
2294            JR   NC,#22BC,COMM_CODE  Jump if code isn't a hook code.
2296            LD   DE,#0DD7,IF1_HOOK   Address of hook (IF1) code table.
2299 CODE_CONT  LD   (IY+0),#FF          Clear error.
229D            SET  2,(IY+1)            What's the purpose of this?
22A1            INC  HL                  Advance return address past the code.
22A2            PUSH HL
22A3            ADD  A,A                 Table is made of two byte addresses,
so
22A4            LD   L,A                 double code.
22A5            LD   H,0
22A7            ADD  HL,DE               Point codes entry in table.
22A8            LD   E,(HL)              Fetch the address of the routine.
22A9            INC  HL
22AA            LD   D,(HL)
22AB            LD   HL,#22C8,HOOK_RET   Return address after completion of
22AE            PUSH HL                  code.
22AF            LD   (#2066),SP          Set D_ERR_SP.
22B3            EX   DE,HL
22B4            LD   DE,(#3AC5)          Restore DE and A.
22B8            LD   A,( #3E4F)
22BB            JP   (HL)                Jump to the routine.

22BC COMM_CODE  SUB  24                  Adjust range for command codes
(0..20).
22BE            CP   21
22C0            JP   NC,#1666,REP_17     Give error if not a command code.
22C3            LD   DE,#22DE,MGT_HOOK   Address of command code table.
22C6            JR   #2299,CODE_CONT     Continue with command codes.

THE 'HOOK_RET' ROUTINE
This routine is entered whenever a hook or command code is finished.

22C8 HOOK_RET   PUSH HL
22C9            LD   HL,#0000
22CC            LD   (#2066),HL          Clear D_ERR_SP.
22CF            POP  HL
22D0            CALL #168E,BORD_REST     Return to the calling routine with the
22D3            JP   #0050,UNPAGE_1      'main' ROM paged in.

THE 'PAGE-IN +D' SUBROUTINE
This is called by using 'command code' 71. On return the +D is paged-in and the
HL
register contains 0, to indicate that this is a +D (with a DISCiPLE HL holds
1).

22D6 PATCH      POP  HL                  Drop 'HOOK_RET' return address.
22D7            LD   HL,#0000            Clear 'D_ERR_SP'.
22DA            LD   (#2066),HL
22DD            RET                      HL=0, meaning 'this is a +D'.

THE 'COMMAND CODE ADRESSES' TABLE
This jump table consists of the 21 addresses of the routines called by using
the various
'command codes'.

22DE MGT_HOOK   DEFW #2F8B,HXFER         Command code #33, 51.
22E0            DEFW #2F9E,OFSM          Command code #34, 52.
22E2            DEFW #2FA4,HOFLE         Command code #35, 53.
22E4            DEFW #0761,SBYT          Command code #36, 54.
22E6            DEFW #2FAB,HSVBK         Command code #37, 55.
22E8            DEFW #0B89,CFSM          Command code #38, 56.
22EA            DEFW #15C9,PNTP          Command code #39, 57.
22EC            DEFW #12D2,COPS          Command code #3A, 58.
22EE            DEFW #2FB1,HGFLE         Command code #3B, 59.
22F0            DEFW #077F,LBYT          Command code #3C, 60.
22F2            DEFW #2FB7,HLDBK         Command code #3D, 61.
22F4            DEFW #3016,JWSAD         Command code #3E, 62.
22F6            DEFW #300F,JRSAD         Command code #3F, 63.
22F8            DEFW #06B6,REST          Command code #40, 64.
22FA            DEFW #2FBD,HERAZ         Command code #41, 65.
22FC            DEFW #133E,COPS2         Command code #42, 66.
22FE            DEFW #3154,PCAT          Command code #43, 67.
2300            DEFW #2FD4,HRSAD         Command code #44, 68.
2302            DEFW #2FF2,HWSAD         Command code #45, 69.
2304            DEFW #3110,OTFOC         Command code #46, 70.
2305            DEFW #22D6,PATCH         Command code #47, 71.
 ____________________________
|Previous|Next|Contents|Index|
###### 2308-basic1.html ######
###### 2308-basic1.html ######


 ____________________________
|Previous|Next|Contents|Index|
The BASIC command execution routines I

THE 'COPY FILE(S)' ROUTINE
This routine handles the copying of files. It is executed as soon as the
'EXPT_PARMS'
routine at #2665 finds a 'TO' keyword. The return address to the routine which
called
'EXPT_PARMS' is dropped at #230E.

2308 TO         CALL #3108,TEST_SAVE
230B            JP   Z,#1644,REP_0       Give error if not SAVEing.
230E            POP  HL                  Drop return address to SAVE routine.
230F            CALL #2626,SWAP_UFIAS    Swap the UFIAS.
2312            RST  #28,NEXT_C
2313            AND  #DF                 Drop lower case bit.
2315            CP   68,"D"
2317            JP   NZ,#1644,REP_0      Jump if 2nd device isn't "D".
231A            LD   (#3E04),A           Store it in DEV_TYPE1.
231D            CALL #25E2,EXPT_DEVN     Evaluate drive num., store it in
UFIA1.
2320            CALL #25A2,SEPARATOR     Test for a separator, jump if one
2323            JR   Z,#2328,TO_1        found, i.e. a 2nd name is given.
2325            CALL #1608,SIGN_4        Used here to signal 'use source
                                         filename for destination file'.
2328 TO_1       CALL Z,#2640,EXPT_FNAME  Evaluate filename if there was a
                                         separator.
232B            CALL #2626,SWAP_UFIAS    Swap the UFIAS again.
232E            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2331            LD   HL,#3E1E            Copy the second filename and directory
2334            LD   DE,#3E32            description.
2337            LD   BC,11
233A            LDIR
233C            LD   HL,#0001            Track 0 sector 1.
233F            LD   (#3DED),HL
2342            LD   HL,#0000            Disk buffer offset #0000.
2345            LD   (#3DEB),HL
2348 TO_2       CALL #0702,TEST_DRV      Is the drive defined?
234B            CALL #23EC,TO_SEARCH     Search for a file to be copied.
234E            JP   NZ,#23BF,TO_EXIT    Jump if there are no files left.
2351            CALL #0C04,LOAD_1ST      Copy file description (directory
                                         description and filename) to UFIA2 and
                                         load the first sector of the file into
                                         the disk buffer.
2354            LD   A,(#3E1E)           Get directory description.
2357            CP   5
2359            JR   Z,#2348,TO_2        Jump with 'Snapshot 48K'.
235B            CP   6
235D            JR   Z,#2348,TO_2        Jump with 'Microdrive file'.
235F            CP   9
2361            JR   Z,#2348,TO_2        Jump with 'Snapshot 128K'.
2363            CP   10
2365            JR   Z,#2348,TO_2        Jump with 'Opentype file'.
2367            CP   11
2369            JR   Z,#2348,TO_2        Jump with 'Execute file'.
                                         These five file types can't be copied
                                         with the 'SAVE .. TO ..' command.

Now the file is going to be copied.
NOTE: The file to be copied will destroy everything above 'start of BASIC'+256
and no
checks are made if the file fits in memory and if the stack isn't overwritten.

236B            CALL #28CD,LOAD_HEAD2    Copy the file header (the 9 bytes
                                         consisting of filetype, length, etc.)
                                         to UFIA2.
236E            LD   HL,(23635)          Fetch start of BASIC program (PROG).
2371            INC  H                   Add 256 to it.
2372            LD   DE,(#3E2A)          Fetch length of file (LENGTH2_1).
2376            CALL #079E,LOAD_FILE     Load DE bytes, starting at address HL.
2379            CALL #23CB,TO_MSG        Print the message "CHANGE disc ...."
if
                                         source drive is destination drive.
237C            CALL #2626,SWAP_UFIAS    Swap the UFIA's again. The header of
                                         the loaded file is now held in UFIA1.
237F            CALL #1630,TEST_4        Used here to test whether a 2nd
2382            JR   NZ,#239A,TO_5       filename was given. Jump if not.
2384            LD   HL,#3E33            Here the 2nd filename was stored.
2387            LD   DE,#3E06            Start of filename of loaded file.
238A            LD   B,10                Filename length.

Now the characters from the filename of the loaded file are replaced by the
characters
of the 2nd filename. Except when the wildcard characters '*' and '?' were used
in the 2nd
name. With '*' all next characters are left unchanged, with '?' the current
character
isn't changed.

238C TO_3       LD   A,(HL)
238D            CP   42,"*"              With a '*' don't replace the remaining
238F            JR   Z,#239A,TO_5        characters.
2391            CP   63,"?"              With a '?' in name 2 don't replace
this
2393            JR   Z,#2396,TO_4        character.
2395            LD   (DE),A              Store this character.
2396 TO_4       INC  HL
2397            INC  DE
2398            DJNZ #238C,TO_3          Repeat for all 'normal' characters.
239A TO_5       CALL #0702,TEST_DRV
239D            CALL #0AD9,OFSM_2        Open the file for SAVEing.
23A0            JR   NZ,#23B3,TO_6       Jump if file existed already and the
                                         user didn't want to overwrite it.
23A2            CALL #2879,SAVE_HEAD1    SAVE the 9 header bytes to the file.
23A5            LD   HL,(23635)          Fetch start of BASIC (PROG), and add
23A8            INC  H                   256 to it. (here the file was loaded)
23A9            LD   DE,(#3E11)          Length of file.
23AD            CALL #0850,HSVBK_2       Save the file.
23B0            CALL #0B89,CFSM          Close the file.
23B3 TO_6       CALL #2626,SWAP_UFIAS    Swap the UFIA's again.
23B6            CALL #15F4,SIGN_0        Signal 'at least one file has been
                                         copied'
23B9            CALL #23CB,TO_MSG        Print message "Input ..." if necessary
23BC            JP   #2348,TO_2          Repeat until no more files have to be
                                         copied.

23BF TO_EXIT    CALL #161C,TEST_0        Give error if there isn't one file
23C2            JP   Z,#1678,REP_26      copied.
23C5            LD   HL,#11B7,NEW        Otherwise jump to the appropriate
'NEW'
23C8            JP   #3137,TO_NEW        routine (128K or 48K).

THE 'PRINT "CHANGE DISC"' SUBROUTINE
This subroutine tests whether source and destination drives are equal. If they
are the
messages "Insert SOURCE disc - press SPACE" and "Insert TARGET disc - press
SPACE" are
printed in turn.

23CB TO_MSG     LD   A,(#3E01)           Fetch source drive.
23CE            LD   B,A
23CF            LD   A,(#3E1A)           Fetch destination drive.
23D2            CP   B
23D3            RET  NZ                  Return if they aren't equal.
23D4            RST  #10,CALBAS          Otherwise clear lower screen area.
23D5            DEFW #0D6E,CLS_LOWER
23D7            SET  5,(IY+2)            Signal 'lower screen has to be
cleared'
23DB            CALL #30B5,TO_MSG1       Print "Input ... disc" message.
23DE            CALL #0B75,BEEP          Give a beep.
23E1 TO_WSPC    LD   A,#7F               Keyboard row B-SPACE address.
23E3            IN   A,(254)
23E5            RRA
23E6            JR   C,#23E1,TO_WSPC     Jump unless the SPACE key is pressed.
23E8            RST  #10,CALBAS          Clear lower screen.
23E9            DEFW #0D6E,CLS_LOWER
23EB            RET                      Finished.

THE 'SEARCH FILES' SUBROUTINE
This subroutine searches for files which have to be copied. It returns with the
Zero
flag set if the current file is to be copied, if the complete directory is
searched the
routine returns with Zero reset.

23EC TO_SEARCH  LD   DE,(#3DED)          Track & sector to DE.
23F0            LD   A,D
23F1            CP   4                   Jump if not reached track 4, i.e.
23F3            JR   NZ,#23F8,TO_SEARCH1 directory hasn't been read completely.
23F5            CP   0                   Reset Zero flag.
23F7            RET

The directory isn't finished yet, so read sector and test the file(s).

23F8 TO_SEARCH1 CALL #05CC,RSAD          Read sector E from track D.
23FB TO_SEARCH2 CALL #2433,TO_COPY       Check if this file is to be copied.
23FE            PUSH AF                  Store result (Zero flag).
23FF            LD   HL,(#3DEB)          Disk buffer offset to HL.
2402            LD   A,H
2403            CP   1
2405            JR   Z,#2418,TO_NXTSEC   Jump if second entry.
2407            LD   A,(#3DDA)           Fetch current control port status.
240A            AND  #04
240C            JR   NZ,#2418,TO_NXTSEC  Jump with single density.
240E            LD   HL,256              Otherwise offset is for second entry.
2411            LD   (#3DEB),HL
2414            POP  AF                  Restore Zero flag.
2415            RET  Z                   Return if this file is to be copied.
2416            JR   #23FB,TO_SEARCH2    Otherwise next file.

The file entries of the current sector have been tested so point to the next
sector.

2418 TO_NXTSEC  LD   HL,0                Offset is for first entry.
241B            LD   DE,(#3DED)          Fetch track and sector.
241F            INC  E                   Next sector.
2420            LD   A,E
2421            CP   11
2423            JR   NZ,#2428,TO_NXT1    Jump if not last sector on this track.
2425            LD   E,1                 Start with sector 1.
2427            INC  D                   Next track.
2428 TO_NXT1    LD   (#3DED),DE          Store track & sector.
242C            LD   (#3DEB),HL          Store disk buffer offset.
242F            POP  AF                  Restore Zero flag.
2430            RET  Z                   Return if previous file is to be
2431            JR   #23F8,TO_SEARCH     copied. Otherwise jump.

THE 'COPY THIS FILE ?' SUBROUTINE
This subroutine checks if the 'current' filename is to be  copied. The routine
returns
with the Zero flag set to signal yes and RPT pointing to the directory
description of the
file to be copied.

2433 TO_COPY    LD   HL,#3BD6            Point to start of sector.
2436            LD   DE,(#3DEB)          Offset to DE.
243A            LD   (IX+14),D           Update RPT (RAM PoinTer (?)).
243D            ADD  HL,DE               Update HL.
243E            LD   A,(HL)              Fetch directory description.
243F            AND  A
2440            JR   NZ,#2444,TO_COPY1   Jump if the file isn't ERASEd.
2442            INC  A                   Reset Zero flag to signal 'do not copy
2443            RET                      this file' and exit.

2444 TO_COPY1   INC  HL                  Step past directory descriptor.
2445            LD   DE,#3E06            DE now points to FILE_NAME1.
2448            LD   B,10                A filename is 10 characters long.
244A TO_COPY2   LD   A,(DE)              Fetch character.
244B            CP   42,"*"              If it was a '*' all other characters
244D            RET  Z                   don't matter. Signal 'copy this one'.
244E            CP   63,"?"              If it was a '?' this character doesn't
2450            JR   Z,#2456,TO_COPY3    matter.
2452            XOR  (HL)
2453            AND  #DF                 Upper and lower case? don't bother.
2455            RET  NZ                  Exit if characters are unequal.
2456 TO_COPY3   INC  DE                  Check next character.
2457            INC  HL
2458            DJNZ #244A,TO_COPY2
245A            RET                      Finished.

THE 'CAT' COMMAND SYNTAX ROUTINE
This routine checks that the command is in the form CAT <#s;>d<<;>n$>
.

245B CAT        LD   IX,#3AC3            Point to the +D workspace.
245F            LD   HL,#3E06            "*" is the default name of the files
2462            LD   (HL),42,"*"         being CATted.
2464            LD   HL,#3E03            Just like #2 is the default output
2467            LD   (HL),2              stream.
2469            RST  #28,NEXT_C          Get next character.
246A            CP   13                  Give an error if an 'end of line' (CR)
246C            JP   Z,#1648,REP_2       is found right after "CAT".
246F            CP   58,":"
2471            JP   Z,#1648,REP_2       Same error for ":".
2474            CP   35,"#"              Jump if no stream specified, use
2476            JR   NZ,#2481,CAT_DRV    default stream #2.
2478            CALL #2AEF,EXPT_#NR      Evaluate stream number.
247B            CALL #25A2,SEPARATOR     Check if there is a separator.
247E            JP   NZ,#1644,REP_0      Give an error if no separator found.
2481 CAT_DRV    CALL #25FA,EXPT_DEVN2    Evaluate drive number.
2484            CALL #25A2,SEPARATOR     Evaluate filename if there is a
2487            CALL Z,#2640,EXPT_FNAME  separator.
248A            CP   33,"!"              If there is no "!" then an extended
248C            JR   NZ,#2499,EXT_CAT    catalogue is given.
248E            RST  #28,NEXT_C          Next character.
248F            CALL #3148,ST_END_RAM    Confirm end of statement and exit when
                                         syntax checking.
2492            CALL #0702,TEST_DRV      See if drive is defined.
2495            LD   A,%00000010         Signal 'small' CAT.
2497            JR   #24A4,DO_CAT1

2499 EXT_CAT    CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax time.
249C            RST  #10,CALBAS          Clear the screen by calling 'main' ROM
249D            DEFW #0DAF,CL_ALL        routine.
249F DO_CAT     CALL #0702,TEST_DRV      See if drive is defined.
24A2            LD   A,%00000100         Signal extended CAT.
24A4 DO_CAT1    CALL #24B5,CAT_RUN       Give the CAT.
24A7            JP   #047C,END           Finished.

THE 'CAT' COMMAND ROUTINE
This routine makes a catalogue of the disk inserted in the specified drive, by
calling
the +D ROM routine 'SCAN_CAT'.

24AA CAT_1      LD   HL,#3E06            Point to name.
24AD            LD   (HL),42,"*"         All files.
24AF            LD   HL,#3E03            Point to stream number.
24B2            LD   A,2                 Make it stream 2.
24B4            LD   (HL),A
24B5 CAT_RUN    PUSH AF
24B6            LD   A,(#3E03)
24B9            RST  #10,CALBAS          Open the desired stream by calling
24BA            DEFW #1601,CHAN_OPEN     'CHAN_OPEN' in the 'main' ROM.
24BC            LD   A,13
24BE            CALL #1799,PRT_A         Printing starts on the next line.
24C1            CALL #304B,MSG_0         Print the 1st part of "DIR"-message.
24C4            LD   A,(#3ACE)           Fetch current drive.
24C7            AND  #03                 Only bits 0&1.
24C9            OR   #30                 Make ASCII "1" or "2".
24CB            CALL #1799,PRT_A         Print drive number.
24CE            CALL #3061,MSG_1         Print the 2nd part of "DIR"-message.
24D1            LD   HL,0                Reset 'total number of sectors'
24D4            LD   (#3DD8),HL          occupied.
24D7            POP  AF                  Restore 'CAT' type.
24D8            CALL #09A5,SCAN_CAT      Print the CAT entries.
24DB            CALL #3072,MSG_2         Print "Free ..." message.
24DE            CALL #0985,DRV_CAP       Get drive capacity in A register.
24E1            PUSH BC
24E2            BIT  7,A
24E4            JR   Z,#24E7,CAT_RUN1    Jump if drive is single sided.
24E6            ADD  A,A                 Otherwise double the number of tracks
                                         and get rid of the side bit.
24E7 CAT_RUN1   SUB  4                   Subtract number of catalogue tracks.
24E9            LD   HL,0
24EC            LD   B,10                Each track has 10 sectors.
24EE            LD   D,0                 Number of tracks to DE.
24F0            LD   E,A
24F1 CAT_RUN2   ADD  HL,DE               Calculate total number of sectors.
24F2            DJNZ #24F1,CAT_RUN2
24F4            POP  BC
24F5            NOP                      New code is two bytes shorter.
24F6            NOP
24F7            LD   DE,(#3DD8)          Get number of used sectors.
24FB            XOR  A                   Clear carry.
24FC            SBC  HL,DE               Calculate number of free sectors.
24FE            SRL  H                   Divide it by two to get number of free
2500            RR   L                   K-bytes.
2502            XOR  A
2503            CALL #174C,PRT_N1000     Print the number.
2506            LD   A,13
2508            CALL #1799,PRT_A         Print a newline.
250B            RET

THE 'ERASE' COMMAND SYNTAX ROUTINE
This routine checks that the command is in the form ERASE *n$ to erase a file
or ERASE
*n1$ TO n2$ to rename a file. The '*' stands for +D syntax ('d'd<;>) or
Microdrive syntax
('"m"';d;).

250C ERASE      RST  #28,NEXT_C          Get next character.
250D            LD   (#3E04),A           Store the device descriptor.
2510            CP   34,"""              Test for Microdrive syntax if it was a
2512            CALL Z,#25C2,MD_SYN1     quote.
2515            CALL #25E2,EXPT_DEVN     Evaluate the drive number.
2518            CALL #25A2,SEPARATOR     Test for a separator.
251B            JP   NZ,#1644,REP_0      Give error if none found.
251E            CALL #2640,EXPT_FNAME    Evaluate filename.
2521            CP   204,"TO"            Is the filename followed by "TO"?
2523            JR   Z,#2561,RENAME      Jump if so, rename is wanted.
2525            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2528            LD   A,(#3E04)           Fetch device descriptor.
252B            AND  #DF                 Drop lower case bit.
252D            CP   68,"D"
252F            JR   Z,#2536,ERASE_RUN   Jump if it was "D".
2531            CP   77,"M"
2533            JP   NZ,#1658,REP_10     Give error if it wasn't "M".

THE 'ERASE A FILE' ROUTINE
This routine deletes the specified file(s) on the specified drive. First it
calls the
routine 'FIND_FILE' to find a matching name, then it marks the file ERASEd by
setting the
directory description to 0, the dir. entry is then SAVEd back to disc.

2536 ERASE_RUN  CALL #0702,TEST_DRV      See if drive is defined.
2539 ERASE_LOOP CALL #2559,FIND_FILE     Find the file.
253C            JR   NZ,#2548,NOT_FOUND  Jump if not found.
253E            LD   (HL),0              Directory description 0 means ERASEd.
2540            CALL #0584,WSAD          Write sector DE.
2543            CALL #15F4,SIGN_0        Signal 'at least one file ERASEd'.
2546            JR   #2539,ERASE_LOOP    ERASE all files with this filename.

2548 NOT_FOUND  CALL #161C,TEST_0        Give an error if there wasn't at least
254B            JP   Z,#1678,REP_26      one file ERASEd.
254E ERASE_EXIT LD   A,(#3E04)
2551            CP   68,"D"              If the device descriptor was a
2553            CALL Z,#24AA,CAT_1       (capital) "D", then give a CATalogue.
2556            JP   #047C,END           Finished.

THE 'FIND A FILE' SUBROUTINE
This routine searches the directory for a matching filename by calling the +D
ROM
routine 'SCAN_CAT', it returns with HL pointing to the directory description of
the
matching file. This routine is also called by command code 65 routine.

2559 FIND_FILE  LD   A,%00010000         Scan the CATalogue for a matching
255B            CALL #09A5,SCAN_CAT      filename.
255E            JP   #0D93,RPT_HL        Make HL point to the start of the dir.
                                         entry buffer and exit.

THE 'RENAME A FILE' ROUTINE
This routine renames a file by replacing its filename, given first, by the
filename
given second. It first tests whether the 'new' name isn't used already. If not,
a check
is made whether the file to be renamed exists.

2561 RENAME     RST  #28,NEXT_C          Get next character.
2562            CALL #25A2,SEPARATOR     Check if there is a separator.
2565            JP   NZ,#1644,REP_0      Give an error if none found.
2568            CALL #2620,EXPT_2FNAM    Evaluate 2nd filename.
256B            CALL #3148,ST_END_RAM    Confirm end of statement and exit when
                                         syntax checking.
256E            LD   A,(#3E04)           Fetch device descriptor.
2571            AND  #DF                 Drop lower case bit.
2573            CP   68,"D"
2575            JR   Z,#257C,RENAME_RUN  Jump if it was a "D".
2577            CP   77,"M"
2579            JP   NZ,#1658,REP_10     Give error if it wasn't a "M".
257C RENAME_RUN CALL #0702,TEST_DRV      See if the drive is defined.
257F            CALL #2626,SWAP_UFIAS    Swap UFIA 1 & 2 in the DFCA.
2582            CALL #2559,FIND_FILE     Give an error if the 2nd filename
2585            JP   Z,#167C,REP_28      already exists.
2588            CALL #2626,SWAP_UFIAS    Swap UFIA 1 & 2 in the DFCA.
258B            CALL #2559,FIND_FILE     Give an error if the 1st filename
258E            JP   NZ,#1678,REP_26     doesn't exist.
2591            INC  HL
2592            PUSH DE
2593            LD   DE,#3E1F            Rename the file by copying the 2nd to
2596            EX   DE,HL               the 1st name.
2597            LD   BC,10
259A            LDIR
259C            POP  DE
259D            CALL #0584,WSAD          Write the CATalogue sector.
25A0            JR   #254E,ERASE_EXIT    Exit via 'ERASE_EXIT'.
 ____________________________
|Previous|Next|Contents|Index|
###### 25a2-syntax.html ######
###### 25a2-syntax.html ######


 ____________________________
|Previous|Next|Contents|Index|
The syntax checking routines

THE 'SEPARATOR' SUBROUTINE
This small subroutine tests whether the current character is a separator or a
quote. It
returns with Zero flag set if it was a ";", "," or a """, with the first two A
holds the
next character.

25A2 SEPARATOR  CP   44,","
25A4            JR   Z,#25AD,SEPAR_1     Jump if current character is a comma.
25A6            CP   59,";"
25A8            JR   Z,#25AD,SEPAR_1     Jump if it is a semicolon.
25AA            CP   34,"""
25AC            RET                      Return with Zero set if it's a quote.
25AD SEPAR_1    RST  #28,NEXT_C          Get next character.
25AE            LD   (#3DEA),A
25B1            XOR  A                   Set Zero flag.
25B2            LD   A,(#3DEA)
25B5            RET

THE 'EVALUATE STRING EXPR.' SUBROUTINE
A call is made to the 'main' ROM 'EXPT_EXP' (class-0A) subroutine, to evaluate
a string
expression. During runtime, the parameters of the string (start and length) are
returned
in the DE and BC register pairs.

25B6 EXPT_STR   RST  #10,CALBAS          Evaluate the string expression.
25B7            DEFW #1C8C,EXPT_EXP
25B9            RST  #30,SYNTAX_Z
25BA            RET  Z                   Return if syntax is being checked.
25BB            PUSH AF                  Save the character following the
string
25BC            RST  #10,CALBAS          and the zero flag.
25BD            DEFW #2BF1,STK_FETCH     Fetch the string parameters.
25BF            POP  AF
25C0            RET

THE 'EVAL. MICRODRIVE SYNTAX' SUBROUTINE
This subroutine is entered at 'MD_SYNTAX' or 'MD_SYNTAX1' depending upon
whether or not
the character pointer is to be updated to the next character. A single
character string
is evaluated, and its ASCII value is stored during runtime. If a separator
isn't present
after the single character string, an error is given.

25C1 MD_SYNTAX  RST  #28,NEXT_C          Next character.
25C2 MD_SYN1    CALL #25B6,EXPT_STR
25C5            JR   Z,#25D9,MD_SYN2     Jump if syntax is being checked.
25C7            PUSH AF                  Save the character following the
25C8            LD   A,C                 string. A holds string length low
byte.
25C9            DEC  A
25CA            OR   B                   Give an error if there isn't exactly
25CB            JP   NZ,#1658,REP_10     one character in the string.
25CE            LD   A,(DE)              Fetch the channel specifier.
25CF            RST  #10,CALBAS          Call 'ALPHA' to see if it's a valid
25D0            DEFW #2C8D,ALPHA         letter.
25D2            JP   NC,#1658,REP_10     Give error if not a valid letter.
25D5            LD   (#3E04),A           Store the specifier in the UFIA.
25D8            POP  AF                  Restore next character.
25D9 MD_SYN2    CP   59,";"
25DB            RET  Z                   Return if it's a semicolon.
25DC            CP   44,","
25DE            RET  Z                   Return if it's a comma.
25DF            JP   #1644,REP_0         Otherwise give error.

THE 'EVALUATE DEVICE NUMBER' SUBROUTINE
This subroutine is used to evaluate the device number.

25E2 EXPT_DEVN  AND  #DF                 Make upper case.
25E4            CP   80,"P"
25E6            JR   NZ,#25F9,EXPT_DEVN1 Jump if the device wasn't "P".
25E8            RST  #28,NEXT_C          Next character.
25E9            CALL #2611,EXPT_NUM      Get the program number.
25EC            RET  Z                   Return if syntax checking.
25ED            PUSH AF
25EE            LD   A,(#3E01)           Store program number.
25F1            LD   (#3E02),A
25F4            CALL #2604,LAST_DRV      Drive is last drive.
25F7            POP  AF
25F8            RET

Now a check is made whether the last used device is wanted.

25F9 EXPT_DEVN1 RST  #28,NEXT_C          Get next character.
25FA EXPT_DEVN2 CP   42,"*"
25FC            JR   NZ,EXPT_NUM         Jump if it wasn't a "*".
25FE            RST  #30,SYNTAX_Z
25FF            CALL NZ,#2604,LAST_DRV   Store last drive number during
runtime.
2602            RST  #28,NEXT_C          Next character.
2603            RET

THE 'SET LAST DRIVE' SUBROUTINE
This subroutine is used whenever the last used drive is to be used again.

2604 LAST_DRV   LD   A,(#3DDA)           Fetch current control port status.
2607            AND  #01                 Keep only drive select.
2609            ADD  A,#01               A holds 1 for drive 2, 2 for drive 1.
260B            XOR  #03                 1 becomes 2, 2 becomes 1.
260D            LD   (#3E01),A           Store drive number.
2610            RET

THE 'EVALUATE NUMERIC EXPR.' SUBROUTINE
This subroutine is used to evaluate a single numeric expression. The result is
returned
during runtime into the BC register pair and into UFIA1.

2611 EXPT_NUM   RST  #10,CALBAS          Evaluate the expression by calling
2612            DEFW #1C82,EXPT_1NUM     'EXPT_1NUM' in the 'main' ROM.
2614            RST  #30,SYNTAX_Z
2615            RET  Z                   Return if syntax is being checked.
2616            PUSH AF
2617            RST  #10,CALBAS          Fetch the value from the calculator
2618            DEFW #1E99,FIND_INT2     stack.
261A            LD   A,C
261B            LD   (#3E01),A           Store it in UFIA1.
261E            POP  AF
261F            RET

THE 'EVALUATE 2ND FILENAME' SUBROUTINE
This routine evaluates the second filename of a BASIC command. Because
'EXP_F_NAME'
stores the filename in UFIA1, both UFIAS are swapped first,
then 'EXP_F_NAME' is called and an exit is made via 'SWAP_UFIAS' to get the
UFIA's in
the right place again.

2620 EXPT_2FNAM CALL #2626,SWAP_UFIAS    Swap UFIA1 and 2.
2623            CALL #2640,EXPT_FNAME    Evaluate filename.
                                         Exit via 'SWAP_UFIAS'.
THE 'SWAP UFIAS' SUBROUTINE
This subroutine swaps the contents of UFIA1 and UFIA2 in DFCA.

2626 SWAP_UFIAS PUSH AF
2627            PUSH BC
2628            PUSH DE
2629            PUSH HL
262A            LD   B,24                An UFIA is 24 bytes long.
262C            LD   DE,#3E01            Start of UFIA1.
262F            LD   HL,#3E1A            Start of UFIA2.
2632 SWAP_LOOP  LD   A,(DE)              Exchange the contents.
2633            LD   C,(HL)
2634            EX   DE,HL
2635            LD   (DE),A
2636            LD   (HL),C
2637            INC  DE
2638            INC  HL
2639            DJNZ #2632,SWAP_LOOP     Repeat for all 24 bytes.
263B            POP  HL
263C            POP  DE
263D            POP  BC
263E            POP  AF
263F            RET

THE 'EVALUATE A FILENAME' SUBROUTINE
A string expression is evaluated and, provided that the length is within the
range 1..10
characters, is stored in UFIA1.

2640 EXPT_FNAME CALL #25B6,EXPT_STR      Evaluate the string.
2643            RET  Z                   Return if checking syntax.
2644            PUSH AF
2645            LD   A,C
2646            OR   B
2647            JP   Z,#1654,REP_8       Give error with null string.
264A            LD   HL,10
264D            SBC  HL,BC
264F            JP   C,#1654,REP_8       Give error with string length > 10.
2652            LD   HL,#3E05            Clear the filename and the directory
2655            LD   A,11                description of UFIA1.
2657 CLR_FNAME  LD   (HL),32
2659            INC  HL
265A            DEC  A
265B            JR   NZ,#2657,CLR_FNAME  Repeat for all 11 bytes.
265D            LD   HL,#3E06            Copy the filename into UFIA1.
2660            EX   DE,HL
2661            LDIR
2663            POP  AF
2664            RET

THE 'EVALUATE PARAMETERS' SUBROUTINE
This very important subroutine is called to evaluate the syntax of the +D
'SAVE',
'LOAD', 'MERGE' and 'VERIFY' commands. The routine is entered with CH_ADD
pointing to the
command; on exit during runtime UFIA1 is filled with the proper values.

2665 EXPT_PARMS RST  #28,NEXT_C          Get next character from BASIC line.
2666            CP   32," "              Give an error with character codes
2668            JP   C,#1644,REP_0       below 32, i.e. colour codes, etc.
266B            CP   170,"SCREEN$"
266D            JP   Z,#301D,DUMP_SCR$   Jump with 'SCREEN$'.
2670            LD   (#3E04),A           Otherwise store it in DEV_TYPE1.
2673            CP   64,"@"
2675            JR   NZ,#26AE,NOT_@      Jump if not a '@'.

Now deal with @.

2677            CALL #25E2,EXPT_DEVN     Evaluate drive number.
267A            CALL #25A2,SEPARATOR
267D            JP   NZ,#1648,REP_2      Give error if no separator was found.
2680            RST  #10,CALBAS          Call 'EXPT_1NUM' to evaluate the track
2681            DEFW #1C82,EXPT_1NUM     number.
2683            CALL #25A2,SEPARATOR     Test for another separator and give an
2686            JP   NZ,#1648,REP_2      error if none found.
2689            RST  #10,CALBAS          Evaluate sector number.
268A            DEFW #1C82,EXPT_1NUM
268C            CALL #25A2,SEPARATOR     Again a separator has to be found.
268F            JP   NZ,#1648,REP_2
2692            RST  #10,CALBAS          Evaluate address.
2693            DEFW #1C82,EXPT_1NUM
2695            CALL #3148,ST_END_RAM    Confirm end of statement, and exit
                                         during syntax checking.
2698            RST  #10,CALBAS          Fetch the address from the calculator
2699            DEFW #1E99,FIND_INT2     stack.
269B            LD   (#3E15),BC          Store it in LENGTH1_2
269F            RST  #10,CALBAS          Fetch sector.
26A0            DEFW #1E99,FIND_INT2
26A2            LD   (#3E13),BC          Store it in FILE_ADDR1
26A6            RST  #10,CALBAS          Fetch track.
26A7            DEFW #1E99,_FIND_INT2
26A9            LD   (#3E11),BC          Store it in LENGTH1_1
26AD            RET                      Exit.

26AE NOT_@      CP   42,"*"              Call 'MD_SYNTAX' if it was a "*".
26B0            CALL Z,#25C1,MD_SYNTAX
26B3            CALL #25E2,EXPT_DEVN     Fetch device or program number.
26B6            CALL #25A2,SEPARATOR     Test for a separator.
26B9            PUSH AF
26BA            RST  #30,SYNTAX_Z
26BB            JR   Z,#26D6,FILENAME    Jump if syntax checking.
26BD            LD   A,(#3E04)           Fetch device descriptor.
26C0            AND  #DF                 Only capitals.
26C2            CP   68,"D"
26C4            JR   Z,#26D1,NOT_@1      Jump if device is disk.
26C6            CP   77,"M"
26C8            JR   Z,#26D1,NOT_@1      Or disk with Microdrive syntax.
26CA            CP   80,"P"
26CC            JR   Z,#26DB,PARAMS      Jump with program.
26CE            JP   NZ,#1658,REP_10     Give error with unknown device.
26D1 NOT_@1     POP  AF                  Give error if no separator or quote
26D2            JP   NZ,#1644,REP_0      found with devices "D" and "M".
26D5            PUSH AF                  Balance 'POP AF' below.
26D6 FILENAME   POP  AF
26D7            CALL Z,#2640,EXPT_FNAME  Evaluate filename if necessary.
26DA            PUSH AF                  Balance next instruction.
26DB PARAMS     POP  AF
26DC            CP   13
26DE            JP   Z,#276F,NO_PARAMS   Jump with ENTER.
26E1            CP   58,":"
26E3            JP   Z,#276F,NO_PARAMS   Jump with colon.
26E6            CP   204,"TO"
26E8            JP   Z,#2308,TO          Jump with 'TO'.
26EB            CP   170,"SCREEN$"
26ED            JP   Z,#27A5,SCREEN$     Jump with 'SCREEN$'.
26F0            CP   175,"CODE"
26F2            JP   Z,#27C0,CODE        Jump with 'CODE'.
26F5            CP   228,"DATA"
26F7            JP   Z,#281A,DATA        Jump with 'DATA'.
26FA            CP   202,"LINE"
26FC            JP   Z,#275F,LINE        Jump with 'LINE'.
26FF            AND  #DF                 Only capitals.
2701            CP   83,"S"
2703            JR   NZ,#270F,NOT_S      Jump with other than 'S'.
2705            RST  #28,NEXT_C          Next character.
2706            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2709            LD   A,5                 Signal '48K Snapshot'.
270B            LD   (#3E05),A
270E            RET                      Finished.

270F NOT_S      CP   75,"K"
2711            JR   NZ,#271D,NOT_K      Jump with other than 'K'.
2713            RST  #28,NEXT_C          Next character.
2714            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2717            LD   A,9                 Signal '128K Snapshot'.
2719            LD   (#3E05),A
271C            RET                      Finished.

271D NOT_K      CP   88,"X"
271F            JP   NZ,#1644,REP_0      Give error with other than 'X'.
2722            RST  #28,NEXT_C          Next character.
2723            CALL #25A2,SEPARATOR     Jump if a separator found, there is
2726            JR   Z,#2736,XFILE_1     more.
2728            CALL #1635,TEST_5        There must follow a address if
SAVEing.
272B            JP   NZ,#1648,REP_2      Give error if SAVEing.
272E            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2731            LD   BC,#3BD6            Load address of execute file.
2734            JR   #273F,XFILE_2       Jump forward.

A separator has been found, so there should follow an address.

2736 XFILE_1    RST  #10,CALBAS          Evaluate address.
2737            DEFW #1C82,EXPT_1NUM
2739            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
273C            RST  #10,CALBAS          Fetch the address.
273D            DEFW #1E99,FIND_INT2
273F XFILE_2    LD   (#3E13),BC          Store it in FILE_ADDR1
2743            LD   BC,510              Length of execute file on double
2746            LD   A,(#3DDA)           density disks.
2749            AND  #04
274B            JR   Z,#2750,XFILE_3     Jump if double density selected.
274D            LD   BC,254              Otherwise this is the length of the
                                         execute file.
2750 XFILE_3    LD   (#3E11),BC          Store length in LENGTH1_1.
2754            LD   A,3                 File type is 'CODE'.
2756            LD   (#3E10),A           Store it in FILE_TYPE1.
2759            LD   A,11                Signal 'Execute file'.
275B            LD   (#3E05),A           Store in DIR_DESCR1
275E            RET                      Finished.

Now deal with LINE. The +D allows LOAD, VERIFY and MERGE .. LINE to be entered
as a
command but the LINE is completely ignored.

275F LINE       RST  #28,NEXT_C          Advance CH_ADD.
2760            RST  #10,CALBAS          Evaluate autostart line number by
2761            DEFW #1C82,EXPT_1NUM     calling 'EXPT_1NUM' in the 'main' ROM.
2763            CALL #3148,ST_END_RAM    Confirm end of statement, and exit
                                         during syntax checking.
2766            RST  #10,CALBAS          Fetch the autostart line number.
2767            DEFW #1E99,FIND_INT2
2769            LD   (#3E17),BC          Store it in AUTOSTART1.
276D            JR   #2772,PROG

If there are no parameters, as with a BASIC program, the syntax checking ends
here.

276F NO_PARAMS  CALL #3148,ST_END_RAM    Confirm end of statement, exit when
                                         syntax checking.
2772 PROG       LD   A,(#3E04)
2775            AND  #DF                 Only capitals.
2777            CP   80,"P"              Jump if the device wasn't "P", i.e. no
2779            JR   NZ,#2782,PROG_1     program number was specified.
277B            CALL #1635,TEST_5        'SAVE pn' is not supported, so give an
277E            RET  Z                   error if saving, otherwise return.
277F            JP   #1644,REP_0

2782 PROG_1     XOR  A                   File type is 'BASIC'.
2783            LD   (#3E10),A
2786            LD   A,1                 Signal 'BASIC file'.
2788            LD   (#3E05),A
278B            LD   HL,(23641)          Fetch (E_LINE), the first location
past
                                         the variables area.
278E            LD   DE,(23635)          Fetch (PROG), the 'start' of the BASIC
2792            LD   (#3E13),DE          program and store it in FILE_ADDR1
2796            SCF                      Calculate ((E_LINE)-(PROG)-1), i.e.
the
2797            SBC  HL,DE               length of the program and its
2799            LD   (#3E11),HL          variables. Store it in LENGTH1_1.
279C            LD   HL,(23627)          Fetch (VARS) and calculate
279F            SBC  HL,DE               (VARS)-(PROG), i.e. the length of the
                                         program without its variables.
27A1            LD   (#3E15),HL          Store it into LENGTH1_2.
27A4            RET                      Finished.

If the token is SCREEN$, the parameters are entered directly into the file
header.

27A5 SCREEN$    RST  #28,NEXT_C          Get the next character.
27A6            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
27A9            LD   HL,6912             The size of the display file is stored
27AC            LD   (#3E11),HL          into LENGTH1_1.
27AF            LD   HL,16384            The startaddress is stored into
27B2            LD   (#3E13),HL          FILE_ADDR1
27B5            LD   A,3                 File type is 'CODE'.
27B7            LD   (#3E10),A
27BA            LD   A,7                 Signal 'SCREEN$'.
27BC            LD   (#3E05),A
27BF            RET

Now deal with CODE, three parameters are needed: "start", "length" and "execute
address". With LOAD there may be none, one, two or three parameters, but with
SAVE at
least two parameters must be present.

27C0 CODE       RST  #28,NEXT_C          Update CH_ADD.
27C1            CP   13                  If there are no further parameters,
27C3            JR   Z,#27C9,CODE_1      jump to use '0' as default value.
27C5            CP   58,":"              Jump if there are parameters to be
27C7            JR   NZ,#27D4,CODE_2     evaluated (i.e. the next character is
                                         not a colon).
27C9 CODE_1     CALL #1635,TEST_5        'SAVE .. CODE' has to be followed by
at
27CC            JP   NZ,#1648,REP_2      least two numbers, so give an error if
                                         none present.
27CF            RST  #10,CALBAS          A call to the 'main' ROM routine
27D0            DEFW #1CE6,USE_ZERO      'USE_ZERO' is made to use a value of
27D2            JR   #27DC,CODE_3        zero as default.

It's likely that an address follows.

27D4 CODE_2     RST  #10,CALBAS          Use the 'main' ROM routine to evaluate
27D5            DEFW #1C82,EXPT_1NUM     the first parameter.
27D7            CALL #25A2,SEPARATOR
27DA            JR   Z,#27E7,CODE_4      Jump if a separator is present.
27DC CODE_3     CALL #1635,TEST_5        Give an error if there isn't a second
27DF            JP   NZ,#1648,REP_2      number with 'SAVE .. CODE'.
27E2            RST  #10,CALBAS          Otherwise use zero as default.
27E3            DEFW #1CE6,USE_ZERO
27E5            JR   #27EF,CODE_5

The length seems to be present also.

27E7 CODE_4     RST  #10,CALBAS          Evaluate the second parameter.
27E8            DEFW #1C82,EXPT_1NUM
27EA            CALL #25A2,SEPARATOR     Jump if a second separator is found.
27ED            JR   Z,#27F4,CODE_6
27EF CODE_5     RST  #10,CALBAS          Otherwise zero is default.
27F0            DEFW #1CE6,USE_ZERO
27F2            JR   #27F7,CODE_7

There's even an execute address.

27F4 CODE_6     RST  #10,CALBAS          Evaluate the third parameter.
27F5            DEFW #1C82,EXPT_1NUM
27F7 CODE_7     CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
27FA            RST  #10,CALBAS          Fetch the "autoexecute" address from
27FB            DEFW #1E99,FIND_INT2     the calculator stack and store it into
27FD            LD   (#3E17),BC          AUTOSTART1
2801            RST  #10,CALBAS          Fetch the "length".
2802            DEFW #1E99,FIND_INT2
2804            LD   (#3E11),BC          Store it into LENGTH1_1
2808            RST  #10,CALBAS          Fetch the "start".
2809            DEFW #1E99,FIND_INT2
280B            LD   (#3E13),BC          Store it into FILE_ADDR1
280E            LD   A,3                 File type is 'CODE'.
2811            LD   (#3E10),A
2814            LD   A,4                 Signal 'CODE file'.
2816            LD   (#3E05),A
2819            RET                      Finished.

Finally the routine to evaluate DATA parameters.

281A DATA       CALL #163A,TEST_6        Give an error if attempting to MERGE
an
281D            JP   NZ,#1660,REP_14     array.
2820            RST  #28,NEXT_C          Next character.
2821            RST  #10,CALBAS          Call LOOK_VARS to look for the array
2822            DEFW #28B2,LOOK_VARS     name.
2824            SET  7,C
2826            JR   NC,#2833,DATA_1     Jump if handling an existing array or
                                         if syntax checking.
2828            LD   HL,#0000            Signal 'using a new array'.
282B            CALL #1630,TEST_4
282E            JR   NZ,#284E,DATA_3     Jump if LOADing the array.
2830            JP   #165A,REP_11        Otherwise give error 'Variable not
                                         found'.
2833 DATA_1     JP   NZ,#1644,REP_0      Give error if not an array variable.

NOTE: This test fails to exclude simple strings, but the 'bug' (present in the
'main'
ROM) is corrected at #283E.

2836            RST  #30,SYNTAX_Z
2837            JR   Z,#2860,DATA_5      Jump if syntax is being checked.
2839            CALL #1635,TEST_5
283C            JR   Z,#2843,DATA_2      Jump if LOADing.
283E            BIT  7,(HL)              Give an error if trying to SAVE a
2840            JP   Z,#1644,REP_0       simple string.
2843 DATA_2     INC  HL                  Point to the 'length' of the array.
2844            LD   A,(HL)              Store the length into LENGTH1_1.
2845            LD   (#3E11),A
2848            INC  HL
2849            LD   A,(HL)
284A            LD   (#3E12),A
284D            INC  HL                  Advance to the start of the array.
284E DATA_3     LD   A,C                 Store array name into LSB of
LENGTH1_2.
284F            LD   (#3E15),A
2852            LD   A,1                 File type is 'NUM ARRAY'.
2854            BIT  6,C
2856            JR   Z,#2859,DATA_4      Jump if really a numeric array.
2858            INC  A                   File type is 'STR ARRAY'.
2859 DATA_4     LD   (#3E10),A           Store file type into FILE_TYPE1.
285C            INC  A                   Signal: (A=2) 'Numeric array',
285D            LD   (#3E05),A           (A=3) 'String array'.
2860 DATA_5     EX   DE,HL               DE holds 'start' of the array (or
#0000
                                         with a 'new' array to be LOADed).
2861            RST  #28,NEXT_C          Next character.
2862            CP   41,")"              Check that the ')' does exist.
2864            JP   NZ,#1648,REP_2      Report an error if not.
2867            RST  #28,NEXT_C          Next character.
2868            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
286B            LD   (#3E13),DE          Store "start" of the array into
286F            RET                      FILE_ADDR1 and exit.
 ____________________________
|Previous|Next|Contents|Index|
###### 2870-basic2.html ######
###### 2870-basic2.html ######


 ____________________________
|Previous|Next|Contents|Index|
The BASIC command execution routines II

THE 'GET TRACK AND SECTOR' SUBROUTINE
This routine loads DE with track and sector number from the file header, where
they were
stored by the 'EXPT_PARMS' subroutine. Used with LOAD/SAVE @.

2870 GET_TR&SE  LD   A,(#3E11)           Get track from LSB of LENGTH1_1.
2873            LD   D,A
2874            LD   A,(#3E13)           Get sector from LSB of FILE_ADDR1.
2877            LD   E,A
2878            RET

THE 'SAVE HEADER 1' SUBROUTINE
This subroutine SAVEs the 9 bytes header from UFIA 1 to the file and to the
catalogue
entry which is build up in the DFCA.

2879 SAVE_HEAD1 LD   HL,#3E10            Start of header 1.
287C            LD   DE,#3BA9            Address of header area of a catalogue
                                         entry
287F            LD   B,9                 The headers length.
2881 SAVE_H11   LD   A,(HL)
2882            LD   (DE),A
2883            CALL #0761,SBYT          Save the byte to the file.
2886            INC  HL
2887            INC  DE
2888            DJNZ #2881,SAVE_H11      Repeat for all nine bytes.
288A            RET                      Finished.

THE 'SAVE' COMMAND SYNTAX ROUTINE
This routine checks that the SAVE command has the appropriate syntax.

288B SAVE       LD   IX,#3AC3            Pointer to the DFCA.
288F            CALL #160D,SIGN_5        Signal 'SAVEing'.
2892            CALL #2665,EXPT_PARMS    Evaluate & store all parameters.
2895            CALL #0702,TEST_DRV      See if the drive is defined.
2898            LD   A,(#3E04)
289B            CP   64,"@"
289D            JR   NZ,#28AF,SAVE_RUN   Jump if the command wasn't 'SAVE @'.
289F            LD   IX,(#3E15)          Get address where sector is to be
saved
28A3            CALL #2870,GET_TR&SE     from. Get track and sector number.
28A6            LD   A,(#3E01)           Get drive number.
28A9            CALL #2FF2,HWSAD         Write the sector.
28AC            JP   #047C,END           Finished.

THE 'SAVE A FILE' ROUTINE
This routine SAVEs the specified file on the specified drive.

28AF SAVE_RUN   CALL #0AD9,OFSM_2        Open the file for 'SAVE'.
28B2            JP   NZ,#254E,ERASE_EXIT Exit if the file isn't to be
                                         overwritten.
28B5            LD   A,(#3E05)
28B8            CP   11                  Pass the header to the file unless
it's
28BA            CALL NZ,#2879,SAVE_HEAD1 an 'execute' file.
28BD            LD   HL,(#3E13)          Fetch the start address.
28C0            LD   DE,(#3E11)          Fetch the length.
28C4            CALL #0850,HSVBK_2       Save the block.
28C7            CALL #0B89,CFSM          Close the file.
28CA            JP   #254E,ERASE_EXIT    Exit via 'ERASE_EXIT'.

THE 'LOAD HEADER INTO UFIA 2' SUBROUTINE
This subroutine LOADs a 9 bytes header into UFIA 2.

28CD LOAD_HEAD2 LD   HL,#3E29            Start of HEADER 2.
28D0            LD   B,9                 Length of a header.
28D2 LOAD_H21   CALL #077F,LBYT          Load a byte.
28D5            LD   (HL),A              Store it into UFIA 2.
28D6            INC  HL
28D7            DJNZ #28D2,LOAD_H21      Repeat for all header bytes.
28D9            RET

THE 'LOAD' COMMAND SYNTAX ROUTINE
The 'LOAD' flag is set and the routine continues into the 'LOAD_VERIFY_MERGE'
routine
below.

28DA LOAD       CALL #1608,SIGN_4        Signal 'LOADing'.
28DD            JR   #28E7,LD_VF_MR

THE 'VERIFY' COMMAND SYNTAX ROUTINE
The 'VERIFY' flag is set and again the 'LOAD_VERIFY_MERGE' routine handles the
rest.

28DF VERIFY     CALL #1617,SIGN_7        Signal 'VERIFYing'.
28E2            JR   #28E7,LD_VF_MR

THE 'MERGE' COMMAND SYNTAX ROUTINE
The 'MERGE' flag is set and 'LOAD_VERIFY_MERGE' continues the syntax checking.

28E4 MERGE      CALL #1612,SIGN_6        Signal 'MERGEing'.

THE 'LOAD_VERIFY_MERGE' COMMAND ROUTINE
This routine checks the syntax of the LOAD, VERIFY and MERGE commands and
executes it.

28E7 LD_VF_MR   LD   IX,#3AC3            Pointer to DFCA.
28EB            CALL #2665,EXPT_PARMS    Evaluate & store all parameters.
28EE LD_VF_MR1  CALL #0702,TEST_DRV      See if the drive is defined.
28F1            LD   A,(#3E04)
28F4            CP   64,"@"
28F6            JR   NZ,#2908,LD_ETC_RUN Jump if it wasn't a '@' command.
28F8            LD   IX,(#3E15)          Get address where sector is to be
28FC            CALL #2870,GET_TR&SE     loaded. Get track and sector number.
28FF            LD   A,(#3E01)           Get drive number.
2902            CALL #2FD4,HRSAD         Load the sector.
2905            JP   #047C,END           Finished.

The routine continues here when a file is to be LOADed from disk.

2908 LD_ETC_RUN CALL #0BCF,HGFLE_2       Open the file for loading.
290B            LD   A,(#3E05)
290E            CP   5
2910            JR   NZ,#2921,LD_ETC_R1  Jump if it isn't a 'Snapshot 48K'.
2912            LD   SP,#3FEA            Use internal stack.
2915            LD   HL,16384            Start address and length of a 48K
Snap.
2918            LD   DE,49152
291B            CALL #079E,LOAD_FILE     Load the file.
 291E            JP   #00B1,SNAP_EXIT     Exit via 'SNAP_EXIT'.

2921 LD_ETC_R1  CP   9
2923            JR   NZ,#294A,LD_ETC_R3  Jump if it isn't a 'Snapshot 128K'.
2925            LD   SP,#3FEA            Use internal stack.
2928            CALL #077F,LBYT          Get the page configuration byte.
292B            PUSH AF
292C            AND  #F8                 Keep the RAM page bits only.
292E            LD   B,#08               LOAD the eight RAM-pages.
2930 LD_ETC_R2  PUSH AF
2931            PUSH BC
2932            CALL #223F,RAMPAGE_A     Page in RAM bank.
2935            LD   HL,49152            Start address and length of each RAM
2938            LD   DE,16384            bank.
293B            CALL #079E,LOAD_FILE     'LOAD DE bytes to HL'.
293E            POP  BC
293F            POP  AF
2940            INC  A                   Next RAM bank.
2941            DJNZ #2930,LD_ETC_R2     Repeat for each RAM bank.
2943            POP  AF                  Retrieve page configuration.
2944            CALL #223F,RAMPAGE_A     Page in the right RAM, ROM and SCR$
2947            JP   #00B1,SNAP_EXIT     bank, exit via 'SNAP_EXIT'.

294A LD_ETC_R3  CP   11
294C            JR   NZ,#2954,LD_ETC_R4  Jump if it isn't a 'Execute' file.
294E            CALL #3BD6               Execute (this is the address of the
2951            JP   #047C,END           disk buffer). Finished.

2954 LD_ETC_R4  CALL #28CD,LOAD_HEAD2    Load the header into UFIA2.
2957            LD   A,(#3E10)           Fetch type of program to be LOADed.
295A            LD   B,A
295B            LD   A,(#3E29)           Fetch type of program found.
295E            CP   B
295F            JP   NZ,#1654,REP_8      Give an error if they aren't equal.

NOTE: The error 'Invalid FILE NAME' is given, maybe MGT have made a typing
error. 'Wrong
FILE type' is the right message.

2962            CP   3
2964            JR   Z,#2974,LD_ETC_R5   Jump if it's a 'CODE' file.
2966            JP   NC,#1654,REP_8      Give error if file type >= 4.
2969            CALL #163A,TEST_6
296C            JR   NZ,#29DF,MERGE_CTRL Jump if 'MERGEing'.
296E            CALL #163F,TEST_7        Jump if not 'VERIFYing' (i.e. doing a
2971            JP   Z,#29FB,LOAD_CTRL   LOAD).

Now deal with loading of all files with type 3, like 'CODE' and 'SCREEN$', or
verifying
of all file types.

2974 LD_ETC_R5  CALL #163A,TEST_6
2977            JP   NZ,#1660,REP_14     Give error if 'MERGE .. CODE' was
used.
297A            LD   HL,(#3E11)          Fetch length of requested file.
297D            LD   DE,(#3E2A)          Fetch length of file found.
2981            LD   A,H
2982            OR   L
2983            JR   Z,#2992,LD_ETC_R6   Jump if length unspecified.
2985            SBC  HL,DE               Jump if file to be LOADed is shorter
2987            JR   NC,#2992,LD_ETC_R6  than or of equal length as the
                                         requested file.
2989            CALL #1630,TEST_4
298C            JP   Z,#165C,REP_12      'VERIFY failed' if not LOADing.
298F            JP   #1662,REP_15        'CODE error' otherwise.

2992 LD_ETC_R6  LD   HL,(#3E13)          Fetch start address from FILE_ADDR1
2995            LD   A,H
2996            OR   L
2997            JR   NZ,#299C,LD_ETC_R7  Jump if a start address was specified.
2999            LD   HL,(#3E2C)          Otherwise use the start address of the
                                         found file.
299C LD_ETC_R7  LD   A,(#3E29)           But if the file is a BASIC program the
299F            AND  A                   start address is held in (PROG).
29A0            JR   NZ,#29A5,LD_ETC_R8
29A2            LD   HL,(23635)          Fetch 'start' from (PROG).
29A5 LD_ETC_R8  CALL #2A9A,LV_ANY        Load the file.
29A8            CALL #163F,TEST_7
29AB            JP   NZ,#047C,END        Exit when 'VERIFYing'.
29AE            LD   HL,(#3E17)          Fetch execute address.
29B1            CALL #29BD,EXEC_CODE     Use it if it was specified.
29B4            LD   HL,(#3E30)          Otherwise use the files execute
29B7            CALL #29BD,EXEC_CODE     address.
29BA            JP   #047C,END           But if it hasn't one either, exit
here.

THE 'EXECUTE CODE FILE' SUBROUTINE
This routine jumps to the address in the HL register pair (if it is valid)
after pushing
the addresses of 'STMT_R_1' and 'STACK_BC'.

29BD EXEC_CODE  LD   A,H
29BE            OR   L
29BF            RET  Z                   Return if the execute address is zero.
29C0            LD   A,H
29C1            CP   #FF
29C3            JR   NZ,#29C9,EXEC_C1
29C5            LD   A,L                 Also return when the execute address
is
29C6            CP   #FF                 #FFFF.
29C8            RET  Z
29C9 EXEC_C1    LD   SP,(23613)          Clear the stack. (ERR_SP)
29CD            LD   (IY+0),#FF          Clear the error.
29D1            CALL #168E,BORD_REST     Restore the border colour.
29D4            LD   BC,#1B7D,STMT_R_1   Return to 'STMT_R_1' in the 'main' ROM
29D7            PUSH BC                  when finished.
29D8            LD   BC,#2D2B,STACK_BC   Return to 'STMT_R_1' via 'STACK_BC'
29DB            PUSH BC                  also in the 'main' ROM.
29DC            JP   #004F,UNPAGE_HL     Jump to the execute address while
                                         unpaging the +D.

THE 'MERGE CONTROL' ROUTINE This routine handles the MERGEing of a (BASIC)
file. No test is made if the file is an array when using the MERGE 'p'n syntax
(see NOTE at 'LOAD CONTROL').

29DF MERGE_CTRL LD   BC,(#3E2A)          Fetch the length of the program to be
29E3            PUSH BC                  MERGEd.
29E4            INC  BC                  Extra location for the 'end marker'.
29E5            RST  #10,CALBAS          Call 'BC_SPACES' in the 'main' ROM to
29E6            DEFW #0030,BC_SPACES     make the required room in workspace.
29E8            LD   (HL),128            Mark the end.
29EA            EX   DE,HL               Move start pointer to HL.
29EB            POP  DE                  Length to DE.
29EC            PUSH HL
29ED            CALL #2A9A,LV_ANY        Load the file.
29F0            POP  HL                  Fetch 'start' of new program.
29F1            LD   DE,(23635)          Fetch 'start' of old program (PROG).
29F5            RST  #10,CALBAS          Do the MERGEing by calling the 'main'
29F6            DEFW #08D2,ME_NEW_LP     ROM 'MERGE' routine.
29F8            JP   #047C,END           Finished.

THE 'LOAD CONTROL' ROUTINE
This routine handles the LOADing of a BASIC program or an array.
NOTE: The Spectrum will crash when trying to LOAD or MERGE 'p' an array. The
problem
starts in the 'HGFLE_2' ('OPEN A FILE FOR LOAD') subroutine in ROM (#0BCF)
which is called from
the 'LD_ETC_RUN' routine at #2908. Normally UFIA1 holds the parameters of the
existing array (if
present), and UFIA2 holds the parameters of the array to be loaded. But when
the 'p' syntax is
used, the 'HGFLE_2' routine makes the contents of UFIA1 equal to UFIA2. The
reclaiming at
address #2A32 then fails, trying to reclaim something which isn't there.

29FB LOAD_CTRL  LD   DE,(#3E2A)          Fetch 'new' length.
29FF            LD   HL,(#3E13)          Fetch 'old' start (=0 when loading a
2A02            PUSH HL                  'new' array').
2A03            LD   A,H
2A04            OR   L
2A05            JR   NZ,#2A0D,LOAD_C1    Jump if not a 'new' array.
2A07            INC  DE                  Increment 'length' by 3, i.e. allows
2A08            INC  DE                  for the insertion of array name and
2A09            INC  DE                  two-byte length.
2A0A            EX   DE,HL               Move 'length' to HL.
2A0B            JR   #2A16,LOAD_C2       Jump forward.

The array to be loaded replaces an existing array.

2A0D LOAD_C1    LD   HL,(#3E11)          Fetch 'old' length (i.e. length of
                                         existing program or array) from UFIA1.
2A10            EX   DE,HL               Move 'new' length to HL.
2A11            SCF                      Jump if the program or array to be
2A12            SBC  HL,DE               loaded isn't longer than the existing
2A14            JR   C,#2A1F,LOAD_C3     one.
2A16 LOAD_C2    LD   DE,5                Otherwise a check must be made to
2A19            ADD  HL,DE               ensure that there is sufficient space
2A1A            LD   B,H                 in memory for the program (or array)
to
2A1B            LD   C,L                 be loaded.
2A1C            RST  #10,CALBAS          Make the check by calling the 'main'
2A1D            DEFW #1F05,TEST_ROOM     ROM 'TEST_ROOM' subroutine.
2A1F LOAD_C3    POP  HL                  Restore 'old' start (=0 when handling
2A20            LD   A,(#3E29)           a 'new' array).
2A23            AND  A
2A24            JR   Z,#2A57,LD_PROG     Jump if it's a BASIC program.
2A26            LD   A,H
2A27            OR   L                   Jump unless an 'old' array is to be
2A28            JR   Z,#2A35,LOAD_C4     erased before loading the 'new' one.
2A2A            DEC  HL                  Points to high byte of 'array length'.
2A2B            LD   B,(HL)              Fetch the 'length'.
2A2C            DEC  HL
2A2D            LD   C,(HL)
2A2E            DEC  HL                  Now points to the 'array name'.
2A2F            INC  BC                  Include 'length' and 'name' in the
2A30            INC  BC                  array length.
2A31            INC  BC
2A32            RST  #10,CALBAS          Call 'RECLAIM_2' in the 'main' ROM to
2A33            DEFW #19E8,RECLAIM_2     delete the array.
2A35 LOAD_C4    LD   HL,(23641)          (E_LINE) points to the end of
variables
2A38            DEC  HL                  area+1.
2A39            LD   BC,(#3E2A)          Fetch length of array to be loaded.
2A3D            PUSH BC
2A3E            INC  BC                  Include in the length one byte for the
2A3F            INC  BC                  'array name' and two bytes for the
2A40            INC  BC                  'array length'.
2A41            LD   A,(#3E15)           Fetch the array name from 'LENGTH1_2'.
2A44            PUSH AF
2A45            RST  #10,CALBAS          Call 'MAKE_ROOM' to create the space
2A46            DEFW #1655,MAKE_ROOM     for the array.
2A48            INC  HL                  Point to first 'new' location
inserted.
2A49            POP  AF
2A4A            LD   (HL),A              Store array name into first location.
2A4B            POP  DE
2A4C            INC  HL                  Store array length into the following
2A4D            LD   (HL),E              two locations.
2A4E            INC  HL
2A4F            LD   (HL),D
2A50            INC  HL
2A51            CALL #2A9A,LV_ANY        Load the file.
2A54            JP   #047C,END           Finished.

Now deal with the LOADing of a BASIC program and its variables.

2A57 LD_PROG    LD   DE,(23635)          Fetch start of existing program.
(PROG)
2A5B            LD   HL,(23641)          Fetch end of existing program. I.e.
2A5E            DEC  HL                  (E_LINE)-1.
2A5F            RST  #10,CALBAS          Delete the program by calling
2A60            DEFW #19E5,RECLAIM_1     'RECLAIM_1' in the 'main' ROM.
2A62            LD   BC,(#3E2A)          Fetch length of program and variables.
2A66            LD   HL,(23635)          Fetch (PROG), start of a BASIC
program.
2A69            RST  #10,CALBAS          Create the required space by calling
2A6A            DEFW #1655,MAKE_ROOM     'MAKE_ROOM'.
2A6C            INC  HL                  Point to the first location.
2A6D            LD   BC,(#3E2E)          Fetch length without variables.
2A71            ADD  HL,BC               Calculate and store the start of the
2A72            LD   (23627),HL          variables area.
2A75            LD   A,(#3E31)           When no autostart is known this
2A78            LD   H,A                 ('AUTOSTART2-hi') holds #FF.
2A79            AND  #C0
2A7B            JR   NZ,#2A88,LD_PROG1   Jump with no autostart.
2A7D            LD   A,(#3E30)           Otherwise store the autostart line
2A80            LD   L,A                 number into 'NEWPPC' and clear
'NSPPC'.
2A81            LD   (23618),HL          These hold the line and the statement
2A84            LD   (IY+10),#00         to be executed respectively.
2A88 LD_PROG1   LD   HL,(23635)          Fetch the start of the BASIC program.
2A8B            LD   DE,(#3E2A)          Fetch the length + variables.
2A8F            DEC  HL                  Reset the DATA pointer 'DATADD' to the
2A90            LD   (23639),HL          beginning of the program.
2A93            INC  HL                  Balance the 'DEC HL'.
2A94            CALL #2A9A,LV_ANY        Load the file.
2A97            JP   #047C,END           Finished.

THE 'LOAD OR VERIFY' SUBROUTINE
This subroutine is used to LOAD or VERIFY (signalled by FLAGS3) a block of
bytes. It
must be entered with HL and DE holding 'start' and 'length'.

2A9A LV_ANY     LD   A,D
2A9B            OR   E
2A9C            RET  Z                   Return if 'length' is zero.
2A9D            CALL #163F,TEST_7
2AA0            JR   NZ,#2AAE,LV_ANY3    Jump if 'VERIFYing'.
2AA2            JP   #079E,LOAD_FILE     Otherwise load the file.

2AA5 LV_ANY1    CP   (HL)                The actual VERIFY, i.e. compare the
                                         fetched byte with that held in memory.
2AA6            JP   NZ,#165C,REP_12     Give an error if they don't match.
2AA9 LV_ANY2    INC  HL                  Next memory address.
2AAA            DEC  DE                  One byte less to go.
2AAB            LD   A,D
2AAC            OR   E
2AAD            RET  Z                   Exit if no more bytes left.
2AAE LV_ANY3    CALL #077F,LBYT          Load one byte.
2AB1            CALL #163F,TEST_7
2AB4            JR   NZ,#2AA5,LV_ANY1    Jump if VERIFYing.
2AB6            LD   (HL),A              Otherwise store the byte.
2AB7            JR   #2AA9,LV_ANY2       Repeat for all bytes.

THE 'FORMAT' COMMAND SYNTAX ROUTINE
This routine tests if the command has the appropriate syntax.

2AB9 FORMAT     RST  #28,NEXT_C          Advance CH_ADD to next character.
2ABA            AND  #DF                 Only capitals.
2ABC            CP   68,"D"
2ABE            JP   NZ,#1644,REP_0      Give an error if not a "D".
2AC1            RST  #28,NEXT_C          Next character.
2AC2            CALL #25FA,EXPT_DEVN2    Evaluate the drive number.
2AC5            CP   204,"TO"            Jump if the current character isn't
2AC7            JR   NZ,#2AD3,FORMAT_1   'TO'.
2AC9            CALL #2626,SWAP_UFIAS    Exchange UFIA1 and UFIA2.
2ACC            RST  #28,NEXT_C          Update CH_ADD.
2ACD            CALL #25FA,EXPT_DEVN2    Evaluate 2nd drive number.
2AD0            CALL #2626,SWAP_UFIAS    Exchange UFIA's again.
2AD3 FORMAT_1   CALL #3148,ST_END_RAM    Confirm end of statement and exit when
                                         syntax checking.
2AD6            CALL #0702,TEST_DRV      Check if the drive is defined.
2AD9            RST  #10,CALBAS
2ADA            DEFW #0D6E,CLS_LOWER     Clear lower screen area.
2ADC            SET  5,(IY+2)            Signal 'lower screen has to be
                                         cleared'.
2AE0            CALL #180C,MESG_2        Print 'Are you SURE ? (y/n)' message.
2AE3            CALL #0B60,TEST_Y        Wait for a key, Zero set means 'Y'
2AE6            JP   NZ,#047C,END        pressed. Finished when not sure.
2AE9            CALL #0C2B,FORMAT_RUN    Otherwise FORMAT the disk.
2AEC            JP   #047C,END           Finished.
 ____________________________
|Previous|Next|Contents|Index|
###### 2aef-stream.html ######
###### 2aef-stream.html ######


 ____________________________
|Previous|Next|Contents|Index|
The stream handling routines

THE 'EVALUATE STREAM NUMBER' SUBROUTINE
A single numeric expression is evaluated and the result, in the range 0..15 is
stored
into 'STRM_NUM1'.

2AEF EXPT_#NR   RST  #28,NEXT_C          Advance CH_ADD.
2AF0 EXPT_#NR1  RST  #10,CALBAS          Evaluate stream number.
2AF1            DEFW #1C82,EXPT_1NUM
2AF3            RST  #30,SYNTAX_Z        Return if syntax is being checked.
2AF4            RET  Z
2AF5            PUSH AF
2AF6            RST  #10,CALBAS          Fetch the number.
2AF7            DEFW #1E94,FIND_INT1
2AF9            CP   16                  Give an error if it isn't in the range
2AFB            JP   NC,#1656,REP_9      0..15. ('Invalid station' ?)
2AFE            LD   (#3E03),A           Store stream number into 'STRM_NUM1'.
2B01            POP  AF
2B02            RET

THE 'MOVE' COMMAND SYNTAX ROUTINE
A 'MOVE' command requires two sets of parameters, for the 'input' channel, and
for the
'output' channel. These parameters are stored into the UFIA's.

2B03 MOVE       CALL #2BAD,EXPT_EXP1     Evaluate stream or channel expression.
2B06            CP   204,"TO"            The keyword 'TO' must be present,
2B08            JP   NZ,#1644,REP_0      give an error if 'TO' is missing.
2B0B            CALL #2626,SWAP_UFIAS    Exchange the UFIA's.
2B0E            CALL #2BAD,EXPT_EXP1     Evaluate second stream or channel
                                         expression.
2B11            CALL #2626,SWAP_UFIAS    Exchange the UFIA's again.
2B14            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax check.

The actual 'MOVE' command reads a byte from the source channel or stream, and
then
writes it to the destination channel or stream. This is repeated until the
first channel
or stream reports 'End Of File'. 'SIGN_2' is called to signal to the 'D_INPUT'
routine at
#2EDC that the 'END of file' error isn't to be generated.

2B17            CALL #15FE,SIGN_2        See above.
2B1A            LD   A,191,"IN"          This is the keyword 'IN', it is used
to
2B1C            LD   (#3E02),A           signal 'READ channel'.
2B1F            CALL #2BDA,OP_MOVE       Open the source channel/stream.
2B22            LD   HL,(23631)          Save (CHANS).
2B25            PUSH HL
2B26            LD   A,(#3E02)           Save 'DIR_DESCR1' into 'DIR_DESCR2'.
2B29            LD   (#3E1E),A
2B2C            CALL #2626,SWAP_UFIAS    Exchange the UFIA's.
2B2F            LD   A,223,"OUT"         This is the keyword 'OUT'.
2B31            LD   (#3E02),A           Signal 'WRITE channel'.
2B34            LD   IX,#3AC3            Pointer to DFCA.
2B38            CALL #2BDA,OP_MOVE       Open the destination channel/stream.
2B3B            JR   NC,#2B49,MOVE_RUN1  Jump if opening was successfull. I.e.
                                         file was 'new' or 'old' file was
                                         overwritten.
2B3D            LD   IX,(#3E1E)          Otherwise reclaim first channel
(Second
2B41            CALL #2B9E,RECL_CHAN     wasn't opened so nothing to reclaim).
2B44            POP  HL                  Drop (CHANS) address.
2B45            POP  HL                  ?? Drop what?
2B46            JP   #047C,END           Finished.

2B49 MOVE_RUN1  CALL #2626,SWAP_UFIAS    Exchange UFIA's again.

To my knowledge the instructions at #2B22, #2B25, #2B44 and from #2B4C to #2B58
aren't
needed with the +D. With IF1 the Microdrive maps are situated between 23734
(end of
Spectrum system variables) and (CHANS). The consequence of opening a new
channel could be
the creating of a new map. I.e. the channel information could move up and then
the source
channels address is to be recalculated. With the +D, however, nothing is
situated between
23734 and (CHANS).

2B4C            POP  DE                  Retrieve 'old' (CHANS).
2B4D            LD   HL,(23631)          Fetch 'new' (CHANS).
2B50            OR   A                   Calculate the space which was inserted
2B51            SBC  HL,DE               under (CHANS).
2B53            LD   DE,(#3E05)          Adjust first channels address.
2B57            ADD  HL,DE
2B58            LD   (#3E05),HL
2B5B MOVE_RUN2  LD   HL,(#3E05)          Make 'current' the first channel.
2B5E            LD   (23633),HL          (CURCHL)
2B61 MOVE_RUN3  RST  #10,CALBAS          Call 'INPUT_A' in the 'main' ROM to
2B62            DEFW #15E6,INPUT_A       read a byte.
2B64            JR   C,#2B6A,MOVE_RUN4   Jump with acceptable codes.
2B66            JR   Z,#2B61,MOVE_RUN3   Repeat if no byte read.
2B68            JR   #2B75,MOVE_RUN5     Jump if EOF has been reached.

An acceptable code has been found.

2B6A MOVE_RUN4  LD   HL,(#3E1E)          Make 'current' the 2nd channel.
2B6D            LD   (23633),HL          (CURCHL)
2B70            RST  #10,CALBAS          Use 'main' ROM 'PRINT_A_2' to send the
2B71            DEFW #15F2,PRINT_A_2     byte to the 2nd channel.
2B73            JR   #2B5B,MOVE_RUN2     Repeat until EOF.

EOF has been reached.

2B75 MOVE_RUN5  XOR  A                   Clear FLAGS3.
2B76            LD   (#3ACF),A
2B79            LD   HL,(23631)          Store current (CHANS).
2B7C            PUSH HL
2B7D            CALL #2626,SWAP_UFIAS    Exchange the UFIA's.
2B80            CALL #2C12,CL_MOVE       Close the destination channel.
2B83            CALL #2626,SWAP_UFIAS    Exchange the UFIA's again.

Again the instructions at address #2B79, #2B7C and from #2B86 to #2B92 aren't
needed
with the +D.

2B86            POP  DE                  Restore initial address of CHANS.
2B87            LD   HL,(23631)          Fetch current (CHANS).
2B8A            OR   A                   Calculate the amount of bytes
reclaimed
2B8B            SBC  HL,DE               after the deletion of the second
                                          channel.
2B8D            LD   DE,(#3E05)          Calculate the new start address of the
2B91            ADD  HL,DE               first channel.
2B92            LD   (#3E05),HL          And store it.
2B95            CALL #2C12,CL_MOVE       Close the source channel.
2B98            CALL #2C28,RECL_TEMP     Reclaim temporary channels.
2B9B            JP   #047C,END           Finished.

THE 'RECLAIM CHANNEL' SUBROUTINE
This subroutine is used to reclaim the channel pointed to by IX.

2B9E RECL_CHAN  LD   C,(IX+9)            Fetch channel length.
2BA1            LD   B,(IX+10)
2BA4            PUSH BC
2BA5            PUSH IX                  Channel start to HL.
2BA7            POP  HL
2BA8            RST  #10,CALBAS          Call 'RECLAIM_2' in the 'main' ROM to
2BA9            DEFW #19E8,RECLAIM_2     reclaim the channel.
2BAB            POP  BC
2BAC            RET

THE 'EVALUATE STRM. OR EXPR.' SUBROUTINE
This subroutine is used to check the syntax of the 'MOVE' command. If the
'current'
character is a hash sign (#), then a stream number is evaluated. Otherwise a
device
expression is evaluated.

2BAD EXPT_EXP1  RST  #28,NEXT_C          Advance CH_ADD.
2BAE            CP   35,"#"              Jump to 'EXPT_#_NR' to evaluate stream
2BB0            JP   Z,#2AEF,EXPT_#NR    number if character is a '#'.
2BB3 EXPT_EXP2  LD   (#3E04),A           Otherwise store device letter.
2BB6            AND  #DF                 Only capitals.
2BB8            CP   68,"D"              If device letter isn't "D" then
2BBA            CALL NZ,#25C2,MD_SYN1    evaluate microdrive syntax.
2BBD            CALL #25E2,EXPT_DEVN     Evaluate device number.
2BC0            CALL #25A2,SEPARATOR     If there is a separator exit via
2BC3            JP   Z,#2640,EXPT_FNAME  'EXP_F_NAME' to evaluate a filename.
2BC6            RST  #30,SYNTAX_Z
2BC7            RET  Z                   Return if checking syntax.
2BC8            PUSH AF
2BC9            LD   A,(#3E04)           Fetch device letter.
2BCC            AND  #DF                 Only capitals.
2BCE            CP   68,"D"              If the device is "D" or "M" then there
2BD0            JP   Z,#1648,REP_2       must be a name present. Give an error
2BD3            CP   77,"M"              if no name specified.
2BD5            JP   Z,#1648,REP_2
2BD8            POP  AF
2BD9            RET

THE 'USE STREAM OR CHANNEL' SUBROUTINE
This subroutine is used from the 'MOVE' command routine above to fetch the
start address
of the channel attached to a stream, or to open a channel and fetch its start
address.

2BDA OP_MOVE    LD   A,(#3E03)           Fetch stream number.
2BDD            INC  A                   Jump to open a temporary channel, i.e.
2BDE            JR   Z,#2BEB,OP_MOVE1    if the stream was nonexistent.
2BE0            DEC  A
2BE1            RST  #10,CALBAS          Open the channel attached to stream A.
2BE2            DEFW #1601,CHAN_OPEN
2BE4            LD   HL,(23633)          Store the channels address (CURCHL)
2BE7            LD   (#3E05),HL          into UFIA1.
2BEA            RET                      Return.

2BEB OP_MOVE1   LD   A,(#3E04)           Fetch device letter.
2BEE            AND  #DF                 Capitals only.
2BF0            CP   77,"M"
2BF2            JR   Z,#2BF8,OP_MOVE2    Jump if it's a "M".
2BF4            CP   68,"D"
2BF6            JR   NZ,#2C09,OP_MOVE3   Jump if it isn't a "D".
2BF8 OP_MOVE2   CALL #0702,TEST_DRV      Check if the drive is defined.
2BFB            CALL #2CDF,OP_TEMP_D     Open a temporary "D" channel.
2BFE            LD   A,(#3E05)           Save 'DIR_DESCR1' into 'PROG_NUM1'.
2C01            LD   (#3E02),A
2C04            LD   (#3E05),IX          Store channels address.
2C08            RET

2C09 OP_MOVE3   CP   78,"N"
2C0B            JP   NZ,#1644,REP_0      Give an error if device isn't "N".
2C0E            CALL #1603,SIGN_3        Otherwise signal 'using network'.
2C11            RET

THE 'CLOSE "MOVE" CHANNEL' SUBROUTINE
This is the opposite subroutine of the preceeding one, and is used to CLOSE the
channel
used by the 'MOVE' command routine. If 'STRM_NUM1' denotes that a stream was
used,
nothing is done.

2C12 CL_MOVE    LD   A,(#3E03)           Fetch stream number.
2C15            INC  A
2C16            RET  NZ                  Return if a stream has been used.
2C17            LD   A,(#3E04)           Otherwise fetch device letter.
2C1A            AND  #DF                 Only capitals.
2C1C            CP   78,"N"
2C1E            JR   Z,#2C27,CL_MOVE1    Jump if it was "N".
2C20            LD   IX,(#3E05)          Fetch channel address.
2C24            JP   #2C57,CLOSE_CHAN    Close the channel and exit.
2C27 CL_MOVE1   RET

THE 'RECLAIM TEMP. CHANNELS' SUBROUTINE
This subroutine is called to reclaim from the CHANS all 'temporary' channels
(i.e. with
bit 7 of the channel specifier set).

2C28 RECL_TEMP  LD   IX,(23631)          Point to the start of the channel
area.
2C2C            LD   DE,20               IX now points to the first
2C2F            ADD  IX,DE               'non-standard' channel.
2C31 RECL_T1    LD   A,(IX+0)
2C34            CP   128                 Return if the end marker was found,
2C36            RET  Z                   i.e. there are no more channels.
2C37            LD   A,(IX+4)            Fetch channel specifier.
2C3A            CP   196,"D"+128
2C3C            JR   NZ,#2C43,RECL_T2    Jump if not a temporary "D" channel.
2C3E            CALL #2C57,CLOSE_CHAN
2C41            JR   #2C28,RECL_TEMP

Permanent "D" channels mustn't be closed, except when 'CLEAR #' was given.

2C43 RECL_T2    CALL #1621,TEST_1
2C46            JR   Z,#2C4D,RECL_T3     Jump if not 'CLEAR # executing'.
2C48            CALL #2B9E,RECL_CHAN     Otherwise reclaim the channel.
2C4B            JR   #2C28,RECL_TEMP

Skip this channel.

2C4D RECL_T3    LD   E,(IX+9)            Fetch channel length.
2C50            LD   D,(IX+10)
2C53            ADD  IX,DE               Point to the next channel.
2C55            JR   #2C31,RECL_T1       Repeat for all channels.

THE 'CLOSE CHANNEL' SUBROUTINE
This subroutine closes the channel pointed to by IX.

2C57 CLOSE_CHAN PUSH IX
2C59            POP  HL
2C5A            LD   DE,(23631)          (CHANS).
2C5E            OR   A
2C5F            SBC  HL,DE               Calculate channel offset.
2C61            INC  HL
2C62            LD   (#3DED),HL          The channel is CLOSEd by jumping into
2C65            JP   #2E80,CLOSE_0       the 'CLOSE' routine

THE 'OPEN' COMMAND SYNTAX ROUTINE
This routine deals with the 'OPEN #' command concerning +D channels, Spectrum
channels
are handled by the 'main' ROM.

2C68 OPEN       CALL #2AEF,EXPT_#NR      Evaluate stream number.
2C6B            CALL #25A2,SEPARATOR
2C6E            JP   NZ,#1644,REP_0      Give an error if no separator found.
2C71            CALL #2BB3,EXPT_EXP2     Evaluate channel specifier.
2C74            CP   13
2C76            JR   Z,#2C85,OPEN_2      Jump if no more parameters.
2C78            CP   191,"IN"
2C7A            JR   Z,#2C81,OPEN_1      Jump if 'IN' specified.
2C7C            CP   223,"OUT"
2C7E            JP   NZ,#1648,REP_2      Give error if no 'OUT' specified.
2C81 OPEN_1     LD   (#3E02),A           Store the channel type (IN or OUT) in
                                         'PROG_NUM1'.
2C84            RST  #28,NEXT_C          Advance CH_ADD.
2C85 OPEN_2     CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2C88            LD   A,(#3E03)           Fetch stream number.
2C8B            RST  #10,CALBAS          Call 'main' ROM 'STR_DATA1' routine;
on
2C8C            DEFW #1727,STR_DATA1     exit, BC holds 'stream data'.
2C8E            LD   HL,17
2C91            AND  A
2C92            SBC  HL,BC               Give an error if the current stream
was
2C94            JP   C,#1680,REP_30      already used by the +D.
2C97            LD   A,(#3E04)           Fetch channel specifier.
2C9A            AND  #DF                 Only capitals.
2C9C            CP   68,"D"
2C9E            JR   Z,#2CA5,OPEN_3      Jump if opening a "D" channel.
2CA0            CP   77,"M"              Give an error if not opening a "M"
2CA2            JP   NZ,#1644,REP_0      channel.
2CA5 OPEN_3     CALL #0702,TEST_DRV      See if the drive is defined.
2CA8            LD   A,#0A               Signal 'OPENTYPE file'.
2CAA            LD   (#3E05),A
2CAD            CALL #2CB3,OPEN_CHAN     Open the channel.
2CB0            JP   #047C,END           Finished.

THE 'OPEN "D" CHANNEL' SUBROUTINE
This is the actual OPEN routine referred to the "D" channel.

2CB3 OPEN_CHAN  LD   A,(#3E03)           Fetch stream number.
2CB6            ADD  A,A                 The streams area entries are two bytes
                                         each.
2CB7            LD   HL,23574            Address of data for stream 0.
2CBA            LD   E,A
2CBB            LD   D,0
2CBD            ADD  HL,DE               Index into STRMS area.
2CBE            PUSH HL
2CBF            CALL #2CDF,OP_TEMP_D     Open a temporary "D" channel. On
return
2CC2            POP  DE                  HL holds new channel offset.
2CC3            RET  C                   Return when an error occurred.
2CC4            BIT  0,(IX+12)
2CC8            JR   Z,#2CD6,MAKE_PERM   Jump if this is a 'read' file.
2CCA            IN   A,(227)             Read Floppy Disk Controller status.
2CCC            BIT  6,A                 Test the 'write protect' bit.
2CCE            JR   Z,#2CD6,MAKE_PERM   Jump if disk isn't write protected.

NOTE: This doesn't work, the write protect bit of the FDC's status register is
not
adjusted with read commands. So the jump is always made.

2CD0            CALL #2B9E,RECL_CHAN     Otherwise reclaim the channel.
2CD3            JP   #1672,REP_23        And give an error.
2CD6 MAKE_PERM  RES  7,(IX+4)            Make the channel permanent by
resetting
                                         bit 7 of the channel specifier.
2CDA            EX   DE,HL               DE holds new channel offset.
2CDB            LD   (HL),E              Store it into the STRMS area.
2CDC            INC  HL
2CDD            LD   (HL),D
2CDE            RET                      Finished.

THE 'OPEN TEMP. "D" CHANNEL' SUBROUTINE
This subroutine is used to open a temporary "D" channel in the CHANS area.

2CDF OP_TEMP_D  LD   IX,(23631)          Start of channel area (CHANS).
2CE3            LD   DE,20               Point to the first 'non-standard'
2CE6            ADD  IX,DE               channel.
2CE8 OP_TEMP1   LD   A,(IX+0)
2CEB            CP   128
2CED            JR   Z,#2D24,OP_TEMP4    Jump if end of CHANS area is reached.
2CEF            LD   A,(IX+4)            Otherwise fetch channel specifier.
2CF2            AND  #5F                 Clear bit 7 and make capital.
2CF4            CP   68,"D"
2CF6            JR   NZ,#2D1A,OP_TEMP3   Jump if this isn't a "D" channel.
2CF8            LD   A,(#3E01)           Fetch drive number.
2CFB            CP   (IX+11)             Jump if this channel uses a different
2CFE            JR   NZ,#2D1A,OP_TEMP3   drive.
2D00            PUSH IX
2D02            POP  HL                  Start of channel to HL.
2D03            LD   DE,20               Filename offset.
2D06            ADD  HL,DE
2D07            EX   DE,HL               DE points to the name of this channel.
2D08            LD   HL,#3E06            HL points to the name of the channel
to
2D0B            LD   B,10                be opened.
2D0D OP_TEMP2   LD   A,(DE)
2D0E            XOR  (HL)
2D0F            AND  #DF                 Capitalize.
2D11            JR   NZ,#2D1A,OP_TEMP3   Jump if not the same file.
2D13            INC  HL
2D14            INC  DE
2D15            DJNZ #2D0D,OP_TEMP2      Repeat for all 10 characters.
2D17            JP   #1682,REP_31        Give an error if the channel already
                                         exists.
2D1A OP_TEMP3   LD   E,(IX+9)            Fetch the length of the channel.
2D1D            LD   D,(IX+10)
2D20            ADD  IX,DE               Point to the next channel.
2D22            JR   #2CE8,OP_TEMP1      Repeat for all channels.

The channel wasn't already present in memory so it can be opened.

2D24 OP_TEMP4   PUSH IX
2D26            LD   A,%0001000          Scan the CATalogue for a matching
2D28            CALL #09A5,SCAN_CAT      filename.
2D2B            LD   A,(#3E02)           Get channel type (read/write).
2D2E            JP   NZ,#2D8A,OP_TEMP5   Jump if file not found.
2D31            CP   223,"OUT"
2D33            JP   Z,#312A,OP_T_PATCH  Jump if OUTput channel.
2D36            LD   BC,551              Length of INput channel.
2D39            CALL #2DF3,CHAN_SPC      Create the room for the channel.
2D3C            CALL #0D93,RPT_HL        Make HL point to the CAT entry.
2D3F            POP  IX
2D41            CALL #0702,TEST_DRV      See if the drive is defined.
2D44            NOP
2D45            NOP
2D46            NOP
2D47            LD   A,0                 Signal 'READing'.
2D49            LD   (IX+12),A
2D4C            LD   BC,39               Offset of buffer from start of
channel.
2D4F            LD   (IX+15),C
2D52            LD   (IX+16),B
2D55            PUSH HL                  HL points to the CATalogue entry.
2D56            PUSH IX                  IX points to the start of the channel.
2D58            POP  HL
2D59            LD   DE,19               Offset of directory description.
2D5C            ADD  HL,DE
2D5D            EX   DE,HL
2D5E            POP  HL                  Pointer to CAT entry.
2D5F            LD   BC,11               Move the directory description and the
2D62            LD   A,(HL)              filename to the channel.
2D63            LD   (#3E05),A           Store dir. descr. in UFIA1.
2D66            LDIR
2D68            INC  HL                  Skip length in sectors, i.e. point to
2D69            INC  HL                  track and sector bytes.
2D6A            LD   B,(HL)              Fetch first track and sector.
2D6B            INC  HL
2D6C            LD   C,(HL)
2D6D            PUSH BC
2D6E            LD   BC,196
2D71            ADD  HL,BC               HL points to file header - 1 in CAT
2D72            LD   A,(HL)              entry. That is the MSB of the file
2D73            LD   (IX+18),A           length (number of 64K blocks).
2D76            INC  HL
2D77            LD   BC,9
2D7A            LDIR                     Copy the file header to the channel.
2D7C            LD   DE,#3FEA
2D7F            LD   BC,22               Copy the SNAP registers (?).
2D82            LDIR
2D84            POP  DE                  Get track and sector in DE.
2D85            CALL #05CC,RSAD          Load the sector at DE.
2D88            JR   #2DDC,OP_TEMP8

The file was not found, so if the channel isn't for OUTput give an error.

2D8A OP_TEMP5   CP   191,"IN"
2D8C            JP   Z,#1678,REP_26      Give error if it is an INput channel.
2D8F OP_TEMP6   LD   BC,787              Length of OUTput channel.
2D92            CALL #2DF3,CHAN_SPC      Create the room for the channel.
2D95            POP  IX
2D97            CALL #0702,TEST_DRV      See if the drive is defined.
2D9A            NOP
2D9B            NOP
2D9C            NOP
2D9D            LD   A,1                 Signal 'WRITEing'.
2D9F            LD   (IX+12),A
2DA2            LD   BC,275              Offset of databuffer from the start of
2DA5            LD   (IX+15),C           the channel.
2DA8            LD   (IX+16),B
2DAB            CALL #0AD9,OFSM_2        Open the file.
2DAE            JR   Z,#2DBB,OP_TEMP7    Jump if file doesn't exist (anymore).
2DB0            LD   BC,787              Length of an OUTput channel.
2DB3            PUSH IX                  Start of the channel to HL.
2DB5            POP  HL
2DB6            RST  #10,CALBAS          Reclaim the channel.
2DB7            DEFW #19E8,RECLAIM_2
2DB9            SCF                      Signal 'error'.
2DBA            RET                      Finished.

2DBB OP_TEMP7   JP   #2DDC,OP_TEMP8      Jump forward.

Before the routine continues there are first some 'leftovers' from a earlier
system
version.

2DBE            JR   Z,#2DDC,OP_TEMP8
2DC0            PUSH IX
2DC2            POP  HL
2DC3            LD   DE,230
2DC6            ADD  HL,DE
2DC7            EX   DE,HL
2DC8            LD   HL,(#3E1E)
2DCB            LD   BC,30
2DCE            ADD  HL,BC
2DCF            LD   BC,9
2DD2            LDIR
2DD4            LD   HL,#3FEA
2DD7            LD   BC,20
2DDA            LDIR

Now continue with the 'OPEN a temporary "D" channel' routine.

2DDC OP_TEMP8   PUSH IX
2DDE            POP  DE                  Start of channel to DE.
2DDF            LD   HL,#2E0B,D_CH_DATA  Start of the "D" channel data.
2DE2            LD   BC,11               Copy the 11 bytes channel data to the
2DE5            LDIR                     channel area.
2DE7            PUSH IX                  Start of channel to HL.
2DE9            POP  HL
2DEA            LD   DE,(23631)          HL-(CHANS)+1 gives the required
'stream
2DEE            OR   A                   offset'.
2DEF            SBC  HL,DE
2DF1            INC  HL
2DF2            RET                      Finished.

THE 'MAKE ROOM FOR CHANNEL' SUBROUTINE
This small subroutine creates room for a channel at the end of the CHANS area
(i.e. just
before the BASIC program).

2DF3 CHAN_SPC   LD   (#2E14),BC          Store the length of the channel into
                                         the "D" channel data table.
2DF7            LD   HL,(23635)          Fetch the start address of the channel
2DFA            DEC  HL                  ((PROG)-1).
2DFB            PUSH HL
2DFC            PUSH BC
2DFD            RST  #10,CALBAS          Create the required space by calling
2DFE            DEFW #1655,MAKE_ROOM     'main' ROM 'MAKE_ROOM'.
2E00            POP  BC
2E01            POP  HL                  Clear the created space.
2E02 CHAN_SPC1  LD   (HL),0
2E04            INC  HL
2E05            DEC  BC
2E06            LD   A,B
2E07            OR   C
2E08            JR   NZ,#2E02,CHAN_SPC1
2E0A            RET

THE '"D" CHANNEL DATA' TABLE
The '11' bytes that compose the initial part of a "D" channel are as follows:

2E0B D_CH_DATA  DEFW #0008               Main ROM 'output' routine.
2E0D            DEFW #0008               Main ROM 'input' routine.
2E0F            DEFB "D"+128             Channel specifier.
2E10            DEFW #2F5F,DCHAN_OUT     +D system 'output' routine.
2E12            DEFW #2EDC,D_INPUT       +D system 'input' routine.
2E14            DEFW #0000               Length of a channel.

THE 'CLOSE #' COMMAND SYNTAX ROUTINE
Unlike the Interface 1 and the Opus Discovery, the +D doesn't page-in in the
middle of
the 'main' ROM 'CLOSE' routine. But because the 'main' ROM routine can't cope
with +D
channels a 'CLOSE' for those channels has to be available. In order to fail the
normal
syntax, 'CLOSE #*s' has to be used. The 'CLOSE #*' command closes all streams.

2E16 CLOSE      RST  #28,NEXT_C          Next character.
2E17            CP   42,"*"
2E19            JP   NZ,#1644,REP_0      Give an error if it isn't a '*'.
2E1C            RST  #28,NEXT_C          Next character.
2E1D            CP   13
2E1F            JR   Z,#2E34,CLOSE_ALL   Jump if statement ended with ENTER.
2E21            CP   58,":"
2E23            JR   Z,#2E34,CLOSE_ALL   Also if statement ended with a ':'.
2E25            CALL #2AF0,EXPT_#NR1     Evaluate stream number.
2E28            CALL #3148,ST_END_RAM    Confirm end of statement and exit when
                                         syntax checking.
2E2B            LD   A,(#3E03)           Fetch stream number.
2E2E            CALL #2E5E,CLOSE_STRM    Close the stream.
2E31            JP   #047C,END           Finished.

2E34 CLOSE_ALL  CALL #3148,ST_END_RAM    Confirm end of statement and exit if
2E37            JR   #2E46,CLEAR_1       syntax checking. Jump into the CLEAR#
                                         routine.

THE 'CLEAR #' COMMAND ROUTINE
All streams are closed in turn, with bit 1 of FLAGS3 set to signal that the
remaining
buffer contents are to be erased (with the 'CLOSE #*' command all buffers are
emptied,
i.e. their contents are sent to the corresponding device).

2E39 CLEAR      RST  #28,NEXT_C          Advance CH_ADD.
2E3A            CP   35,"#"
2E3C            JP   NZ,#1644,REP_0      Give an error if it isn't a '#'.
2E3F            RST  #28,NEXT_C
2E40            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2E43            CALL #15F9,SIGN_1        Signal 'CLEAR #'.
2E46 CLEAR_1    XOR  A                   Start with stream 0.
2E47 CLEAR_2    PUSH AF
2E48            CALL #2E5E,CLOSE_STRM    Close this stream.
2E4B            POP  AF
2E4C            INC  A                   Next stream.
2E4D            CP   16                  Repeat until all streams 0..15 have
2E4F            JR   C,#2E47,CLEAR_2     been CLOSEd.
2E51            CALL #2C28,RECL_TEMP     Reclaim temporary channels.
2E54            XOR  A
2E55            LD   (#3DEF),A           Clear 'MAP_USED' (=POKE @7663,0).
2E58            LD   (#3ACF),A           Clear FLAGS3.
2E5B            JP   #047C,END           Finished.

THE 'CLOSE A STREAM' SUBROUTINE
Any stream 0 to 15 may be CLOSEd by loading the stream number into A and then
calling
this subroutine. The unsent bytes in 'OUTput' files are sent or lost depending
upon
whether bit 1 of FLAGS3 is reset or set. First a call to 'STR_DATA1' in the
'main' ROM is
made to fetch into BC the 'stream data' for the given stream, and to make HL
point to the
first of the two data bytes.

2E5E CLOSE_STRM RST  #10,CALBAS          Call 'STR_DATA1'.
2E5F            DEFW #1727,STR_DATA1
2E61            LD   A,C
2E62            OR   B                   Return if the stream is already CLOSEd
2E63            RET  Z                   (i.e. stream data = 0).
2E64            LD   (#3DED),BC          Store stream data.
2E68            PUSH HL
2E69            LD   HL,(23631)          Make HL point to the start of the
2E6C            DEC  HL                  channel attached to the stream to be
2E6D            ADD  HL,BC               CLOSEd ((CHANS)+'stream data').
2E6E            EX   (SP),HL             HL now holds the address of the stream
                                         data.
2E6F            RST  #10,CALBAS          A call in the middle of the 'main' ROM
2E70            DEFW #16EB,CLOSE_0       'CLOSE' routine is made to update
STRMS
                                         contents.
2E72            POP  IX                  IX points to the start of the channel
2E74            LD   A,B                 to be removed.
2E75            OR   C
2E76            RET  NZ                  Exit if the stream is one of 0 to 3.

NOTE: Because this test tests for streams a disk channel attached to one of the
streams
0..3 can never be CLOSEd. If the test was made for 'standard' channels it had
been possible to
use streams 0..3 with "D" channels.

2E77            LD   A,(IX+4)            Fetch channel specifier.
2E7A            AND  #5F                 Clear bit 7 (temporary) and make
                                         capital.
2E7C            CP   68,"D"
2E7E            JR   NZ,#2E8E,CLOSE_1    Jump if it isn't a "D" channel.
2E80 CLOSE_0    BIT  0,(IX+12)
2E84            JR   Z,#2E8E,CLOSE_1     Jump if it is an 'INput' channel.
2E86            CALL #1621,TEST_1        Jump if doing a 'CLEAR #', i.e. just
2E89            JR   NZ,#2E8E,CLOSE_1    remove the channel.
2E8B            CALL #3117,CL_PATCH      Empty the buffer.
2E8E CLOSE_1    CALL #2B9E,RECL_CHAN     Reclaim the channel.

Now all data refering to the stream attached to the channels moved down are
updated.

2E91            XOR  A                   Start with stream 0.
2E92            LD   HL,23574            Address of data for stream 0.
2E95 CLOSE_2    LD   (#3AC8),HL          Use 'FILE_ADDR' as a temporary
storage.
2E98            LD   E,(HL)              Fetch stream data.
2E99            INC  HL
2E9A            LD   D,(HL)
2E9B            LD   HL,(#3DED)          Fetch stream data for CLOSEd stream.
2E9E            AND  A                   Jump if the stream data found is lower
2E9F            SBC  HL,DE               than that of the CLOSEd stream (i.e.
2EA1            JR   NC,#2EAE,CLOSE_3    channel has not been moved).
2EA3            EX   DE,HL               Fetched stream data to HL.
2EA4            AND  A
2EA5            SBC  HL,BC               Calculate the new stream data.
2EA7            EX   DE,HL               New stream data to DE.
2EA8            LD   HL,(#3AC8)          Restore stream data address.
2EAB            LD   (HL),E              Store new stream data.
2EAC            INC  HL
2EAD            LD   (HL),D
2EAE CLOSE_3    LD   HL,(#3AC8)          Make HL point to next stream data.
2EB1            INC  HL
2EB2            INC  HL
2EB3            INC  A                   Increment stream number.
2EB4            CP   16
2EB6            JR   C,#2E95,CLOSE_2     Repeat for all streams 0..15.
2EB8            RET                      Finished.

THE 'CLS #' COMMAND ROUTINE
The 'CLS #' command resets during runtime the Spectrum system variables ATTR_P,
ATTR_T,
MASK_P, MASK_T, P_FLAG and BORDCR. I.e. all these variables are filled with
their
'initial' values (paper 7, ink 0, flash 0 and bright 0).

2EB9 CLS        RST  #28,NEXT_C          Next character.
2EBA            CP   35,"#"
2EBC            JP   NZ,#1644,REP_0      Give error if it isn't a '#'.
2EBF            RST  #28,NEXT_C          Next character.
2EC0            CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
2EC3            LD   HL,56               The 'initial' attribute value.
2EC6            LD   (23693),HL          Store 56 into ATTR_P, clear MASK_P.
2EC9            LD   (23695),HL          Store 56 into ATTR_T, clear MASK_T.
2ECC            LD   (IY+14),L           Store 56 also for lower screen
                                         attribute.
2ECF            LD   (IY+87),H           Clear P_FLAG.
2ED2            LD   A,7                 Set white border.
2ED4            OUT  (254),A
2ED6            RST  #10,CALBAS          Call 'main' ROM 'CLS' routine.
2ED7            DEFW #0D6B,CLS
2ED9            JP   #047C,END           Finished.

THE '"D" CHANNEL INPUT' ROUTINE
This is a peculiar routine, although the +D supports only one type of channel
(the "D"
channel), this routine can handle all kinds of channels by loading HL with the
address of
the 'service' input routine and entering at address #2EE3. From that address on
it's
largely the same as the Interface 1 'CALL_INP' routine, which routine handles
all the
IF1's channels.

2EDC D_INPUT    LD   IX,(23633)          IX points to the start of the current
                                         channel (CURCHL).
2EE0            LD   HL,#2F2E,DCHAN_IN   Address of "D" input service routine.
2EE3            RES  3,(IY+2)            Signal 'the mode is to be considered
as
                                         being unchanged'.
2EE7            PUSH HL                  Store address of service routine.
2EE8            LD   HL,(23613)          HL points to error address (ERR_SP).
2EEB            LD   E,(HL)              Fetch the error address.
2EEC            INC  HL
2EED            LD   D,(HL)
2EEE            AND  A
2EEF            LD   HL,#107F,ED_ERROR   If the error address is 'ED_ERROR'
2EF2            SBC  HL,DE               ('main' ROM) then an INPUT command was
2EF4            JR   NZ,#2F1D,D_INKEY$   used. Jump if unequal to 'ED_ERROR'.

Now deal with an 'INPUT #' command referred to a "D" channel.

2EF6            POP  HL                  Restore address of service routine.
2EF7            LD   SP,(23613)          Clear the machine stack (ERR_SP).
2EFB            POP  DE                  Remove 'ED_ERROR'.
2EFC            POP  DE
2EFD            LD   (23613),DE          Restore the old value of ERR_SP.
2F01 D_INPUT1   PUSH HL                  Store address of service routine.
2F02            LD   DE,#2F07,D_INP_END  Return address is 'D_INP_END' below.
2F05            PUSH DE
2F06            JP   (HL)                Jump to the service routine.

When the byte has been read from the required channel, a return is made here to
add the
byte to the INPUT line, or to return if the byte is equal to CHR$ 13, i.e.
ENTER.

2F07 D_INP_END  JR   C,#2F0F,D_INP_ACC   Jump with acceptable codes.
2F09            JP   NZ,#167A,REP_27     Give the 'END of file' error when the
                                         Zero flag is reset.
2F0C            POP  HL                  Otherwise restore address of service
2F0D            JR   #2F01,D_INPUT1      routine and try again.

2F0F D_INP_ACC  CP   13
2F11            JR   Z,#2F19,D_INPUT2    Jump if the code is ENTER.
2F13            RST  #10,CALBAS          Otherwise the byte is to be added to
2F14            DEFW #0F85,ADD_CHAR0     the INPUT line. This is done by
calling
                                         into the 'ADD_CHAR' subroutine.
2F16            POP  HL                  Restore address of service routine and
2F17            JR   #2F01,D_INPUT1      read the next byte.

2F19 D_INPUT2   POP  HL                  Drop the address of the service
routine
2F1A            JP   #0050,UNPAGE_1      and page-out the +D system.

Now deal with the reading of a single byte.

2F1D D_INKEY$   POP  HL                  Restore address of the servce routine.
2F1E            LD   DE,#2F23,D_INK$_END Return address is 'D_INK$_END' below.
2F21            PUSH DE
2F22            JP   (HL)                Jump to the service routine.

2F23 D_INK$_END RET  C                   Return with acceptable codes or
2F24            RET  Z                   with no byte read.
2F25            CALL #1626,TEST_2        Give the 'END of file' error if not
2F28            JP   Z,#167A,REP_27      executing a 'MOVE' command.
2F2B            OR   1                   Otherwise return with Zero and Carry
2F2D            RET                      flags both reset.

THE '"D" CHANNEL INPUT' SERVICE ROUTINE
This is the actual input a byte from disk routine. The byte is read from the
data buffer
in the channel, when it is empty the next sector is read from disk (provided
that the
'current' data block is not the EOF one) before reading the byte.

2F2E DCHAN_IN   BIT  0,(IX+12)           Give 'Reading a WRITE file' error if
2F32            JP   NZ,#1668,REP_18     it's an OUTput channel.
2F35            LD   A,(IX+31)           Decrease LSB of file length.
2F38            SUB  1
2F3A            LD   (IX+31),A
2F3D            JR   NC,#2F57,DCHAN_IN1  Jump if more bytes left.
2F3F            LD   A,(IX+32)           Decrease MID byte of file length.
2F42            SUB  1
2F44            LD   (IX+32),A
2F47            JR   NC,#2F57,DCHAN_IN1  Jump if more bytes left.
2F49            LD   A,(IX+18)           Decrease MSB of file length.
2F4C            SUB  1
2F4E            LD   (IX+18),A
2F51            JR   NC,#2F57,DCHAN_IN1  Jump if more bytes left.
2F53            XOR  A                   Otherwise EOF has been reached, so
                                         reset Zero and Carry flag to signal
                                         'End Of File'.
2F54            ADD  A,13                The return byte is 13.
2F56            RET                      Finished.

NOTE: This 'end of file' test works only once, if an attempt is made to read
more bytes
after the 'End of FILE' message has been given a crash will almost certainly
follow.

2F57 D_CHANIN1  CALL #077F,LBYT          Load one byte, read a new sector from
                                         disk when the buffer is empty.
2F5A            CALL #168E,BORD_REST     Restore border colour.
2F5D            SCF                      Signal 'acceptable code'.
2F5E            RET

THE '"D" CHANNEL OUTPUT' ROUTINE
The routine which handles "D" channel output is quite short. It SAVEs the byte
in the A
register to disk by calling the ROM 'SBYT' routine, which handles the saving of
the byte.
The only thing done here is incrementing the file length bytes.

2F5F DCHAN_OUT  LD   IX,(23633)          IX point to current channel (CURCHL).
2F63            BIT  0,(IX+12)           Give 'Writing a READ file' error if
2F67            JP   Z,#166A,REP_19      it's an INput channel.
2F6A            CALL #0761,SBYT          Save the byte in the A register.
2F6D            CALL #168E,BORD_REST     Restore the border colour.
2F70            NOP
2F71            NOP
2F72            NOP
2F73            NOP
2F74            PUSH IX
2F76            LD   BC,229
2F79            ADD  IX,BC               IX now points to the file header.
2F7B            INC  (IX+2)              Update file length, skip higher bytes
2F7E            JR   NZ,#2F88,DCHAN_OUT1 if it isn't necessary to update them.
2F80            INC  (IX+3)
2F83            JR   NZ,#2F88,DCHAN_OUT1
2F85            INC  (IX+0)
2F88 DCHAN_OUT1 POP  IX
2F8A            RET                      Finished.
 ____________________________
|Previous|Next|Contents|Index|
###### 2f8b-command.html ######
###### 2f8b-command.html ######


 ____________________________
|Previous|Next|Contents|Index|
The Command code routines

THE 'TRANSFER UFIA TO DFCA' SUBROUTINE
This subroutine is called by using command code 51 (#33), it transfers the file
description and header (UFIA) to the Disk File Channel Area (DFCA). On entry IX
must
point to the start of the User's File Information Area (UFIA).

2F8B HXFER      PUSH IX
2F8D            POP  HL
2F8E            LD   DE,#3E01            Start of 'UFIA1'.
2F91            LD   BC,24
2F94            LDIR                     Transfer the UFIA to 'UFIA1'.
2F96            LD   IX,#3AC3            IX points to the DFCA.
2F9A            CALL #0702,TEST_DRV      Check if the specified drive is
2F9D            RET                      defined.

THE 'OPEN FILE SECTOR MAP' SUBROUTINE
This subroutine is called by using command code 52 (#34), it Opens a File
Sector Map
with the information contained in the DFCA. On entry IX must point to the UFIA,
a call to
'HXFER' above transfers the UFIA to the DFCA. A return is made with the disk
buffer
pointer (RPT) set to the start of the disk buffer in the +D RAM. 'OFSM' should
be used
for files which don't contain a 9 byte header at the start of the file.

2F9E OFSM       CALL #2F8B,HXFER         Transfer UFIA to DFCA.
2FA1            JP   #0AD9,OFSM_2        Open the file sector map.

THE 'OPEN A FILE' SUBROUTINE
This subroutine is called by using command code 53 (#35), it opens a file for
SAVEing.
As with the preceeding subroutines IX must point to the UFIA. By calling 'OFSM'
above the
UFIA is transferred to the DFCA and the file sector map is opened. Finally
'SAVE_HEAD1'
is called to transfer the 9 bytes file header to the file. 'HOFLE' can be used
for files
which contain the 9 byte header.

2FA4 HOFLE      CALL #2F9E,OFSM          Transfer UFIA to DFCA and open the
file
                                         sector map.
2FA7            CALL #2879,SAVE_HEAD1    Transfer the 9 byte file header to the
2FAA            RET                      file and exit.

THE 'SAVE BLOCK TO DISK' SUBROUTINE
This is called by using command code 55 (#37). The data block starting at
address DE
with length BC is SAVEd to disk.
NOTE: A file has to be opened for SAVEing before writing bytes. Use 'HOFLE' or
'OFSM' to
do this.

2FAB HSVBK      CALL #2FCB,BCDE_DEHL     Transfer BC to DE and DE to HL.
2FAE            JP   #0850,HSVBK_2       Save the block.

THE 'GET A FILE FROM DISK' SUBROUTINE
This is called by using command code 59 (#3B), it opens a file for LOADing. The
IX
register must point to the start of the UFIA. The return is made with the first
sector of
the file loaded into the disk buffer and RPT pointing to the first byte
(usually the
start of the 9 byte file header).

2FB1 HGFLE      CALL #2F8B,HXFER         Transfer the UFIA to the DFCA.
2FB4            JP   #0BCF,HGFLE_2       Open the file and load the first
sector
                                         in the disk buffer.

THE 'LOAD BLOCK FROM DISK' SUBROUTINE
This subroutine is called by using command code 61 (#3D), it does the opposite
of
'HSVBK' above. The data block starting at address DE with length BC is LOADed
from disk.
NOTE: The file has to be opened by using 'HGFLE' before an attempt can be made
to LOAD
bytes. Don't try to LOAD more bytes than available.

2FB7 HLDBK      CALL #2FCB,BCDE_DEHL     Transfer BC to DE and DE to HL.
2FBA            JP   #079E,LOAD_FILE     Load the block.

THE 'ERASE A FILE' SUBROUTINE
This is called by using command code 65 (#41). It ERASEs one file on the disk
(even when
wildcards were used), using the information contained in the UFIA, so make sure
that IX
points to the start of it.

2FBD HERAZ      CALL #2F8B,HXFER         Transfer the UFIA to the DFCA.
2FC0            CALL #2559,FIND_FILE     Find the file, HL points to the
                                         directory entry of the file (contained
                                         in the disk buffer).
2FC3            JP   NZ,#1678,REP_26     Give error if file not found.
2FC6            LD   (HL),0              Directory description 0 means ERASEd.
2FC8            JP   #0584,WSAD          Write sector DE.

THE 'BC TO DE AND DE TO HL' SUBROUTINE
This routine transfers the contents of BC to DE and that of DE to HL, it also
sets IX to
the start of the DFCA.

2FCB BCDE_DEHL  PUSH DE
2FCC            PUSH BC
2FCD            POP  DE
2FCE            POP  HL
2FCF            LD   IX,#3AC3
2FD3            RET

THE 'READ SECTOR TO ADDRESS' SUBROUTINE
This routine is called by using command code 68 (#44). It reads sector DE from
drive A
to the address held in the IX register.

2FD4 HRSAD      PUSH BC
2FD5            PUSH IX
2FD7            LD   IX,#3AC3
2FDB            CALL #0705,TEST_DRV      See if the drive held in the A
register
                                         is defined.
2FDE            CALL #05CC,RSAD          Load the sector into the disk buffer.
2FE1            POP  HL
2FE2            PUSH DE
2FE3            LD   DE,#3BD6            Start of disk buffer.
2FE6            EX   DE,HL
2FE7            LD   BC,512              Sector length.
2FEA            LDIR                     Move sector to specified address.
2FEC            PUSH DE
2FED            POP  IX                  Update IX.
2FEF            POP  DE                  Restore DE and BC.
2FF0            POP  BC
2FF1            RET

THE 'WRITE SECTOR FROM ADDR.' SUBROUTINE
This is called using command code 69 (#45), it writes sector DE to drive A
starting from
address IX.

2FF2 HWSAD      PUSH BC
2FF3            PUSH IX
2FF5            POP  HL
2FF6            LD   IX,#3AC3
2FFA            CALL #0705,TEST_DRV      See if the drive held in the A
register
2FFD            PUSH DE                  is defined.
2FFE            LD   DE,#3BD6
3001            LD   BC,512              Sector length.
3004            LDIR                     Move BC bytes to the disk buffer.
3006            POP  DE
3007            PUSH HL
3008            CALL #0584,WSAD          Write sector DE to disk.
300B            POP  IX
300D            POP  BC
300E            RET                      Finished.

THE 'READ SECTOR DE' SUBROUTINE
This routine is called using command code 63 (#3F), it loads sector DE from the
current
drive into the disk buffer.

300F JRSAD      LD   IX,#3AC3
3013            JP   #05CC,RSAD          Load the sector.

THE 'WRITE SECTOR DE' SUBROUTINE
This is called using command code 62 (#3E), it saves the contents of the disk
buffer
into sector DE on the current drive.

3016 JWSAD      LD   IX,#3AC3
301A            JP   #0584,WSAD          Save the sector.
 ____________________________
|Previous|Next|Contents|Index|
###### 301d-misc3.html ######
###### 301d-misc3.html ######


 ____________________________
|Previous|Next|Contents|Index|
Miscalleneous routines III

THE 'COPY SCREEN' ROUTINE
This routine has two entry points. The first one, #301D, is used with the BASIC
commands
'SAVE/LOAD/VERIFY/MERGE SCREEN$'. The second entry point (#3020) is used for
the 'COPY'
command itself. Depending on the parameter following the 'SCREEN$', the normal
or the
grey scale screen dump is used.

301D DUMP_SCR$  POP  HL                  Drop the return address (within the
                                         routine which called 'EXPT_PARMS').
301E            JR   #3026,COPY_1        Jump forward.

3020 COPY       RST  #28,NEXT_C          Advance CH_ADD.
3021            CP   170,"SCREEN$"       Give 'Nonsense in G+DOS' error if
3023            JP   NZ,#1644,REP_0      command isn't followed by 'SCREEN$'.
3026 COPY_1     LD   A,49,"1"            Default is '1' for 'normal' dump.
3028            LD   (#3E00),A
302B            RST  #28,NEXT_C          Advance CH_ADD
302C            CP   13
302E            JR   Z,#3038,COPY_2      Jump with ENTER.
3030            CP   58,":"
3032            JR   Z,#3038,COPY_2      Also jump with ':'.
3034            LD   (#3E00),A           Otherwise store character.
3037            RST  #28,NEXT_C          Update CH_ADD again.
3038 COPY_2     CALL #3148,ST_END_RAM    Confirm end of statement and exit
                                         during syntax checking.
303B            LD   A,(#3E00)
303E            CP   49,"1"              Normal screendump if '1' followed the
3040            CALL Z,#12D2,COPS        'SCREEN$'.
3043            CP   50,"2"              Grey scale in case of a '2'.
3045            CALL Z,#133E,COPS2       Ignore other values.
3048            JP   #047C,END           Finished.
 ____________________________
|Previous|Next|Contents|Index|
###### 304b-sysmsg.html ######
###### 304b-sysmsg.html ######


 ____________________________
|Previous|Next|Contents|Index|
The system message routines

Finally there follow some messages. A message follows directly after the CALL
to the ROM
print routine.

304B MSG_0      CALL #178A,PO_MSG1
304E            DEFM "* MGT PLUS D DISC"
3060            DEFB " "+128
3061 MSG_1      CALL #178A,PO_MSG1
3064            DEFM " CATALOGUE *"
3070            DEFB 13,13+128
3072 MSG_2      CALL #178A,PO_MSG1
3075            DEFB 13,13
3077            DEFB "Number of Free K-Bytes ="
308F            DEFB " "+128
3090 MSG_3      CALL #177E,PO_MSG
3093            DEFM "©Miles Gordon Technology G+DOS2a"
30B3            DEFB 13,13+128

This routine makes sure the 'SOURCE' and 'TARGET' messages are printed in turn.

30B5 TO_MSG1    LD   A,(#3107)
30B8            XOR  #01
30BA            LD   (#3107),A
30BD            JR   NZ,#30E3,MSG_5
30BF MSG_4      CALL #178A,PO_MSG1
30C2            DEFB 13
30C3            DEFM "Insert SOURCE disc - press SPAC"
30E2            DEFB "E"+128
30E3 MSG_5      CALL #178A,PO_MSG1
30E6            DEFB 13
30E7            DEFM "Insert TARGET disc - press SPAC"
3106            DEFB "E"+128

3107            DEFB #00

THE 'CLEAR MESSAGE FLAG' SUBROUTINE

3108 TEST_SAVE  XOR  A                   Clear the flag used in printing
3109            LD   (#3107),A           'SOURCE' and 'TARGET' message.
310C            CALL #1635,TEST_5
310F            RET
 ____________________________
|Previous|Next|Contents|Index|
###### 3110-patches.html ######
###### 3110-patches.html ######


 ____________________________
|Previous|Next|Contents|Index|
The patches

THE 'OPENTYPE FILE OPEN/CLOSE' ROUTINE
This routine opens or closes an opentype file according to the contents of the
A
register. When it holds 0 a "D" channel is attached to the stream given in the
DFCA. A
non zero value closes the corresponding stream.

3110 OTFOC      AND  A
3111            JP   Z,#2CB3,OPEN_CHAN   Open a channel if A holds zero.
3114            JP   #2E5E,CLOSE_STRM    Otherwise close the stream.

THE 'CLOSE #' PATCH
This patch cures the bug related to CLOSEing 'OPENTYPE' files. Before the file
is CLOSEd
first the correct drive settings are send to the FDC.

3117 CL_PATCH   LD   E,(IX+17)           Fetch sector and track.
311A            LD   D,(IX+18)
311D            LD   A,(IX+11)           Fetch drive number.
3120            LD   (#3ACE),A
3123            CALL #071C,SET_DRVSD     Select track, sector, side and drive.
3126            CALL #0B89,CFSM          Close the file sector map.
3129            RET                      Finished.

THE 'OPEN TEMPORARY OUTPUT' PATCH
This patch gives an error report when an attempt is made to open an existing
OUTput file
using a command code. A jump back to the 'open a temporary channel' routine is
made if
not using a command code.

312A OP_T_PATCH PUSH HL
312B            LD   HL,(#2066)
312E            LD   A,H
312F            OR   L                   Jump back to the 'OP_TEMP' routine if
3130            POP  HL                  'D_ERR_SP' is zero (this isn't the
case
3131            JP   Z,#2D8F,OP_TEMP6    during command code execution).
3134            JP   #167C,REP_28        Otherwise give 'File NAME used' error.

THE 'NEW' PATCH
When the file copy command is finished the +D jumps to the 'NEW' routine. With
System 2a
a selection is made for 48K or 128K 'NEW'

3137 TO_NEW     BIT  4,(IY+1)            Jump if not in 128K mode HL contains
313B            JP   Z,#004F,UNPAGE_HL   #11B7, the address of 48K 'NEW'.
313E            CALL #5B00,SWAP          Call the paging subroutine of the 128.
3141            DI
3142            LD   BC,#00C7            Address of 128 'NEW' routine.
3145            JP   #0046,UNPAGE_BC

THE 'END OF STATEMENT' ROUTINE
It isn't clear why IX should point to #000C during syntax checking.

3148 ST_END_RAM LD   IX,#000C
314C            CALL #046E,ST_END
314F            LD   IX,#3AC3
3153            RET

THE 'PCAT' ROUTINE
This routine is called by using command code 67, in System 2a the command code
works.

3154 PCAT       CALL #0702,TEST_DRV      Drive defined?
3157            LD   A,(#3E10)           Get 'CAT' type.
315A            JP   #24B5,CAT_RUN       Do the CAT.

315D - 39FF Unused locations (all set to #00).
