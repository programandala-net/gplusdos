; Plus D Source

; The Z80 source of the Plus D ZX Spectrum interface, ROM and RAM.

; Original +D disassembly by:
; JRB, 2005-11,
; http://www.biehold.nl/rudy/plusd/plusd.htm.
;
; This edited version by:
; Marcos Cruz (programandala.net), 2016-03.

; Last modified: 201603062010

; ===============================================================
; Values

then_keyword  equ 203
poke_keyword  equ 244
run_keyword   equ 247

; ===============================================================
; The restart routines

; ----------------------------------------------
; THE 'POWER UP RESET' RESTART

; When the Spectrum is turned on or the reset button is pressed, the +D ROM is
; paged in at address 0, i.e. the routine listed here is executed.

POWER_UP
  NOP                      ;0000;
  LD   BC,$0101            ;0001;
  NOP                      ;0004;
  JP   POWER_UP2           ;0005; Sump to main routine.
  ; XXX FIXME -- why error `power_up2` is not defined?

; ----------------------------------------------
; THE 'USE G+DOS' RESTART

; This is the main entry point to the +D system; it is paged in when the Z80
; reaches address $0008, that is, the address of the 'main' ROM 'ERROR'
; routine.

START
  LD   HL,(23645)          ;0008; The address reached by the interpreter
  LD   (23647),HL          ;000B; (CH_ADD) is copied to the error pointer
  JR   START2              ;000E; (X_PTR) before proceeding.

; ----------------------------------------------
; THE 'CALL A MAIN ROM ROUTINE' RESTART

; This routine allows for a subroutine in the 'main' ROM to be called from the
; +D system. It can be called by using a RST $10 instruction, followed by the
; address of the 'main' ROM subroutine.

CALBAS
  JP   CALBAS_2            ;0010; Jump forward.

; ----------------------------------------------
; THE 'START_2' ROUTINE


START2
  JP   START_3             ;0013; Continue with the +D systems main
                                         ; entry routine.
  DEFB $00,$00             ;0016; Unused locations.

; ----------------------------------------------
; THE 'FLAGS ADDRESS' RESTART

; This routine is used by the -BIT- routines at address $15F4, the original HL
; is saved and the flags address is loaded into HL.

F_ADDR
  EX   (SP),HL             ;0018; Exchange RETurn address and HL.
  PUSH HL                  ;0019; Re-stack RETurn address.
  LD   HL,$3ACF            ;001A; Address of FLAGS3.
  RET                      ;001D;
  DEFB $00,$00             ;001E; Unused locations.

; ----------------------------------------------
; THE '+D ERROR' RESTART

; A RST $20 followed by a one-byte error code will print the appropriate
; message, when the error occurred during the execution of a command code
; however, the error code will be returned in the A register with the Carry
; flag set.

DISC_ERR
  LD   HL,(23645)          ;0020; The address reached by the interpreter
  LD   (23647),HL          ;0023; is copied to the error pointer before
  JR   DISC_ERR2           ;0026; proceeding.

; ----------------------------------------------
; THE 'NEXT CHAR' RESTART

; This routine gets the next character from a BASIC line, it does this by
; calling the RST $20 routine in the 'main' ROM.

NEXT_C
  RST  CALBAS              ;0028; Call 'main' ROM 'NEXT_CHAR'.
  DEFW NEXT_CHAR           ;0029;
  RET                      ;002B;

; ----------------------------------------------
; THE 'GET CHAR' ROUTINE

; Get character by calling the 'main' ROM restart.

GET_C
  RST  CALBAS              ;002C; Call 'main' ROM 'GET_CHAR'.
  DEFW GET_CHAR            ;002D;
  RET                      ;002F;

; ----------------------------------------------
; THE 'SYNTAX-Z' RESTART

; This corresponds to the 'main' ROM 'SYNTAX-Z' subroutine. A test of bit 7 of
; FLAGS will give the Zero flag set during syntax checking, and reset during
; execution.

SYNTAX_Z
  BIT  7,(IY+1)            ;0030; Test the runtime flag.
  RET                      ;0034;

; ----------------------------------------------
; THE 'DISC_ERR2' ROUTINE


DISC_ERR2
  JP   D_ERROR             ;0035; Continue with the +D error routine.

; ----------------------------------------------
; THE 'MASKABLE INTERRUPT' RESTART

; While the +D system is paged in, 'nothing' is done during an interrupt.

INT
  EI                       ;0038; Enable interrupts before RETurning.
  RET                      ;0039;

; ----------------------------------------------
; AN 'UNUSED' SUBROUTINE

; This is probably a piece of an older ROM version, it loads HL with (FRAMES)
; and CALLs another unused routine at $02E3.

  LD   HL,(23672)          ;003A; Get the two LSBs of FRAMES.
  CALL $02E3               ;003D;
  OUT  (231),A             ;0040; Page-out.
  DEFB $B5                 ;0042;
  DEFB $00,$00,$00         ;0043;

; ----------------------------------------------
; THE 'UNPAGE 128 ROM' SUBROUTINE

; This routine pages out the +D system and returns to the 128K ROM at address
; $0049. That address contains a RET instruction so the effect is a jump to BC
; with the 128K ROM paged in.

UNPAGE_BC
  PUSH BC                  ;0046; Stack return address.
UNPAGE_0
  OUT  (231),A             ;0047; Page out +D system.
  RET                      ;0049; ? This statement is not reached from
                                         ; above.
  DEFB $00,$00,$00,$00,$00 ;004A; Unused locations.

; ----------------------------------------------
; THE 'UNPAGE' SUBROUTINE

; This routine pages out the +D system and returns to the 'main' ROM at
; address $0052.  That address contains a RET instruction so the effect is a
; jump to HL with the 'main' ROM paged in.

UNPAGE_HL
  PUSH HL                  ;004F; Stack return address.
UNPAGE_1
  OUT  (231),A             ;0050; Page out +D system.
  RET                      ;0052;

; ===============================================================
; The Snapshot routines

; ----------------------------------------------
; THE 'NON-MASKABLE INTERRUPT' CONTINUED

; This piece of code determines whether the NMI button was pressed or a return
; from a CALBAS was made.

NMI_1
  LD   A,($3DE5)           ;0053;
  CP   $47                 ;0056; Check if returning from a CALBAS.
  JR   NZ,NMI_2            ;0058; Jump if not returning from a CALBAS.
  XOR  A                   ;005A;
  LD   ($3DE5),A           ;005B; Clear CALBAS executing.
  POP  AF                  ;005E; Restore A register and return to the
  RET                      ;005F; calling routine.
NMI_2
  LD   A,R                 ;0060;
  PUSH AF                  ;0062; Save R register and interrupt status.
  JR   SNAPSHOT            ;0063;
  DEFB $00                 ;0065;

; ----------------------------------------------
; THE 'NON-MASKABLE INTERRUPT' ROUTINE

; This is the third point, from address $0000, at which the +D system is paged
; in. It is reached  either by pressing the 'snapshot' button or when
; returning from a CALBAS.

NMI
  PUSH AF                  ;0066; Save A register.
  JR   NMI_1               ;0067;

; ----------------------------------------------
; THE 'SNAPSHOT' ROUTINE

; When the 'snapshot' button is pressed this routine is executed. By pressing
; the keys 1 or 2 a choice can be made to dump the screen to the printer in
; small or grey- scale format. As soon as the system file is loaded it is
; possible to make snapshots to disk (See $20A1 and further).

SNAPSHOT
  LD   ($3FFE),SP          ;0069; Use 'internal' stack.
  LD   SP,$3FFE            ;006D;
  LD   A,I                 ;0070;
  PUSH AF                  ;0072; Save all registers, starting with I.
  PUSH HL                  ;0073;
  PUSH BC                  ;0074;
  PUSH DE                  ;0075;
  EX   AF,AF'              ;0076; Save alternative registerset.
  EXX                      ;0077;
  PUSH AF                  ;0078;
  PUSH HL                  ;0079;
  PUSH BC                  ;007A;
  PUSH DE                  ;007B;
  PUSH IX                  ;007C; Save the index registers.
  PUSH IY                  ;007E;
  DI                       ;0080; Disable interrupts in case $0066 was
                                         ; called normally. When a NMI occurs the
                                         ; Z80 disables interrupts.
  LD   HL,SNAP_EXIT        ;0081;
  PUSH HL                  ;0084; RETurn address from snapshot.
  LD   ($2066),SP          ;0085; Store current stackpointer at D_ERR_SP
                                         ; so an error will activate SNAP_EXIT.
SNAP_KEYS
  LD   BC,$F7FE            ;0089; Keyboard port and key 1-5 I/O address.
  IN   E,(C)               ;008C;
  BIT  0,E                 ;008E; CASE key OF
  JP   Z,COPS              ;0090; 1: jump to the smallcopy routine.
  BIT  1,E                 ;0093;
  JP   Z,COPS2             ;0095; 2: jump to the greyscale routine.
  CALL SYSTEM_Z            ;0098; System loaded?
  CALL Z,JSNAP             ;009B; Yes, then call system snap routine.
  INC  A                   ;009E; END CASE.
  AND  $07                 ;009F;
  OUT  (C),A               ;00A1; Nice stripes in border.
  LD   B,$FE               ;00A3; CAPS-V I/O address.
  IN   E,(C)               ;00A5;
  BIT  2,E                 ;00A7;
  JR   NZ,SNAP_KEYS        ;00A9; Test for X, loop if not pressed.
SNAP_KEY1
  IN   E,(C)               ;00AB;
  BIT  2,E                 ;00AD;
  JR   Z,SNAP_KEY1         ;00AF; Wait until X is released again.

; ----------------------------------------------
; THE 'SNAP_EXIT' ROUTINE

; This routine is used to return to the snapshotted program.

SNAP_EXIT
  DI                       ;00B1;
  LD   HL,$0000            ;00B2; Clear D_ERR_SP.
  LD   ($2066),HL          ;00B5;
  CALL BORD_REST           ;00B8;
  LD   SP,$3FEA            ;00BB;
  POP  IY                  ;00BE; Restore the index registers.
  POP  IX                  ;00C0;
  POP  DE                  ;00C2; Restore the alternate registerset.
  POP  BC                  ;00C3;
  POP  HL                  ;00C4;
  POP  AF                  ;00C5;
  EX   AF,AF'              ;00C6;
  EXX                      ;00C7;
  CALL D_ROMBANK           ;00C8; Determine current 'main' ROM bank.
  JR   NZ,SNAP_EX3         ;00CB; Jump if 128K ROM bank.
  CALL REST_PBUF           ;00CD;
  POP  DE                  ;00D0; Restore the registerset.
  POP  BC                  ;00D1;
  POP  HL                  ;00D2;
  POP  AF                  ;00D3;
  LD   I,A                 ;00D4;
  CP   $00                 ;00D6;
  JR   Z,SNAP_EX1          ;00D8;
  CP   $3F                 ;00DA; When the I register doesn't contain $00
  JR   Z,SNAP_EX1          ;00DC; or $3F, it is most likely that the
  IM   2                   ;00DE; interrupt mode is 2.
SNAP_EX1
  LD   SP,($3FFE)          ;00E0; Restore stack pointer.
  POP  AF                  ;00E4;
  LD   R,A                 ;00E5; Jump if the interupts were disabled
  JP   PO,SNAP_EX2         ;00E7; when 'SNAPSHOT' was entered.
  PUSH HL                  ;00EA;
  LD   HL,$004F            ;00EB; Otherwise return to snapshotted program
  JP   UNPAGE_HL           ;00EE; via 'main' ROM "POP  HL", "POP  AF" and "EI".
SNAP_EX2
  POP  AF                  ;00F1; Return to the instruction before which
  JP   UNPAGE_1            ;00F2; the snapshot occurred.

; This piece of code does almost the same as the above. The only difference is
; that it returns to the 128 'main' ROM at a somewhat different address.

SNAP_EX3
  CALL REST_PBUF           ;00F5;
  POP  DE                  ;00F8;
  POP  BC                  ;00F9;
  POP  HL                  ;00FA;
  POP  AF                  ;00FB;
  LD   I,A                 ;00FC;
  CP   $00                 ;00FE;
  JR   Z,SNAP_EX4          ;0100;
  CP   $3F                 ;0102;
  JR   Z,SNAP_EX4          ;0104;
  IM   2                   ;0106;
SNAP_EX4
  LD   SP,($3FFE)          ;0108;
  POP  AF                  ;010C;
  LD   R,A                 ;010D;
  JP   PO,SNAP_EX5         ;010F;
  PUSH BC                  ;0112;
  LD   BC,$007B            ;0113;
  JP   UNPAGE_BC           ;0116;

SNAP_EX5
  POP  AF                  ;0119;
  JP   UNPAGE_0            ;011A;

; ----------------------------------------------
; THE 'DETERMINE 128K ROM BANK' SUBROUTINE

; This routine determines, by examining the byte at address $0001, which bank
; of the 128K ROM is selected. Because the +D system is currently paged in the
; 'main' ROM can't be accessed directly. So a routine, which pages out the +D,
; is copied to the printer buffer.  But first the first 10 bytes of the
; printer buffer are saved.

D_ROMBANK
  LD   HL,23296            ;011D; Save the 10 bytes needed by the
  LD   DE,$3BE6            ;0120; subroutine in +D RAM.
  LD   BC,10               ;0123;
  LDIR                     ;0126;
  LD   HL,DET_ROM          ;0128; Copy the subroutine to the freed bytes.
  LD   DE,DET_ROM_COPY     ;012B;
  LD   BC,10               ;012E;
  LDIR                     ;0131;
  LD   A,$47               ;0133; Signal 'CALBAS executing' (the NMI
  LD   ($3DE5),A           ;0135; routine returns immediately).
  JP   DET_ROM_COPY        ;0138; Exit via DET_ROM.


; ===============================================================
; The control routine

; This routine is called from 'START' at $0008, when the +D system is paged
; in.  It has three main tasks:
;
; - If a disc channel has been requested, it jumps to the required 'input' or
; 'output' routine.
;
; - If a hook/command code is used, it jumps to the required routine.
;
; - If an error occurred in the 'main' ROM, it checks whether a +D command was
; used. If so the corresponding routine is called, otherwise a return is made
; to the 'main' ROM, except when the +D variable ONERR holds a non zero
; address.  In that case a CALBAS to that address is made.

START_3
  LD   ($3DD6),HL          ;013B; +D's CH_ADD (D_CH_ADD).
  LD   ($3E4F),A           ;013E;
  POP  HL                  ;0141; Get RETurn address (usually points to
  PUSH HL                  ;0142; the error code).
  PUSH DE                  ;0143;

; Now see if a +D channel has been requested.

  AND  A                   ;0144;
  LD   DE,$15FE            ;0145; If a channel has been requested, this
                                         ; is the RETurn address stored by the
                                         ; CALL $162C in the 'CALL-SUB' subroutine
                                         ; in the Spectrum ROM.
  SBC  HL,DE               ;0148;
  POP  DE                  ;014A;
  JR   NZ,START_4          ;014B; Jump if no channels have been requested
  LD   HL,UNPAGE_1         ;014D; Make UNPAGE_1 RETurn address
  PUSH HL                  ;0150;

; Now see if the channel requested is the "P" channel. The +D "P" channel
; differs only from the Spectrum's in the 'input' and 'output' addresses. For
; the +D they both are $0008. There is no information in the channel on what
; the +D system's in/output addresses are (as with "D" channels). So it has to
; be handled separately.

  PUSH BC                  ;0151;
  LD   HL,(23631)          ;0152; Fetch CHANS.
  LD   BC,16               ;0155; Point to "P" channel.
  ADD  HL,BC               ;0158;
  SBC  HL,DE               ;0159; DE holds address of requested channel.
  POP  BC                  ;015B;
  JP   Z,PCHAN_OUT         ;015C; Jump if +D "P" channel was used.
  LD   HL,4                ;015F; DE holds address of routine pointer-4.
                                         ; See $15EF in 'main' ROM.
  ADD  HL,DE               ;0162; HL now holds address of routine pointer
  LD   E,(HL)              ;0163;
  INC  HL                  ;0164; Fetch routine address.
  LD   D,(HL)              ;0165;
  EX   DE,HL               ;0166; HL now points to the routine.
  JP   (HL)                ;0167; Jump to the appropriate 'input' or
                                         ; 'output' routine.

; At this point, the +D has been paged-in by an error in the 'main' ROM or by
; a hook/command code. When an error occurred during a CALBAS and D_ERR_SP
; isn't zero, the error has to be handled by the 'main' ROM. If D_ERR_SP is
; zero, the error is reported to the routine which executed a CALBAS.

START_4
  LD   A,($3DE5)           ;0168; Check if the +D CALLed a Spectrum
  CP   $47                 ;016B; ROM routine.
  JR   NZ,START_5          ;016D; Jump if it didn't.
  XOR  A                   ;016F;
  LD   ($3ACF),A           ;0170; Clear CALBAS executing.
  POP  HL                  ;0173; Fetch RETurn address.
  RST  CALBAS              ;0174; This CALL's a LD A,(HL) in the Spectrum
  DEFW $007B               ;0175; ROM, so the error code is fetched.
  LD   (23610),A           ;0177; Store the error code in ERR_NR.
  LD   HL,($2066)          ;017A; Fetch D_ERR_SP.
  LD   A,H                 ;017D;
  OR   L                   ;017E; Jump if D_ERR_SP was zero, that is when
  JP   Z,SPEC_ERR1         ;017F; the 'main' ROM has to handle the error.
  SET  7,(IY+0)            ;0182; Signal 'Spectrum error'.
  LD   A,(23610)           ;0186; Copy error code in A register.
  LD   SP,HL               ;0189; Clear stack.
  SCF                      ;018A; Signal 'error and exit', someone else
  RET                      ;018B; has to handle the error.

; Now it is most likely that the +D has to handle the problem which the 'main'
; ROM couldn't.

START_5
  POP  HL                  ;018C; Fetch address of error or hook/command
                                         ; code (the byte after RST $08).
  RST  CALBAS              ;018D; Fetch the byte.
  DEFW $007B               ;018E;
  LD   (23610),A           ;0190; Store it in ERR_NR.
  CP   255                 ;0193;
  JR   NZ,START_7          ;0195; Jump if the error isn't 'OK'.
  CALL SYSTEM_Z            ;0197; System loaded?
  CALL Z,SYSTEM_OK         ;019A; Yes, then check if it's OK.
  JR   Z,START_6           ;019D; Give 'OK G+DOS' message if so.
  BIT  7,(IY+12)           ;019F; Give the message also if PPC-hi
  JR   Z,START_6           ;01A3; indicates line is not in editing area.
  LD   HL,(23641)          ;01A5; Fetch the command from the editing area
  LD   A,(HL)              ;01A8;
  CP   run_keyword         ;01A9; 'RUN' command?
  JP   Z,RUN               ;01AB; Load the system file if the command is 'RUN'.
START_6
  JP   REP_20              ;01AE;

; The error code in the A register determines the task to be executed.

START_7
  SUB  27                  ;01B1; Adjust range, hookcodes start at 0 now.
  JR   C,START_8           ;01B3; Jump if it isn't a hook or command code
  CALL SYSTEM_Z            ;01B5; Jump to the system routine if the
  JP   Z,JHOOK             ;01B8; system is loaded.
  CP   44                  ;01BB; Give the error 'No G+DOS loaded' except
  JP   NZ,REP_29           ;01BD; with command code 71.
  LD   (IY+0),$FF          ;01C0; Clear the error.
  SET  2,(IY+1)            ;01C4;
  INC  HL                  ;01C8; Advance return address past the code.
  PUSH HL                  ;01C9;
  RET                      ;01CA;

START_8
  CP   240                 ;01CB; Jump if the error is
  JR   Z,TEST_INPUT        ;01CD; 'Nonsense in BASIC'.
  CP   243                 ;01CF;
  JR   Z,TEST_INPUT        ;01D1; Also if it is 'Invalid filename'.
  CP   252                 ;01D3;
  JR   Z,TEST_INPUT        ;01D5; Or 'Invalid stream'.
  CP   230                 ;01D7; Jump to the 'main' ROM error handler if
  JP   NZ,SPEC_ERR1        ;01D9; it isn't 'Variable not found'.
TEST_INPUT
  BIT  5,(IY+55)           ;01DC; Use 'main' ROM error handler also if in
  JP   NZ,SPEC_ERR1        ;01E0; INPUT mode.
  RST  SYNTAX_Z            ;01E3;
  JR   NZ,RUNTIME          ;01E4; Jump during RUNtime.
  LD   (IY+12),$FF         ;01E6; Signal 'syntax time' (PPC-hi).

; Now a loop is entered to find the line that has produced the error. The
; routine used here is copied from the IF1 and is way ahead of the DISCiPLE's
; backstepping routine.

RUNTIME
  LD   B,(IY+13)           ;01EA; Statement counter.
  LD   C,0                 ;01ED; Counter of ' " ' characters.
  BIT  7,(IY+12)           ;01EF; Jump forward if the line is in the
  JR   Z,PROG_LINE         ;01F3; program area.
  PUSH BC                  ;01F5; Save counters.
  RST  CALBAS              ;01F6; Call main ROM 'E-LINE-NO' (it fetches
  DEFW E_LINE_NO           ;01F7; the number of the line in the editing
                                         ; area, but is actually used to update
                                         ; CH-ADD to the 1st char.in the line).
  POP  BC                  ;01F9; Restore counters.
  RST  CALBAS              ;01FA; Update HL to the first character in
  DEFW GET_CHAR            ;01FB; the line.
  JR   S_STAT              ;01FD;

PROG_LINE
  LD   HL,(23635)          ;01FF; (PROG), start of the program area.
SC_L_LOOP
  LD   A,(IY+12)           ;0202; Give error if the current line number
  CP   (HL)                ;0205; is greater than that of the line to be
  JP   C,REP_0             ;0206; searched for.
  INC  HL                  ;0209; Point to low byte of line number.
  JR   NZ,LINE_LEN         ;020A; Jump if not at expected line.
  LD   A,(23621)           ;020C; Compare also the low byte of the line
  CP   (HL)                ;020F; numbers (PPC-lo).
  JP   C,REP_0             ;0210; Give error if the line doesn't exist.
LINE_LEN
  INC  HL                  ;0213; Fetch line length.
  LD   E,(HL)              ;0214;
  INC  HL                  ;0215;
  LD   D,(HL)              ;0216;
  INC  HL                  ;0217;
  JR   Z,S_STAT            ;0218; Jump forward if the line is found.
  ADD  HL,DE               ;021A;
  JR   SC_L_LOOP           ;021B; Next line.

SKIP_NUM
  LD   DE,6                ;021D; Length of a floating point number
  ADD  HL,DE               ;0220; and marker.

; This loop advances HL until it points to the start of the statement that has
; produced the error.

EACH_ST
  LD   A,(HL)              ;0221; Get a character from the line.
  CP   $0E                 ;0222;
  JR   Z,SKIP_NUM          ;0224; Skip over floating point numbers.
  INC  HL                  ;0226;
  CP   '"'                 ;0227;
  JR   NZ,CHKEND           ;0229;
  DEC  C                   ;022B; Decrement counter for each ' " '.
CHKEND
  CP   ":"                 ;022C;
  JR   Z,CHKEVEN           ;022E; A colon or the 'THEN' keyword
  CP   then_keyword        ;0230; mark the beginning of a new statement, but
  JR   NZ,CHKEND_L         ;0232; only if they occur out of a string.
CHKEVEN
  BIT  0,C                 ;0234; I.e. the number of quotes found must
  JR   Z,S_STAT            ;0236; be even.
CHKEND_L
  CP   13                  ;0238;
  JR   NZ,EACH_ST          ;023A; Repeat until 'end of line'.
  JP   REP_0               ;023C; An uneven number of quotes is
                                         ; unacceptable.
S_STAT
  DJNZ EACH_ST             ;023F; Loop for every statement in the line.
  DEC  HL                  ;0241; Update CH_ADD to the address of
  LD   (23645),HL          ;0242; the statement found.
  RST  SYNTAX_Z            ;0245;
  JR   NZ,CL_WORK          ;0246; Jump forward during runtime.
  BIT  7,(IY+12)           ;0248; Give an error if the line is not in the
  JP   Z,SPEC_ERR          ;024C; editing area.

; The final loop is made during syntax checking, for removing all 6-byte
; floating point numbers inserted in the line by the 'main' ROM interpreter.

  DEC  HL                  ;024F; Balance the "INC HL" below.
  LD   C,0                 ;0250; ???? C isn't used anymore.
RCLM_NUM
  INC  HL                  ;0252; Point to next character.
  LD   A,(HL)              ;0253;
  CP   $0E                 ;0254; Is it a 'number' marker ?
  JR   NZ,NEXT_NUM         ;0256; Jump if not.
  PUSH BC                  ;0258; ???? again.
  LD   BC,6                ;0259;
  RST  CALBAS              ;025C; Reclaim the 6 bytes forming a number
  DEFW RECLAIM_2           ;025D; and the 'number marker'.
  PUSH HL                  ;025F;
  LD   DE,($3DD6)          ;0260; Fetch D_CH_ADD.
  AND  A                   ;0264; Jump if the number bytes reclaimed were
  SBC  HL,DE               ;0265; after the character pointed to by
  JR   NC,NXT_1            ;0267; D_CH_ADD.
  EX   DE,HL               ;0269; Otherwise D_CH_ADD has to be updated.
  LD   BC,6                ;026A;
  AND  A                   ;026D; The character pointed by D_CH_ADD has
  SBC  HL,BC               ;026E; been moved '6' bytes down.
  LD   ($3DD6),HL          ;0270; Update D_CH_ADD.
NXT_1
  POP  HL                  ;0273;
  POP  BC                  ;0274;
NEXT_NUM
  LD   A,(HL)              ;0275;
  CP   13                  ;0276;
  JR   NZ,RCLM_NUM         ;0278; Again repeat until 'end of line'.

; Now the working area is cleared. The two commands 'RUN' and 'POKE' are
; handled by the +D ROM, the G+DOS system should handle all other commands.

CL_WORK
  RST  CALBAS              ;027A; Clear Spectrum work areas by calling
  DEFW SET_WORK            ;027B; 'SET_WORK' in 'main' ROM.
  RST  NEXT_C              ;027D;
  CP   poke_keyword        ;027E; 'POKE' keyword?
  JP   Z,poke_fetch        ;0280; Jump with 'POKE' command.
  CALL SYSTEM_Z            ;0283; The system routine is called when
  CALL Z,JCTRL             ;0286; present.
  JP   SPEC_ERR            ;0289; Otherwise give an error.

2843
  JR   Z,L82D1        ;028C;


; ===============================================================
; The periodic routines & The +D default variables and tables

; ----------------------------------------------
; THE 'KEY-SCAN' ROUTINE

; This is another entry point to the +D system; it is paged in when the Z80
; reaches address $028E, that is, the Spectrum 'KEY-SCAN' routine. So whenever
; the Spectrum tries to scan the keyboard by calling this routine the +D is
; paged in first.

KEYSCAN
  LD   L,$2F               ;028E; Same instruction as in 'main' ROM.
  CALL KEYSC_1             ;0290;
  NOP                      ;0293; Page-out into the 'main' ROM
  OUT  (231),A             ;0294; 'KEY_SCAN'.

KEYSC_1
  CALL KEYSC_2             ;0296;
  LD   L,$2F               ;0299; Restore registers for 'main' ROM
  LD   DE,$FFFF            ;029B; 'KEY-SCAN'
  LD   BC,$FEFE            ;029E;
  RET                      ;02A1;

KEYSC_2
  LD   A,($3DE5)           ;02A2;
  CP   $47                 ;02A5; If a CALBAS was under execution return
  RET  Z                   ;02A7; immediately to 'main' ROM 'KEY-SCAN'.
  LD   A,($3DE4)           ;02A8;
  CP   $58                 ;02AB;
  JP   Z,TAKE_PRTR         ;02AD; Jump if this is a minimal system.
  CP   $44                 ;02B0; Initialize the minimal system if there
  JR   NZ,NOSYS            ;02B2; is no system file loaded.
  CALL JKSCAN              ;02B4; Otherwise call the appropriate system
  JP   TAKE_PRTR           ;02B7; routine and exit refreshing the 'P'
                                         ; channel.

NOSYS
  LD   HL,$2000            ;02BA;
  LD   BC,8192             ;02BD; Clear the 8K RAM.
CLR_RAM
  LD   (HL),0              ;02C0;
  INC  HL                  ;02C2;
  DEC  BC                  ;02C3;
  LD   A,B                 ;02C4;
  OR   C                   ;02C5;
  JR   NZ,CLR_RAM          ;02C6;
  OUT  (239),A             ;02C8; Clear control port.
  OUT  (247),A             ;02CA; Clear printer port.
  LD   HL,$02F2            ;02CC; Copy the default system variables and
  LD   DE,$2000            ;02CF; settings to RAM.
  LD   BC,104              ;02D2;
  LDIR                     ;02D5;
  LD   A,$58               ;02D7; Signal 'minimal' system
  LD   ($3DE4),A           ;02D9;
  LD   HL,275              ;02DC; Disk buffer offset.
  LD   ($3AD2),HL          ;02DF;
  RET                      ;02E2;

  PUSH BC                  ;02E3; Leftover routine?
  PUSH DE                  ;02E4;
  PUSH HL                  ;02E5;
  CALL KEYSC_2             ;02E6;
  POP  HL                  ;02E9;
  INC  HL                  ;02EA;
  LD   (23672),HL          ;02EB;
  POP  DE                  ;02EE;
  POP  BC                  ;02EF;
  LD   A,H                 ;02F0;
  RET                      ;02F1;

; ----------------------------------------------
; THE 'SYSTEM VARIABLES'

; These variables hold various default settings for drives etc. They can be
; accessed from BASIC with POKE @p,n. Where p is 0 for RBCC at $2000. The
; default variables and system tables, addresses $02F2-$0359, are copied to
; $2000 if there is no system file loaded.

RBCC
  DEFB $00       ;02F2; @0        No flashing borders.
TRAKS1
  DEFB 80+128    ;02F3; @1        Drive 1 80 tracks double sided.
TRAKS2
  DEFB 80+128    ;02F4; @2        Drive 2 80 tracks double sided.
STPRAT
  DEFB 12        ;02F5; @3        "Steprate" 0 msec.
NSTAT
  DEFB 1         ;02F6; @4        Network off.
WIDTH
  DEFB 80        ;02F7; @5        Printer right margin.
PCODE
  DEFB 0         ;02F8; @6        Expand tokens, etc. before printing.
LSPCE
  DEFB 12        ;02F9; @7        Line spacing 12/72 inch.
LFEED
  DEFB 0         ;02FA; @8        Number of line feeds after CR 1.
LMARG
  DEFB 0         ;02FB; @9        Left margin at 0.
GRAPH
  DEFB 1         ;02FC; @10       Print graphic images of some chars.
ZXPNT
  DEFB 1         ;02FD; @11       +D printer port not used.
RESERVED
  DEFW $0000     ;02FE; @12
ONERR
  DEFW $0000     ;0301; @14       Address of routine called after an
                               ;           error has occurred.
EVERY_INT
  DEFW $0000     ;0303; @16       Address of routine called at every
                               ;           interrupt.

; ----------------------------------------------
; THE 'PRINTER CODES' TABLE

; Here the default printer control codes are stored.

INIT_PRT
  DEFB 13,$80,$80,$80      ;0304;
  DEFB $80,$80,$80,$80     ;0308;
CHAR_PITCH
  DEFB 27,"M",$80,$80      ;030C;
  DEFB $80,$80,$80,$80     ;0310;
N_per_72_LSPC
  DEFB 27,"A",$80,$80      ;0314;
  DEFB $80,$80,$80,$80     ;0318;
GRAPH_DPI
  DEFB 27,"*",5,$80        ;031C;
  DEFB $80,$80,$80,$80     ;0320;
INIT_PRT2
  DEFB $80,$80,$80,$80     ;0324;
  DEFB $80,$80,$80,$80     ;0328;

; ----------------------------------------------
; THE 'GRAPHIC REPRESENTATION' TABLE

; This table consists of the graphic representations of the £, # and (c)
; signs.  The 'GRAPH' system variable (@10) determines whether the normal code
; or the graphic representation is outputted to the printer.

; XXX TODO -- check why these data seems unused; there's an identical table at
; $203A

pound_sign_unused
  DEFB %00011000           ;032C;
  DEFB %00100000           ;032D;
  DEFB %00100000           ;032E;
  DEFB %01111000           ;032F;
  DEFB %00100000           ;0330;
  DEFB %00100000           ;0331;
  DEFB %01111100           ;0332;
  DEFB %00000000           ;0333;

hash_sign_unused
  DEFB %00000000           ;0334;
  DEFB %00100100           ;0335;
  DEFB %01111110           ;0336;
  DEFB %00100100           ;0337;
  DEFB %00100100           ;0338;
  DEFB %01111110           ;0339;
  DEFB %00100100           ;033A;
  DEFB %00000000           ;033B;

copyright_sign_unused
  DEFB %01111110           ;033C;
  DEFB %10000001           ;033D;
  DEFB %10111101           ;033E;
  DEFB %10100001           ;033F;
  DEFB %10100001           ;0340;
  DEFB %10111101           ;0341;
  DEFB %10000001           ;0342;
  DEFB %01111110           ;0343;

; ----------------------------------------------
; THE 'GREYSCALE' PRINTER CONTROL CODE

; This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

  DEFB 27,"*",5,64         ;0344;
  DEFB 2,$80,$80,$80       ;0348;

; ----------------------------------------------
; THE 'GREYSCALE' TABLE

; This table consists of three times three bytes of greyscale info. Each
; screen pixel is converted into 3x3 printer dots during greyscale printing.
; The printer dots are ordered as follows: The first dot row is produced from
; the first three bytes by taking the bit, which number is corresponding with
; the colour number, from each of the three bytes. E.g.  for colour 2 (=red)
; bit 2 is used. In the same way the second and third dot rows are produced
; from the second and third three bytes respectively.  The following eight 3x3
; matrices are produced:

 ; White  Yellow  Cyan  Green Magenta  Red    Blue  Black
 ;  000    000    100    000    100    010    110    111
 ;  000    010    010    101    111    111    111    111
 ;  000    000    001    000    001    010    011    111

; Note that some greytones aren't right. E.g. cyan is darker than green, which
; isn't so on the screen.

;                      colour
;                     76543210

  DEFB %00101011           ;034C;
  DEFB %00011111           ;034D; first row
  DEFB %00000001           ;034E;

  DEFB %00000111           ;034F;
  DEFB %01101111           ;0350; second row
  DEFB %00000111           ;0351;

  DEFB %00000001           ;0352;
  DEFB %00011111           ;0353; third
  DEFB %00101011           ;0354;

RAM2063
  DEFW P_ALL               ;0355; Address of 'output' routine for "P".
RAM2065
  DEFB $00                 ;0357; The 'ENTER' flag.
RAM2066
  DEFW $0000               ;0358; D_ERR_SP


; ===============================================================
; The initialise system routine

; ----------------------------------------------
; THE 'SYSTEM-FILE' NAME

; The following 11 bytes form the file description (directory description and
; filename) of a System-file.

SYS_DESCR
  DEFB 4                   ;035A;
  DEFM "+SYS*     "        ;035B;

; ----------------------------------------------
; THE '"AUTO*" FILE' UFIA

; The following 22 bytes form the UFIA of the autoload file, which is loaded
; right after the system file.

AUTO_UFIA
  DEFB $01                 ;0365; Drive 1
  DEFB $00                 ;0366;
  DEFB $00                 ;0367;
  DEFB "D"                 ;0368; Device "D"
  DEFB $01                 ;0369; Dir. entry for BASIC file.
  DEFM "AUTO*     "        ;036A; Name of autoload file.
  DEFB $00                 ;0374; File type is BASIC.
  DEFW $FFFF               ;0375; Max. length.
  DEFW $FFFF               ;0377;
  DEFW $FFFF               ;0379;

; ----------------------------------------------
; THE 'RUN' COMMAND ROUTINE

; The RUN command loads the system file.

RUN
  SET  7,(IY+10)           ;037B; Clear the 'jump' signal set by using
                                         ; the 'RUN' command.
  LD   IX,DFCA             ;037F;
  LD   A,1                 ;0383; Signal 'drive 1 is being used'.
  LD   (IX+11),A           ;0385;
  LD   A,1                 ;0388; Set drive 1.
  LD   ($3DDA),A           ;038A; Store it in the control port state.
  OUT  (239),A             ;038D; Activate.
  CALL REST                ;038F; Move drive head to track 0.
  LD   HL,SYS_DESCR        ;0392; Copy the file description to UFIA1.
  LD   DE,$3E05            ;0395;
  LD   BC,11               ;0398;
  LDIR                     ;039B;
  LD   A,%00001000         ;039D; Signal 'matching name and directory
                                         ; description have to be found'.
  CALL SCAN_CAT            ;039F; Search for the file.
  JP   NZ,REP_7            ;03A2; Give 'No "SYSTEM" file' error when file
                                         ; not found.
  RST  CALBAS              ;03A5; Clear the whole screen.
  DEFW CL_ALL              ;03A6;
  CALL MESG_0              ;03A8; Print the 'SYSTEM LOADING' message.
  CALL LOAD_1ST            ;03AB; Copy the file description (directory
                                         ; description and filename) to UFIA2 and
                                         ; load the first sector of the file into
                                         ; the disk buffer.
  LD   HL,$3BD6            ;03AE; Copy the file header (the 9 bytes
  LD   DE,$3E29            ;03B1; consisting of filetype, length, etc.)
  LD   BC,9                ;03B4; to UFIA2.
  LDIR                     ;03B7;
  LD   (IX+13),9           ;03B9; Update the buffer pointer.
  LD   DE,($3E2A)          ;03BD; Fetch the systemfile's length.
  LD   HL,$2000            ;03C1; Loadaddress is $2000.
  CALL LOAD_FILE           ;03C4; Load the system.
  LD   A,$44               ;03C7; Load the system.
  LD   ($3DE4),A           ;03C9; Signal 'System loaded'.
  XOR  A                   ;03CC;
  PUSH AF                  ;03CD;
  LD   HL,$2080            ;03CE;
  LD   BC,$197F            ;03D1; Calculate checksum.
RUN_CHKSUM
  POP  AF                  ;03D4;
  ADD  A,(HL)              ;03D5;
  PUSH AF                  ;03D6;
  INC  HL                  ;03D7;
  DEC  BC                  ;03D8;
  LD   A,B                 ;03D9;
  OR   C                   ;03DA;
  JR   NZ,RUN_CHKSUM       ;03DB;
  POP  AF                  ;03DD;
  LD   (HL),A              ;03DE;
  XOR  A                   ;03DF;
  LD   ($3ACF),A           ;03E0; Clear FLAGS3.
  LD   ($2066),A           ;03E3;
  RST  CALBAS              ;03E6; Clear the whole display.
  DEFW CL_ALL              ;03E7;
  CALL TAKE_PRTR           ;03E9; If necessary takeover the "P" channel.
  CALL JMSG3               ;03EC; Print DOS copyright message.
  CALL INIT_PRTR           ;03EF; If necessary initialize printer.
  LD   IX,AUTO_UFIA        ;03F2; Point to autoload file ufia.
  CALL JHXFER              ;03F6; Transfer UFIA to DFCA.
  LD   A,%00001000         ;03F9; Search for a file with specified name
  CALL SCAN_CAT            ;03FB; and type.
  JP   NZ,REP_20           ;03FE; "O.K. G+DOS" if no autoload file found
  CALL SIGN_4              ;0401; Signal 'loading'.
  JP   JLOAD               ;0404; Load the file.


; ===============================================================
; Miscalleneous routines I

; ----------------------------------------------
; THE '"P" CHANNEL DATA' TABLE

; Here follow the '5' bytes that compose the +D "P" channel.

P_CHANNEL
  DEFW $0008               ;0407;
  DEFW $0008               ;0409;
  DEFB "P"                 ;040B;

; ----------------------------------------------
; THE 'TAKEOVER PRINTER' SUBROUTINE

; If the printer is to be controlled by the +D system, the following
; subroutine copies the "P" channel data into the channel.

TAKE_PRTR
  CALL SYSTEM_Z            ;040C;
  CALL Z,JPRTR             ;040F;
  LD   A,($200B)           ;0412; (ZXPNT)
  BIT  0,A                 ;0415;
  RET  NZ                  ;0417; Return if the printer isn't to be
  AND  A                   ;0418; handled by the +D.
  CALL NZ,INIT_PRT1        ;0419; If necessary initialize printer.
  LD   HL,(23631)          ;041C; Get address of channel data. (CHANS)
  LD   BC,15               ;041F; Offset for channel "P".
  ADD  HL,BC               ;0422;
  EX   DE,HL               ;0423;
  LD   HL,P_CHANNEL        ;0424;
  LD   BC,5                ;0427;
  LDIR                     ;042A; Copy the "P" channel data.
  RET                      ;042C;

; ----------------------------------------------
; THE 'INIT PRINTER' SUBROUTINE

; This subroutine initialises the printer, if it's to be handled by the +D and
; if it's attached, by sending the initialisation codes and the permanent
; setting codes as mentioned in the 'Setup' program.

INIT_PRTR
  LD   A,($200B)           ;042D;
  BIT  0,A                 ;0430; Exit if printer not to be handled
  RET  NZ                  ;0432; by +D.
INIT_PRT1
  XOR  A                   ;0433;
  LD   ($200B),A           ;0434;
  IN   A,(247)             ;0437;
  BIT  7,A                 ;0439;
  RET  NZ                  ;043B; Exit if the printer is busy.
  LD   DE,INIT_PRT         ;043C; Send initialisation codes to printer.
  CALL PO_ESC_SEQ          ;043F;
  LD   DE,CHAR_PITCH       ;0442; Set character pitch.
  CALL PO_ESC_SEQ          ;0445;
  LD   DE,N_per_72_LSPC    ;0448; Set line spacing to ($2007)/72 inch.
  CALL PO_ESC_SEQ          ;044B;
  LD   A,($2007)           ;044E;
  CALL PNTP                ;0451;
  LD   DE,INIT_PRT2        ;0454; Set other permanent printer settings.
  JP   PO_ESC_SEQ          ;0457;

; ----------------------------------------------
; THE 'CHECK SYSTEM CHECKSUM' ROUTINE

; This subroutine calculates the checksum of the system file in RAM. Its is
; used to check if the system isn't corrupted.

SYSTEM_OK
  XOR  A                   ;045A;
  PUSH AF                  ;045B; Calculate checksum.
  LD   HL,$2080            ;045C;
  LD   BC,$197F            ;045F;
SYS_OK1
  POP  AF                  ;0462;
  ADD  A,(HL)              ;0463;
  PUSH AF                  ;0464;
  INC  HL                  ;0465;
  DEC  BC                  ;0466;
  LD   A,B                 ;0467;
  OR   C                   ;0468;
  JR   NZ,SYS_OK1          ;0469;
  POP  AF                  ;046B;
  CP   (HL)                ;046C; Exit with Zero set if checksums
  RET                      ;046D; match.

; ----------------------------------------------
; THE 'END OF STATEMENT' ROUTINE

; After the syntax of the 'new' commands has been checked, a jump is made here
; to confirm that the statement is finished. An error report is given if it
; isn't finished.  A return to the calling routine is made only during
; runtime, otherwise the control returns to the 'main' ROM interpreter.

ST_END
  CALL GET_C               ;046E; Get current character.
  CP   13                  ;0471;
  JR   Z,ST_END1           ;0473; Jump if the statement ends with ENTER.
  CP   ":"                 ;0475; Give an error if statement doesn't end
  JP   NZ,REP_2            ;0477; with a colon.
ST_END1
  RST  SYNTAX_Z            ;047A;
  RET  NZ                  ;047B; Return during runtime.

; ----------------------------------------------
; THE 'RETURN TO THE INTERPRETER' ROUTINE

; The control is returned to the BASIC interpreter for interpretation of the
; next statement.

END
  LD   SP,(23613)          ;047C; Clear machine stack. (ERR_SP)
  LD   (IY+0),$FF          ;0480; Clear error code. (ERR_NR)
  LD   HL,STMT_NEXT        ;0484; Return address to 'main' ROM is
  RST  SYNTAX_Z            ;0487; 'STMT_NEXT' if syntax is being checked.
  JP   Z,UNPAGE_HL         ;0488;
  CALL BORD_REST           ;048B; Restore border color.
  CALL TST_BREAK           ;048E; Test for BREAK.
  LD   HL,STMT_R_1         ;0491; Return address during runtime is
  JP   UNPAGE_HL           ;0494; 'STMT_R_1'.

; ----------------------------------------------
; THE 'TEST_BREAK' SUBROUTINE

; The BREAK key is checked and the appropriate error is given if it is
; pressed.

TST_BREAK
  LD   A,$7F               ;0497;
  IN   A,(254)             ;0499;
  RRA                      ;049B;
  RET  C                   ;049C; Return if SPACE wasn't pressed.
  LD   A,$FE               ;049D;
  IN   A,(254)             ;049F;
  RRA                      ;04A1;
  RET  C                   ;04A2; Return if CAPS wasn't pressed.
  JP   REP_3               ;04A3;

; ----------------------------------------------
; THE 'CALBAS_2' ROUTINE

; This routine calls the required 'main' ROM routine.

CALBAS_2
  LD   ($3AC5),DE          ;04A6; Free DE and HL.
  LD   ($3AC8),HL          ;04AA;
  POP  HL                  ;04AD; Get return address, points to address
  LD   E,(HL)              ;04AE; of 'main' ROM routine to be called.
  INC  HL                  ;04AF; Fetch address of routine to be called.
  LD   D,(HL)              ;04B0;
  INC  HL                  ;04B1;
  PUSH HL                  ;04B2; Restack return address.
  LD   HL,$3DE5            ;04B3;
  LD   (HL),$47            ;04B6; Signal 'CALBAS executing'.
  LD   HL,$0066            ;04B8; Return address to +D system is
  PUSH HL                  ;04BB; 'NMI_RAM'.
  PUSH DE                  ;04BC; Push address of routine to be called.
  LD   HL,($3AC8)          ;04BD; Restore HL and DE.
  LD   DE,($3AC5)          ;04C0;
  JP   UNPAGE_1            ;04C4; Do the CALBAS.

; ----------------------------------------------
; THE 'POKE @' COMMAND ROUTINE

; The POKE @ command allows a value between 0 and 255 to be stored in the +D
; system variables. But if the value is between 256 and 65535 the POKE @
; behaves as a DPOKE.  Because the +D system vars have a offset of $2000 (or
; 8192) this value has to be subtracted if the POKE @ is to be made directly
; to the given address. So POKE @60000-8192,1000 to DPOKE 60000,1000.

poke_fetch
  CALL SYSTEM_Z            ;04C7; Maybe there is an alternative routine
  CALL Z,JPOKE             ;04CA; in the system file.
  RST  NEXT_C              ;04CD; Get next character.
  CP   "@"                 ;04CE;
  JP   NZ,REP_0            ;04D0; If it isn't "@" give error.
  RST  CALBAS              ;04D3; Evaluate the two following numeric
  DEFW NEXT_2NUM           ;04D4; expressions.
  CALL ST_END              ;04D6; Confirm end of statement and exit
  RST  CALBAS              ;04D9; during syntax checking.
  DEFW FIND_INT2           ;04DA; Fetch value to be POKEd in BC.
  PUSH BC                  ;04DC;
  RST  CALBAS              ;04DD;
  DEFW FIND_INT2           ;04DE; Fetch POKE address.
  LD   HL,$2000            ;04E0; Offset for +D system variables.
  ADD  HL,BC               ;04E3;
  POP  BC                  ;04E4;
  LD   (HL),C              ;04E5; POKE address,low byte.
  LD   A,B                 ;04E6;
  AND  A                   ;04E7;
  JP   Z,END               ;04E8; Exit if 8 bit value.
  INC  HL                  ;04EB; Otherwise POKE address+1,high byte
  LD   (HL),B              ;04EC; before exiting.
  JP   END                 ;04ED;

; ----------------------------------------------
; THE 'SPECTRUM ERROR' ROUTINE

; This routine must be entered with the error code in (ERR_NR), and does the
; same as the 'main' ROM  'ERROR' restart, except when error messages are to
; be supressed.  This is indicated by a non zero value in 23728.

SPEC_ERR
  LD   HL,($3DD6)          ;04F0; Fetch D_CH_ADD.
  LD   (23645),HL          ;04F3; Restore CH_ADD.
  LD   (23647),HL          ;04F6; Restore X_PTR.
SPEC_ERR1
  LD   HL,$0058            ;04F9;
  RST  SYNTAX_Z            ;04FC; RETurn to $58, which is in ERROR_2, in
  JP   Z,UNPAGE_HL         ;04FD; the Spectrum ROM when checking syntax.
  LD   A,(23728)           ;0500;
  AND  A                   ;0503; Also RETurn to $58 in 'main' ROM when
  JP   Z,UNPAGE_HL         ;0504; error messages aren't to be supressed.
  SET  7,(IY+0)            ;0507; Otherwise signal 'Spectrum error'.
  LD   HL,STMT_R_1         ;050B; And RETurn to STMT_R_1 in the Spectrum
  JP   UNPAGE_HL           ;050E; ROM.

; ----------------------------------------------
; THE 'RESTORE PRINTER BUFFER' SUBROUTINE

; This subroutine restores the printer buffers 10 bytes which were destroyed
; by the 'D_ROMBANK' subroutine.

REST_PBUF
  LD   HL,$3BE6            ;0511;
  LD   DE,23296            ;0514;
  LD   BC,10               ;0517;
  LDIR                     ;051A;
  RET                      ;051C;

; ----------------------------------------------
; THE 'DETERMINE 48K OR 128K ROM' ROUTINE

; This small routine is copied to 23296, it returns with the Zero flag set if
; address $0001 in the 'main' ROM contains 175, that is when the 48K ROM bank
; is paged in.

  DET_ROM_COPY EQU 23296

DET_ROM
  OUT  (231),A             ;051D; Page +D out.
  LD   A,($0001)           ;051F;
  CP   175                 ;0522;
  JP   NMI                 ;0524; Page +D in.

; ----------------------------------------------
; THE 'SYSTEM_Z' SUBROUTINE

; This subroutine returns with the Zero flag set when the system file is
; present in RAM.

SYSTEM_Z
  LD   ($3DEA),A           ;0527;
  LD   A,($3DE4)           ;052A;
  CP   $44                 ;052D;
  LD   A,($3DEA)           ;052F;
  RET                      ;0532;

; ----------------------------------------------
; THE 'POWER_UP2' ROUTINE

; The routine continues, with the proper register contents, in the 'main' ROM
; 'START/NEW' routine.

POWER_UP2
  LD   A,$02               ;0533; Red instead of black border.
  OUT  (254),A             ;0535;
  LD   A,$3F               ;0537; Set interrupt vector.
  LD   I,A                 ;0539;
  NOP                      ;053B;
  NOP                      ;053C;
  NOP                      ;053D;
  NOP                      ;053E;
  NOP                      ;053F;
  NOP                      ;0540;
  NOP                      ;0541;
  NOP                      ;0542;
  LD   HL,$7FFF            ;0543; The stackpointer has to point into RAM,
  LD   SP,HL               ;0546; otherwise: trouble (for the
                                         ; UNPAGE_HL routine).
  IM   1                   ;0547; Set interrupt mode 1.
  XOR  A                   ;0549; Restore registers for 'main' ROM
  LD   DE,$FFFF            ;054A; 'START/NEW'.
  LD   HL,$11CB            ;054D;
  JP   UNPAGE_HL           ;0550; Jump to 'START/NEW' in the 'main' ROM.


; ===============================================================
; The disk routines

; ----------------------------------------------
; THE 'STORE INTERRUPT STATE' SUBROUTINE

; This subroutine stores the Interrupt Flip Flop of the Z80 and returns with
; interrupts disabled. Whenever the +D needs the interrupts to be disabled
; with disk operations the status of the IFF (DI or EI) is stored. When the
; disk operation is finished the IFF is restored to the state it was in before
; the interrupts were disabled.  NOTE: As a result of a bug in the Z80 itself
; the stored state of the IFF can be wrong if interrupts are enabled. The
; problem occurs when an interrupt is accepted (implying: interrupts enabled)
; during the execution of the 'LD A,R' or 'LD A,I' instruction. A solution to
; this problem is a second test if the IFF indicates interrupts disabled. With
; a Spectrum it is unlikely that two interrupts follow each other within a
; very short time, so a second test should cure the problem. A better method
; can be found in the 'Zilog Z80 Family Data Book'. The best method is
; replacing the Z80 with a CMOS version, the bug has been fixed in that Z80
; type.

STORE_IFF
  PUSH AF                  ;0553;
  LD   A,I                 ;0554; Set the P/V flag according to the state
  PUSH AF                  ;0556; of the IFF2.
  DI                       ;0557;
  EX   (SP),HL             ;0558; Get the Flag register in L while saving
                                         ; HL.
  LD   ($3E50),HL          ;0559; Store it. (IFF)
  POP  HL                  ;055C; Restore HL and AF.
  POP  AF                  ;055D;
  RET                      ;055E; Finished.

; ----------------------------------------------
; THE 'RESTORE INTERRUPT STATE' SUBROUTINE

; This subroutine restores the interrupt state to the original state (DI or
; EI) (see NOTE above).

REST_IFF
  PUSH AF                  ;055F; Save the contents of the needed
  PUSH HL                  ;0560; registers.
  LD   HL,($3E50)          ;0561; Fetch the previous IFF state.
  EX   (SP),HL             ;0564; Restore HL and store IFF state.
  POP  AF                  ;0565; The IFF state is now contained in the
                                         ; P/V flag.
  JP   PO,REST_IFF1        ;0566; Jump if interrupts were disabled.
  EI                       ;0569; Otherwise enable interrupts.
REST_IFF1
  POP  AF                  ;056A;
  RET                      ;056B; Finished.

; ----------------------------------------------
; THE 'WRITE PRECOMPENSATION' SUBROUTINE

; This subroutine is called before a write command is send to the Floppy Disk
; Controller (FDC). Its task is to enable write precompensation on the inner
; tracks to get a more reliable working of the data transfers. On entry C
; holds the FDC command.

PRECOMP
  LD   C,%10100010         ;056C; Write a single sector, enable spin-up
                                         ; sequence, no settling delay, disable
                                         ; precompensation, normal data mark.
PRECOMP1
  LD   B,64                ;056E; Start write precomp. at track 64.
  CALL DRV_CAP             ;0570; Get drive capacity in A.
  AND  $7F                 ;0573; Keep only the number of tracks.
  CP   80                  ;0575;
  JR   Z,PREC_1            ;0577; Jump if drive has 80 tracks.
  SRL  B                   ;0579; Otherwise precomp. starts at track 32.
PREC_1
  LD   A,D                 ;057B; Fetch current track.
  AND  B                   ;057C;
  JR   Z,PREC_2            ;057D; Jump if not at tracks above 63 or 31.
  RES  1,C                 ;057F; Otherwise enable write precompensation
                                         ; (reset bit 1 of the command).
PREC_2
  JP   LD_COM_REG          ;0581; Give the command to the FDC.

; ----------------------------------------------
; THE 'WRITE SECTOR' SUBROUTINE

; This subroutine writes the contents of the data buffer to sector E on track
; D.

WSAD
  XOR  A                   ;0584; Reset retry counter.
  LD   ($3DDB),A           ;0585;
WSAD_1
  CALL SET_TRKSEC          ;0588; Select drive, side, density and sector
                                         ; and position the head above the correct
                                         ; track.
  CALL PRECOMP             ;058B; Enable precompensation when neccesary
                                         ; and give the command to the FDC.
  CALL HL_BUFFER           ;058E; Make HL point to the data buffer.
  CALL WR_OP               ;0591; Write the sector.
  CALL SECTOR_ERR          ;0594; Check if there was an error, report it
                                         ; if retried often enough. Otherwise exit
  JR   WSAD_1              ;0597; Try again if no succes.

; ----------------------------------------------
; THE 'SEND DATA TO FDC' SUBROUTINE

; This subroutine handles the actual saving of a sector. It keeps sending a
; byte at a time to the FDC as long as it asks for one (sector length doesn't
; matter).

WR_OP
  CALL STORE_IFF           ;0599; Store maskable interrupt state and
                                         ; disable maskable interrupts.
  LD   BC,251              ;059C; BC holds the I/O port address of the
                                         ; data register of the FDC.
  JR   WR_TST_DRQ          ;059F; Jump into the save loop.

WR_LOOP
  OUTI                     ;05A1; Send a byte to the FDC (port BC) then
                                         ; increment HL (and decrement B).
  NOP                      ;05A3; Waste some time.
WR_TST_DRQ
  IN   A,(227)             ;05A4; Fetch FDC status.
  BIT  1,A                 ;05A6; Test Data ReQuest bit.
  JR   NZ,WR_LOOP          ;05A8; Jump if FDC requests a byte.
  IN   A,(227)             ;05AA; Otherwise fetch FDC status again.
  BIT  1,A                 ;05AC;
  JR   NZ,WR_LOOP          ;05AE; Jump if FDC requests a byte.
  IN   A,(227)             ;05B0;
  BIT  1,A                 ;05B2;
  JR   NZ,WR_LOOP          ;05B4;
  IN   A,(227)             ;05B6;
  BIT  1,A                 ;05B8;
  JR   NZ,WR_LOOP          ;05BA;
  BIT  0,A                 ;05BC; Test Busy bit.
  JR   NZ,WR_TST_DRQ       ;05BE; Repeat until FDC is ready.
  CALL REST_IFF            ;05C0; Restore the interrupt state.
  BIT  6,A                 ;05C3; Test Write Protected bit.
  RET  Z                   ;05C5; Return if not write protected.
  CALL DEC_MAPUSE          ;05C6; Decrease (MAPUSED), the number of files
                                         ; using the disk bitmap.
  JP   REP_23              ;05C9; Otherwise give 'Disc WRITE protected'
                                         ; error.

; ----------------------------------------------
; THE 'READ SECTOR' SUBROUTINE

; This subroutine loads the contents of the data buffer from sector E on track
; D.

RSAD
  XOR  A                   ;05CC; Clear retry counter.
  LD   ($3DDB),A           ;05CD;
RSAD_1
  CALL SET_TRKSEC          ;05D0; Set drive, side, density, sector and
                                         ; position the head above the correct
                                         ; track.
  LD   C,%10000000         ;05D3; Read a single sector, enable spin-up
                                         ; sequence, no settling delay.
  CALL LD_COM_REG          ;05D5; Give the command to the FDC.
  CALL HL_BUFFER           ;05D8; Make HL point to the data buffer.
  CALL RD_OP               ;05DB; Read the sector.
  CALL SECTOR_ERR          ;05DE; Check if there was an error, report it
                                         ; if retried often enough. Otherwise exit
  JR   RSAD_1              ;05E1; Try again if no succes.

; ----------------------------------------------
; THE 'GET DATA FROM FDC' SUBROUTINE

; This subroutine handles the actual loading of a sector. It keeps fetching a
; byte at a time from the FDC as long as it asks to get one (sector length
; doesn't matter).

RD_OP
  CALL STORE_IFF           ;05E3; Store the maskable interrupt state and
                                         ; disable interrupts.
  LD   BC,251              ;05E6; I/O address of the FDCs data register.
  JR   RD_TEST_DR      Q   ;05E9; Jump into the load loop.

RD_LOOP
  INI                      ;05EB; Get a byte from the FDC and increment
                                         ; HL (and decrement B).
  NOP                      ;05ED; Wait for a moment.
RD_TST_DRQ
  IN   A,(227)             ;05EE; Fetch FDC status.
  BIT  1,A                 ;05F0; Test Data ReQuest bit.
  JR   NZ,RD_LOOP          ;05F2; Jump if FDC has read a byte.
  IN   A,(227)             ;05F4; Otherwise fetch FDC status again.
  BIT  1,A                 ;05F6;
  JR   NZ,RD_LOOP          ;05F8; Jump if FDC has read a byte.
  IN   A,(227)             ;05FA;
  BIT  1,A                 ;05FC;
  JR   NZ,RD_LOOP          ;05FE;
  IN   A,(227)             ;0600;
  BIT  1,A                 ;0602;
  JR   NZ,RD_LOOP          ;0604;
  BIT  0,A                 ;0606; Test Busy bit.
  JR   NZ,RD_TST_DRQ       ;0608; Repeat until FDC is ready.
  JP   REST_IFF            ;060A; Restore interrupt state and exit.

; ----------------------------------------------
; THE 'CHECK SECTOR ERROR' SUBROUTINE

; This subroutine checks if the FDC reported an error, on entry A holds the
; FDC status byte. If there wasn't one HL points to the start of the data
; buffer and the RPT is reset.  If there was an positioning error the routine
; moves the head to the correct track. With other errors the head is
; repositioned above the current track, unless ten retries have been made,
; then an error is reported.

SECTOR_ERR
  AND  %00011100           ;060D; Mask the non error bits.
  JR   NZ,SEC_ERR1         ;060F; Jump with an error.
  CALL RES_RPT             ;0611; Otherwise reset the data buffer pointer
                                         ; (RPT).
  POP  HL                  ;0614; Drop return address and exit with
  JP   HL_BUFFER           ;0615; HL pointing to the data buffer.

SEC_ERR1
  PUSH AF                  ;0618; Save error.
  LD   A,($3DDB)           ;0619; Increment the retry counter.
  INC  A                   ;061C;
  LD   ($3DDB),A           ;061D;
  CP   10                  ;0620; If 10 retries have been made 'SECTOR
  JP   NC,REP_4            ;0622; error' is given.
  POP  AF                  ;0625;
  BIT  4,A                 ;0626;
  JR   NZ,SEC_ERR2         ;0628; Jump with positioning error.
  CALL STEP_IN             ;062A; Otherwise shake the the dust out of
  CALL STEP_OUT            ;062D; the drive.
  CALL STEP_OUT            ;0630;
  JP   STEP_IN             ;0633;

; The routine now checks whether the head is above the right track. The
; current tracknumber is found by reading the ID Field of the first
; encountered sector on this track. The track number is then stored into the
; track register of the FDC. When no ID Field can be found the retry counter
; is incremented, when this reaches 16 the 'FORMAT data lost' error is given.

SEC_ERR2
  LD   C,%11000000         ;0636; Read Address, disable spinup, no delay.
  CALL LD_COM_REG          ;0638; Execute the command.
  LD   HL,$3DDC            ;063B; Address where the ID Field is loaded.
  CALL RD_OP               ;063E; Get the six byte ID Field of the first
                                         ; sector encountered.
  AND  %00011100           ;0641;
  JR   NZ,SEC_ERR3         ;0643; Jump if there was an error.
  LD   A,($3DDC)           ;0645; Otherwise store the current track
  OUT  (235),A             ;0648; number into the FDC's track register.
  RET                      ;064A;
SEC_ERR3
  LD   A,($3DDB)           ;064B;
  INC  A                   ;064E; Increment retry counter.
  LD   ($3DDB),A           ;064F;
  CP   16                  ;0652; Give up if tried 16 times, 'FORMAT
  JP   Z,REP_5             ;0654; data lost'.
  CP   10                  ;0657;
  JR   NZ,SEC_ERR4         ;0659; After 10 times try something different.
  PUSH DE                  ;065B;
  CALL TRACK_0             ;065C; Start from the beginning of the disk.
  POP  DE                  ;065F;
  JR   SEC_ERR2            ;0660;
SEC_ERR4
  CALL STEP_IN             ;0662; Take one small step.
  JR   SEC_ERR2            ;0665; And retry again.

; ----------------------------------------------
; THE 'SET TRACK AND SECTOR' SUBROUTINE

; This subroutine is used to select the required drive, side, density, sector
; to be handled and to position the drive head above the required track.
; NOTE: The head is moved relative to the current position (fetched from the
; FDCs track register), when the drive selected is not the same as the
; previous one the +D can get confused.

SET_TRKSEC
  LD   A,D                 ;0667;
  OR   E                   ;0668;
  JR   NZ,SET_TRK1         ;0669; Jump if DE<>0.
  CALL TEST_2              ;066B; Test the .. flag.
  JP   Z,REP_27            ;066E; Give 'END of file' error when reset.
  LD   SP,($2066)          ;0671; Otherwise clear the machine stack.
  RET                      ;0675;
SET_TRK1
  CALL SET_DRVSD           ;0676; Select drive, side and density.
  LD   A,E                 ;0679; Store the required sector number into
  OUT  (243),A             ;067A; the FDC's sector register.
  CALL FLASH_REST          ;067C; Change the border colour when wanted.
SET_TRK2
  LD   A,D                 ;067F; Track to A.
  AND  $7F                 ;0680; Mask highest bit which indicates side.
  LD   B,A                 ;0682;
  CALL FDC_READY           ;0683; Wait until FDC is ready, test BREAK.
  IN   A,(235)             ;0686; Fetch contents of FDC's track register.
  CP   B                   ;0688; Compare against required track.
  RET  Z                   ;0689; Exit if already on right track.
  CALL NC,STEP_OUT         ;068A; Step out if required track lies
                                         ; outwards (more towards track 0).
  CALL C,STEP_IN           ;068D; Otherwise step in.
  JR   SET_TRK2            ;0690; Continue until on the right track.

; ----------------------------------------------
; THE 'STEP DELAY' SUBROUTINE

; This subroutine does the waiting between the executing of two step commands.
; By altering the value of the (STPRAT) system variabele (POKE @3,n) the time
; being waited can be altered.

STEP_DELAY
  LD   A,($2003)           ;0692; Fetch (STPRAT).
  AND  A                   ;0695;
STEP_D1
  RET  Z                   ;0696; Exit if 'msec-counter' reaches zero.
WAIT_1MSEC
  PUSH AF                  ;0697;
  LD   BC,135              ;0698; With this value the following loop
                                         ; takes 3505 T states (about 1msec) to
                                         ; complete.
WAIT_1M1
  DEC  BC                  ;069B;
  LD   A,B                 ;069C;
  OR   C                   ;069D;
  JR   NZ,WAIT_1M1         ;069E; Repeat until counter reaches zero.
  POP  AF                  ;06A0;
  DEC  A                   ;06A1; Decrease 'msec-counter'.
  JR   STEP_D1             ;06A2;

; ----------------------------------------------
; THE 'TRACK_0' SUBROUTINE

; This subroutine resets the head of the current drive to track 0. It has two
; entry points, the first is used by the ROM located routines, while the
; second (at $06B6) is used by the 'REST' command code (code 64 or $40). After
; the head has been resetted, a test is made whether there is a disk in the
; drive.

TRACK_0
  LD   A,($2003)           ;06A4;
  RLCA                     ;06A7; Double (STPRAT).
  LD   ($2003),A           ;06A8;
  CALL REST                ;06AB; Move head to track 0.
  LD   A,($2003)           ;06AE;
  RRCA                     ;06B1; Restore original (STPRAT) value.
  LD   ($2003),A           ;06B2;
  RET                      ;06B5;

REST
  LD   DE,$0001            ;06B6; Signal 'track 0, sector 1'.
  CALL SET_DRVSD           ;06B9; Set drive, side and density.

; The following code resets the drive head to track 0.

  LD   C,%11010000         ;06BC; Terminate all operations.
  CALL LD_COM_R1           ;06BE; Execute the FDC command.
  LD   B,0                 ;06C1; Wait about 1 msec.
REST_1
  DJNZ REST_1              ;06C3;

; The routine now checks whether there is a disk in the drive. The bug present
; in the DISCiPLE ROM is corrected, the +D doesn't wait forever for an INDEX
; pulse.

  LD   HL,0                ;06C5; The INDEX signal has to become low
                                         ; and high again within about 1.4 sec.
REST_2
  IN   A,(227)             ;06C8; Fetch FDC status.
  BIT  1,A                 ;06CA;
  CALL NZ,REST_5           ;06CC; Call if INDEX signal is high.
  JR   NZ,REST_2           ;06CF; Wait for it to become low.
REST_3
  IN   A,(227)             ;06D1; Fetch FDC status.
  CPL                      ;06D3; Invert the bits.
  BIT  1,A                 ;06D4;
  CALL NZ,REST_5           ;06D6; Call if INDEX signal is low.
  JR   NZ,REST_3           ;06D9; Wait for it to become high again.
REST_4
  IN   A,(227)             ;06DB; Fetch the FDC status register.
  BIT  2,A                 ;06DD;
  JR   NZ,FDC_READY        ;06DF; Exit if head is above track 0.
  CALL STEP_OUT            ;06E1; Otherwise, step-out and continue
  JR   REST_4              ;06E4; the loop.

; ----------------------------------------------
; THE 'WAIT UNTIL FDC IS READY' SUBROUTINE

; This small subroutine waits until the FDC is ready. When the BREAK key is
; pressed during the waiting, an error is reported.

FDC_READY
  IN   A,(227)             ;06E6; Fetch the FDC status.
  BIT  0,A                 ;06E8;
  RET  Z                   ;06EA; Exit if it's indicating 'FDC ready'.
  CALL TST_BREAK           ;06EB; Test for BREAK.
  JR   FDC_READY           ;06EE; Repeat until FDC is ready.

; ----------------------------------------------
; THE 'TRACK_0' ROUTINE CONTINUED


REST_5
  DEC  HL                  ;06F0; Decrease time limit.
  LD   A,H                 ;06F1;
  OR   L                   ;06F2;
  RET  NZ                  ;06F3; Return if limit isn't exceeded.
  JP   REP_6               ;06F4; Otherwise 'NO DISC in drive'.

; ----------------------------------------------
; THE 'LOAD FDC COMMAND REG.' SUBROUTINE

; This subroutine loads the FDC command register with the command held in the
; Z80's C register. The entry point 'LD_COM_R1' is used to give the 'terminate
; all operations' command to the FDC, it makes no sense to wait for the FDC to
; get ready if the current command is to be aborted.

LD_COM_REG
  CALL FDC_READY           ;06F7; Wait until FDC is ready, test BREAK.
LD_COM_R1
  LD   A,C                 ;06FA; Load the command in the FDC's command
  OUT  (227),A             ;06FB; register.
  LD   B,20                ;06FD; Wait for 73 µsec.
LD_COM_R2
  DJNZ LD_COM_R2           ;06FF; Waste some time.
  RET                      ;0701; Finished.

; ----------------------------------------------
; THE 'TEST DRIVE' SUBROUTINE

; This subroutine checks if the specified drive is defined (only if it's
; number isn't 1, then it is accepted right away). The entry point at $0702 is
; used when the drive is specified in UFIA1. The entry point at $0705 is used
; whenever the drive is specified in the A register. On exit (IX+11) holds the
; hardware representation of the drive to be used.

TEST_DRV
  LD   A,(UFIA1)           ;0702; Fetch drive number from UFIA1.
TEST_DRV1
  CP   1                   ;0705;
  JR   Z,TEST_DRV2         ;0707; Jump if drive one is to be used.
  CP   2                   ;0709; Otherwise give 'Wrong DRIVE' error if
  JP   NZ,REP_22           ;070B; drive isn't drive two.
  LD   A,($2002)           ;070E; Fetch (TRAKS2) system variable.
  CP   0                   ;0711;
  JP   Z,REP_22            ;0713; Give error if drive isn't defined.
  LD   A,2                 ;0716; Select drive two.
TEST_DRV2
  LD   (IX+11),A           ;0718; Store hardware representation.
  RET                      ;071B;

; ----------------------------------------------
; THE 'SET DRIVE PARAMETERS' SUBROUTINE

; This subroutine selects the drive, side and density by setting the right
; bits in the control port (I/O address 239).

SET_DRVSD
  LD   B,(IX+11)           ;071C; Fetch hardware drive representation.
  LD   A,($3DDA)           ;071F; Fetch current control port status.
  AND  %00000011           ;0722; Keep only drive 1&2 select bits.
  CP   B                   ;0724; Set Zero flag if drive isn't changed.
  PUSH AF                  ;0725;
  LD   A,($3DDA)           ;0726; Fetch current control port status
  AND  %01111100           ;0729; again. Mask drive and side select bits.
  LD   C,A                 ;072B; Store result temporary.
  LD   A,D                 ;072C; Fetch track.
  AND  %10000000           ;072D; Only keep side select.
  OR   B                   ;072F; Include drive select.
  OR   C                   ;0730; Include all other bits.
  LD   ($3DDA),A           ;0731; Set current control port status.
  OUT  (239),A             ;0734; Activate settings.
  POP  AF                  ;0736; Get Zero flag.
  RET  Z                   ;0737; Exit if drive hasn't changed.

; NOTE: This would have been a nice place to update the FDC's track register,
; it is very unlikely that both drives are on the same track all the time.

  LD   A,128               ;0738; Otherwise wait for 128 msec.
  JP   WAIT_1MSEC          ;073A; Exit via 'WAIT_1MSEC'.

; ----------------------------------------------
; THE 'PROGRAM NUMBER' SUBROUTINE

; This subroutine calculates the program number from track and sector number
; and the contents of RPT-high (which holds 0 for odd program numbers and 1
; for even ones). It is used to get the program number printed in the extended
; CATalogue.

PROG_NUM
  PUSH DE                  ;073D; Track and sector to BC.
  POP  BC                  ;073E;
  XOR  A                   ;073F; Clear A.
  DEC  B                   ;0740;
  JP   M,PROG_N2           ;0741; Jump with track 0, B now holds -1.
PROG_N1
  ADD  A,10                ;0744; Otherwise set A to 10*track number.
  DEC  B                   ;0746;
  JP   P,PROG_N1           ;0747; Repeat until B gets below zero.
PROG_N2
  LD   B,A                 ;074A;
  SLA  B                   ;074B; Otherwise double number of tens.
  SLA  C                   ;074D; Together with the next instruction the
  DEC  C                   ;074F; effect is 'INC C'.
  LD   A,(IX+14)           ;0750; Fetch high byte of RPT.
  ADD  A,C                 ;0753; Add adjusted sector.
  ADD  A,B                 ;0754; Add adjusted track.
  RET                      ;0755; Exit with A holding the program number.

; ----------------------------------------------
; THE 'SECT_END_Z' SUBROUTINE

; This subroutine returns with the Zero flag set if RPT has reached the sector
; end, that is if RPT points to the next track and sector numbers present in
; each sector.

SECT_END_Z
  CALL RPT_HL1             ;0756; Get RPT in HL and the disk buffer
  LD   A,C                 ;0759; position in BC.
  CP   254                 ;075A; Exit if disk buffer position 510 (or
  RET  NZ                  ;075C; 254) hasn't been reached, Zero reset.
  LD   A,B                 ;075D; Position 510 has to be reached before
  CP   1                   ;075E; returning with Zero set.
  RET                      ;0760;

; ----------------------------------------------
; THE 'SAVE A BYTE TO DISK' SUBROUTINE

; This subroutine saves the byte in A in the data buffer at the location
; pointed to by RPT (the disk buffer pointer). If the buffer is full, an
; automatic sector save to disk will take place, RPT will be reset to the
; start of the buffer and the value will then be saved.

SBYT
  PUSH BC                  ;0761;
  PUSH DE                  ;0762;
  PUSH HL                  ;0763;
  PUSH AF                  ;0764;
  CALL SECT_END_Z          ;0765; Check if the data buffer is full.
  JR   NZ,SBYT_1           ;0768; Jump if data buffer not full.
  CALL MK_ALLOC            ;076A; Allocate the first free sector.
  LD   (HL),D              ;076D; Store it's track and sector number into
  INC  HL                  ;076E; the last two bytes of the data buffer.
  LD   (HL),E              ;076F;
  EX   DE,HL               ;0770;
  CALL GET_SECTOR          ;0771; Fetch track and sector number of the
                                         ; current sector into DE, store the next
                                         ; track and sector number.
  CALL WSAD                ;0774; Write the sector to disk.
SBYT_1
  POP  AF                  ;0777;
  LD   (HL),A              ;0778; Store value.
  POP  HL                  ;0779;
  POP  DE                  ;077A;
  POP  BC                  ;077B;
  JP   INC_RPT             ;077C; Exit while increasing RPT.

; ----------------------------------------------
; THE 'LOAD A BYTE FROM DISK' SUBROUTINE

; This subroutine loads the byte pointed to by RPT from the data buffer, and
; returns with it in A and RPT updated. If the buffer is empty, another sector
; is read from the disk.

LBYT
  PUSH BC                  ;077F;
  PUSH DE                  ;0780;
  PUSH HL                  ;0781;
  CALL SECT_END_Z          ;0782; Check if the data buffer is empty.
  JR   NZ,LBYT_1           ;0785; Jump if data buffer not empty.
  LD   D,(HL)              ;0787; Otherwise fetch track and sector number
  INC  HL                  ;0788; of next sector into DE.
  LD   E,(HL)              ;0789;
  CALL RSAD                ;078A; Load the next sector.
LBYT_1
  LD   A,(HL)              ;078D; Get a byte.
  POP  HL                  ;078E;
  POP  DE                  ;078F;
  POP  BC                  ;0790;
  JP   INC_RPT             ;0791; Exit while increasing RPT.

; ----------------------------------------------
; THE 'LOAD FILE' ROUTINE

; This very important routine handles the loading of any file from disk. The
; entry point is at address $079E. On entry HL holds the load address, while
; DE holds the number of bytes to be loaded. The routine first empties the
; data buffer, which was loaded with the first sector to obtain the 9 byte
; file header. When the data buffer is empty the routine loads all sectors,
; but the last, into the memory directly. The last sector is loaded into the
; data buffer again and then the remaining bytes are loaded from it.

LD_BUF
  LD   A,(HL)              ;0794; Fetch a byte from the data buffer.
  CALL INC_RPT             ;0795; Increment RPT.
  LD   HL,($3AC8)          ;0798; Fetch load address.
  LD   (HL),A              ;079B; Load the byte into memory.
  INC  HL                  ;079C;
  DEC  DE                  ;079D;
LOAD_FILE
  LD   ($3AC8),HL          ;079E; Store load address into (FILEADDR).
  LD   A,D                 ;07A1;
  OR   E                   ;07A2;
  RET  Z                   ;07A3; Exit if no more bytes left.
LD_BUF1
  CALL SECT_END_Z          ;07A4; The data buffer has to be empty before
  JR   NZ,LD_BUF           ;07A7; sectors can be loaded directly into
                                         ; memory. Jump if data buffer not empty.
  LD   ($3AC5),DE          ;07A9; Store the number of bytes left to load
                                         ; into (BYTESLEFT).
  LD   D,(HL)              ;07AD; Fetch next track and sector.
  INC  HL                  ;07AE;
  LD   E,(HL)              ;07AF;
  CALL STO_BUFLEN          ;07B0; Store the data buffer length.
LD_OP
  CALL LAST_SEC_C          ;07B3; Check if this sector is the last one.
  JP   C,LD_LAST           ;07B6; Jump if last sector.
  INC  HL                  ;07B9; Balance the Carry flag subtracted in
                                         ; 'LAST_SEC_C'.
  LD   ($3AC5),HL          ;07BA; Store number of bytes left after this
                                         ; sector has been loaded.
  XOR  A                   ;07BD; Clear retry counter.
  LD   ($3DDB),A           ;07BE;
  CALL STORE_SEC           ;07C1; Store track and sector.
LD_AGAIN
  CALL SET_TRKSEC          ;07C4; Set drive, side, density, sector and
                                         ; track.
  LD   C,%10000000         ;07C7; Read a single sector, enable spin-up,
                                         ; no settling delay.
  CALL LD_COM_REG          ;07C9; Execute the FDC command.
  CALL STORE_IFF           ;07CC; Store interrupt state and disable.
  EXX                      ;07CF; HL' has to be rescued because the
  PUSH HL                  ;07D0; 'main' ROM needs it.
  LD   BC,251              ;07D1; I/O address of FDC's data register.
  LD   DE,2                ;07D4; DE' holds the length of the next sector
                                         ; address in each sector.
  CALL HL_BUFFER           ;07D7; HL' points to the data buffer.
  EXX                      ;07DA;
  LD   BC,251              ;07DB; I/O address of FDC's data register.
  LD   DE,($3ACA)          ;07DE; DE holds length of data buffer. DE +
                                         ; DE' hold the length of a sector.
  LD   HL,($3AC8)          ;07E2; HL holds the load address.
  JR   LD_TST_DRQ          ;07E5; Jump into the load loop.

LD_LOOP
  INI                      ;07E7; Get a byte from the FDC, increment HL.
  DEC  DE                  ;07E9; Decrement byte counter.
  LD   A,D                 ;07EA;
  OR   E                   ;07EB;
  JR   NZ,LD_TST_DRQ       ;07EC; Jump if not zero.
  EXX                      ;07EE; Otherwise select the other HL and DE.
LD_TST_DRQ
  IN   A,(227)             ;07EF; Fetch FDC status.
  BIT  1,A                 ;07F1; Test Data ReQuest bit.
  JR   NZ,LD_LOOP          ;07F3; Jump if FDC has read a byte.
  IN   A,(227)             ;07F5; Otherwise fetch FDC status again.
  BIT  1,A                 ;07F7;
  JR   NZ,LD_LOOP          ;07F9; Jump if FDC has read a byte.
  IN   A,(227)             ;07FB;
  BIT  1,A                 ;07FD;
  JR   NZ,LD_LOOP          ;07FF;
  IN   A,(227)             ;0801;
  BIT  1,A                 ;0803;
  JR   NZ,LD_LOOP          ;0805;
  BIT  0,A                 ;0807; Test Busy bit.
  JR   NZ,LD_TST_DRQ       ;0809; Repeat until FDC is ready.
  EXX                      ;080B; When the FDC is ready, DE and DE' both
  POP  HL                  ;080C; are 0, and the 'EXX' at $07EE has been
  EXX                      ;080D; executed twice, so to restore HL'
                                         ; a 'EXX' has to be executed first.
  CALL REST_IFF            ;080E; Restore interrupt state.
  AND  %00011100           ;0811; Mask non error bits of FDC status.
  JR   Z,LD_OK             ;0813; Jump with no errors.
  CALL FETCH_SEC           ;0815; Otherwise fetch track and sector again.
  CALL SEC_ERR1            ;0818; Check if there was a sector error.
  JR   LD_AGAIN            ;081B; Try to load the sector again.

; If there are no errors the next sector can be loaded.

LD_OK
  LD   ($3AC8),HL          ;081D; Store the load address into
(FILEADDR
  ).
  CALL HL_BUFFER           ;0820; Make HL point to the data buffer.
  LD   D,(HL)              ;0823; Fetch the next track and sector number.
  INC  HL                  ;0824;
  LD   E,(HL)              ;0825;
  JP   LD_OP               ;0826; Load the next sector.

; The last sector is loaded into the data buffer.

LD_LAST
  CALL RSAD                ;0829; Load the last sector.
  LD   DE,($3AC5)          ;082C; Fetch number of bytes left (BYTESLEFT)
  JP   LD_BUF1             ;0830; and copy them to 'main' RAM.

; ----------------------------------------------
; THE 'STORE BUFFER LENGTH' SUBROUTINE

; This subroutine stores the length of the data buffer into ($1ACA). Because
; the +D only uses double density this is always 510.

STO_BUFLEN
  LD   BC,510              ;0833; Length of DD data buffer.
  LD   ($3ACA),BC          ;0836; Store the length into (BUFLEN).
  RET                      ;083A;

; ----------------------------------------------
; THE 'LAST_SEC_C' SUBROUTINE

; This subroutine returns with the Carry flag set if the last sector is to be
; loaded.

LAST_SEC_C
  LD   HL,($3AC5)          ;083B; Fetch the number of bytes left to be
                                         ; loaded from (BYTESLEFT).
  LD   BC,($3ACA)          ;083E; Fetch the data buffer length from
                                         ; (BUFLEN).
  SCF                      ;0842; Set the Carry flag, now the Carry flag
                                         ; will be set after the 'SBC' if HL=BC.
  SBC  HL,BC               ;0843; Exit with Carry set signalling 'last
  RET                      ;0845; sector to be loaded'.

; ----------------------------------------------
; THE 'SAVE FILE' ROUTINE

; This is the opposite of the 'LOAD_FILE' routine above. The entry address is
; $0850, on entry HL holds the save address and DE holds the number of bytes
; to be saved.  The routine first fills up the data buffer, which contains the
; 9 byte file header already.  The data buffer is saved to disk, after which a
; sector address table is build for all but the last sector. All sectors, the
; addresses of which are contained in the table, are saved directly from
; memory. The last sector is saved into the data buffer again after which the
; file should be closed.

SA_BUF
  LD   (HL),D              ;0846; Save the byte in the data buffer.
  CALL INC_RPT             ;0847; Increment RPT.
  LD   HL,($3AC8)          ;084A; Fetch save address from (FILEADDR).
  INC  HL                  ;084D;
  POP  DE                  ;084E;
  DEC  DE                  ;084F;
HSVBK_2
  LD   A,D                 ;0850;
  OR   E                   ;0851;
  RET  Z                   ;0852; Exit if no more bytes to save.
  PUSH DE                  ;0853;
  LD   D,(HL)              ;0854; Fetch a byte from memory.
  LD   ($3AC8),HL          ;0855; Store save address into (FILEADDR).
  CALL SECT_END_Z          ;0858; The data buffer has to be full before
  JR   NZ,SA_BUF           ;085B; the sector can be saved. Jump if data
                                         ; buffer isn't full.
  POP  DE                  ;085D; Fetch number of bytes left to save and
  LD   ($3AC5),DE          ;085E; store it into (BYTESLEFT).
  CALL MK_ALLOC            ;0862; Allocate the first free sector.
  LD   (HL),D              ;0865; Store track and sector number into the
  INC  HL                  ;0866; data buffer.
  LD   (HL),E              ;0867;
  EX   DE,HL               ;0868;
  CALL GET_SECTOR          ;0869; Fetch track and sector number of the
                                         ; current sector in DE, store the next
                                         ; track and sector number.
  CALL WSAD                ;086C; Write the sector to disk.
  XOR  A                   ;086F; Clear sector counter.
  LD   ($3DEA),A           ;0870;
  CALL STO_BUFLEN          ;0873; Store the data buffer length.
  CALL LAST_SEC_C          ;0876; Check if this is the last sector.
  JP   C,SA_LAST           ;0879; Jump if it is.
  CALL HL_BUFFER           ;087C; HL points to the data buffer.
SA_ALLOC
  PUSH HL                  ;087F; Store data buffer address.
  CALL LAST_SEC_C          ;0880; Check if this is the last sector.
  PUSH HL                  ;0883; DE now holds the number of bytes left
  POP  DE                  ;0884; -1.
  POP  HL                  ;0885; Restore data buffer pointer.
  JR   C,SA_OP             ;0886; Jump if all but last sector allocated.
  INC  DE                  ;0888; Balance the Carry subtracted in
  LD   ($3AC5),DE          ;0889; 'LAST_SEC_C' before storing the number
                                         ; of bytes left into (BYTESLEFT).
  CALL MK_ALLOC            ;088D; Allocate a sector.
  LD   (HL),D              ;0890; Store its track and sector number into
  INC  HL                  ;0891; the data buffer.
  LD   (HL),E              ;0892;
  INC  HL                  ;0893;
  LD   A,($3DEA)           ;0894; Increase sector counter.
  INC  A                   ;0897;
  LD   ($3DEA),A           ;0898;
  JR   NZ,SA_ALLOC         ;089B; Repeat until all sectors have been
                                         ; allocated or the sector counter
                                         ; overflows.
SA_OP
  XOR  A                   ;089D; Reset retry counter.
  LD   ($3DDB),A           ;089E;
  CALL FETCH_SEC           ;08A1; Fetch the sector to be saved.
SA_AGAIN
  CALL SET_TRKSEC          ;08A4; Set drive, side, etc.
  CALL PRECOMP             ;08A7; Enable precompensation when neccesary
                                         ; and execute the write sector command.
  CALL STORE_IFF           ;08AA; Store interrupt state and disable.
  EXX                      ;08AD; HL' has to be stored because the
  PUSH HL                  ;08AE; 'main' ROM needs it.
  CALL RPT_HL1             ;08AF; HL' points to the sector address
                                         ; table, build up in the data buffer.
  LD   DE,2                ;08B2; DE' holds the length of the next
                                         ; sector address in each sector.
  LD   BC,251              ;08B5; BC' holds the I/O address of the FDC's
                                         ; data register.
  EXX                      ;08B8;
  LD   HL,($3AC8)          ;08B9; HL holds the save address.
  LD   DE,($3ACA)          ;08BC; DE holds the length of the data space
                                         ; inside a sector. DE+DE' hold the
                                         ; length of a complete sector.
  LD   BC,251              ;08C0; BC holds the same as BC'.
  JR   SA_TST_DRQ          ;08C3; Jump into the save loop.

SA_LOOP
  OUTI                     ;08C5; Send a byte to the FDC, increment HL.
  DEC  DE                  ;08C7; Decrement byte counter.
  LD   A,D                 ;08C8;
  OR   E                   ;08C9;
  JR   NZ,SA_TST_DRQ       ;08CA; Jump if not zero.
  EXX                      ;08CC; Otherwise select the other HL and DE.
SA_TST_DRQ
  IN   A,(227)             ;08CD; Fetch FDC status.
  BIT  1,A                 ;08CF; Test Data ReQuest bit.
  JR   NZ,SA_LOOP          ;08D1; Jump if FDC requests a byte.
  IN   A,(227)             ;08D3; Otherwise fetch FDC status again.
  BIT  1,A                 ;08D5;
  JR   NZ,SA_LOOP          ;08D7; Jump if FDC requests a byte.
  IN   A,(227)             ;08D9;
  BIT  1,A                 ;08DB;
  JR   NZ,SA_LOOP          ;08DD;
  IN   A,(227)             ;08DF;
  BIT  1,A                 ;08E1;
  JR   NZ,SA_LOOP          ;08E3;
  BIT  0,A                 ;08E5; Test Busy bit.
  JR   NZ,SA_TST_DRQ       ;08E7; Repeat until FDC is ready.
  CALL REST_IFF            ;08E9; Restore interrupt state.
  AND  %00011100           ;08EC; Mask non error bits of FDC status.
  JR   Z,SA_OK             ;08EE; Jump with no errors.
  EXX                      ;08F0;
  POP  HL                  ;08F1; Restore HL'.
  EXX                      ;08F2;
  CALL FETCH_SEC           ;08F3; Fetch track and sector again.
  CALL SEC_ERR1            ;08F6; Check if there was a sector error.
  JR   SA_AGAIN            ;08F9; Try to save the sector again.

; If there are no errors the next sector can be saved, but first its track and
; sector number have to be retrieved.

SA_OK
  LD   ($3AC8),HL          ;08FB; Store the save address into (FILEADDR)
  EXX                      ;08FE;
  DEC  HL                  ;08FF; Fetch track and sector number of next
  LD   E,(HL)              ;0900; sector.
  DEC  HL                  ;0901;
  LD   D,(HL)              ;0902;
  CALL INC_RPT             ;0903; Update RPT.
  CALL INC_RPT             ;0906;
  CALL STORE_SEC           ;0909; Store the next sector's track and
                                         ; sector number.
  POP  HL                  ;090C; Restore HL'.
  EXX                      ;090D;
  LD   A,($3DEA)           ;090E; Decrease sector counter.
  DEC  A                   ;0911;
  LD   ($3DEA),A           ;0912; Save the next sector as long as it
  JP   NZ,SA_OP            ;0915; isn't the last one.
SA_LAST
  CALL RES_RPT             ;0918; The bytes of the last sector are saved
  LD   DE,($3AC5)          ;091B; into the data buffer again. Fetch the
  LD   HL,($3AC8)          ;091F; number of bytes left and the save
  JP   HSVBK_2             ;0922; address. Then save the bytes into the
                                         ; data buffer.

; ----------------------------------------------
; THE 'ALLOCATE SECTOR' SUBROUTINE

; This subroutine allocates the first free sector, which track and sector
; number are returned in the DE register pair. The routine searches the disk
; bitmap at $1A00 for a free sector, if there isn't one an error is reported.

MK_ALLOC
  PUSH HL                  ;0925;
  PUSH BC                  ;0926;
  LD   HL,$3A00            ;0927; Address where disk bitmap is located.
  LD   DE,$0401            ;092A; Start with track 4, sector 1.
  LD   C,0                 ;092D; Clear bitmap offset.
MK_ALL1
  LD   A,(HL)              ;092F;
  CP   $FF                 ;0930;
  JR   NZ,MK_ALL3          ;0932; Jump if there is a free sector here.
  LD   A,E                 ;0934; Otherwise update sector number.
  ADD  A,8                 ;0935; Each byte holds 8 sectors.
  LD   E,A                 ;0937;
  SUB  10                  ;0938; But each track holds 10.
  JR   C,MK_ALL2           ;093A; Jump if still on the same track, i.e.
  JR   Z,MK_ALL2           ;093C; with sectors <=9 and 10.
  LD   E,A                 ;093E; Otherwise the next sector has been
  CALL NEXT_TRACK          ;093F; computed, next track is computed now.
MK_ALL2
  INC  C                   ;0942; Increase bitmap offset.
  INC  HL                  ;0943; Next byte of bitmap.
  JR   MK_ALL1             ;0944; Find a free sector.

; Now the routine continues to find which sector is free.

MK_ALL3
  LD   B,1                 ;0946; Reset bit pointer.
MK_ALL4
  LD   A,(HL)              ;0948;
  AND  B                   ;0949;
  JR   Z,MK_ALLOC5         ;094A; Jump if free sector has been found.
  CALL NEXT_SEC            ;094C; Increase sector number.
  CALL Z,NEXT_TRACK        ;094F; Next track if sector is on it.
  RLC  B                   ;0952; Test next sector.
  JR   MK_ALL4             ;0954;

; ----------------------------------------------
; THE 'NEXT TRACK' SUBROUTINE

; This subroutine checks whether the next track (current track held in D)
; still exists and returns holding the next track in D when it does exist. If
; the drive capacity is exceeded, the 'Not enough SPACE on disc' error is
; given.

NEXT_TRACK
  INC  D                   ;0956; Increase track.
  CALL DRV_CAP             ;0957; Get number of tracks on current drive
                                         ; in the A register.
  CP   D                   ;095A; Decrement 'number of files using the
  CALL Z,DEC_MAPUSE        ;095B; disk bitmap' and give an error if
  JP   Z,REP_24            ;095E; drive capacity is exceeded.
  AND  $7F                 ;0961; Mask off side bit.
  CP   D                   ;0963;
  RET  NZ                  ;0964; Return if side 0 isn't full.
  LD   D,128               ;0965; Otherwise return with track 0, side 1.
  RET                      ;0967;

; ----------------------------------------------
; THE 'ALLOCATE SECTOR' ROUTINE CONTINUED

; Now the 'ALLOCATE SECTOR' routine continues by unfreeing the found sector.

MK_ALL5
  LD   A,(HL)              ;0968; Make found sector unfree in disk
  OR   B                   ;0969; bitmap.
  LD   (HL),A              ;096A;
  LD   A,B                 ;096B;
  LD   B,0                 ;096C;
  PUSH IX                  ;096E;
  ADD  IX,BC               ;0970; Add bitmap offset.
  OR   (IX+34)             ;0972; Set new sector in file bitmap.
  LD   (IX+34),A           ;0975;
  POP  IX                  ;0978; Restore disk channel pointer.
  INC  (IX+31)             ;097A; Increment number of sectors used.
  JR   NZ,MK_ALL6          ;097D;
  INC  (IX+30)             ;097F;
MK_ALL6
  POP  BC                  ;0982;
  POP  HL                  ;0983;
  RET                      ;0984; Finished.

; ----------------------------------------------
; THE 'GET DRIVE CAPACITY' SUBROUTINE

; This small subroutine returns with the A register holding the capacity of
; the selected drive, as found in the system variables.

DRV_CAP
  PUSH HL                  ;0985;
  LD   HL,$2001            ;0986; This is TRAKS1, drive 1's capacity.
  LD   A,($3DDA)           ;0989; Fetch current control port state.
  BIT  0,A                 ;098C;
  JR   NZ,DRV_CAP1         ;098E; Jump if drive 1 selected.
  INC  HL                  ;0990; Otherwise point to TRAKS2.
DRV_CAP1
  LD   A,(HL)              ;0991; Fetch drive capacity.
  POP  HL                  ;0992;
  RET                      ;0993; Finished.

; ----------------------------------------------
; THE 'PRINT NAME' SUBROUTINE

; This subroutine is used to print the name of a file during a 'CAT' command
; and when the 'overwrite' message is printed.

PRT_NAME
  LD   (IX+13),1           ;0994; Point to the first character of the
                                         ; name.
  CALL RPT_HL1             ;0998; Make HL point to it.
  LD   B,10                ;099B; A name has 10 characters.
PRT_NAM1
  LD   A,(HL)              ;099D; Fetch a character.
  CALL PRT_A               ;099E; Print it.
  INC  HL                  ;09A1;
  DJNZ PRT_NAM1            ;09A2; Repeat for all 10 characters.
  RET                      ;09A4;

; ----------------------------------------------
; THE 'SCAN CATALOGUE' SUBROUTINE

; This very important subroutine scans the CATalogue of a disk, whether this
; is for a free entry, a matching filename, or for printing the directory. On
; entry all needed parameters other than the A register should be contained in
; UFIA1. The A register determines where to scan for as follows:
;
; (bits set)
;
; - bit 0 : Search for the file with the specified program number.
;
; - bit 1 : Print a 'names only' CATalogue to the current stream. A filename
; must be specified.
;
; - bit 2 : Print an 'extended' CATalogue to the current stream. A filename
; has to be specified.
;
; - bit 3 : Search for a file with the specified type and name.
;
; - bit 4 : Search for a file with the specified filename.
;
; - bit 5 : Produce the disk bitmap.
;
; - bit 6 : Find the first unused entry.  Note that some functions exclude
; others. A return is made with DE holding the track and sector number of the
; found entry, the data buffer holding the sector, RPT pointing to the entry
; and the Zero flag signalling 'success' when set.

SCAN_CAT
  LD   IX,DFCA             ;09A5;
  LD   (IX+4),A            ;09A9; Store scan-type.
  XOR  A                   ;09AC; Clear column counter.
  LD   ($3DEB),A           ;09AD;
  CALL REST                ;09B0; Reset drive head to track 0, DE = 1.
EACH_ENTRY
  CALL RSAD                ;09B3; Load a CATalogue sector.
EACH_E1
  CALL RPT_HL              ;09B6; HL points to the start of data buffer.
  LD   A,(HL)              ;09B9; Fetch file type.
  AND  A                   ;09BA; Jump if it's an unused entry (could be
  JP   Z,SCAN_FREE         ;09BB; ERASEd).
  BIT  0,(IX+4)            ;09BE;
  JR   Z,NO_PRGNUM         ;09C2; Jump if not searching for a filenumber
  CALL PROG_NUM            ;09C4; Otherwise load program number into A.
  LD   B,A                 ;09C7;
  LD   A,($3E02)           ;09C8; Fetch specified program number.
  CP   B                   ;09CB;
  RET  Z                   ;09CC; Exit if they are equal.
  JP   SCAN_NEXT           ;09CD; Otherwise continue scanning.

; NOTE: All entries with numbers below the specified one are considered, this
; isn't really needed.

NO_PRGNUM
  BIT  1,(IX+4)            ;09D0; Jump if a short CATalogue should be
  JR   NZ,PRINT_CAT        ;09D4; printed.
  BIT  2,(IX+4)            ;09D6;
  JR   Z,NO_CAT            ;09DA; Jump if no CATalogue is desired.
PRINT_CAT
  LD   (IX+13),11          ;09DC; RPT points to number of sectors used.
  CALL RPT_HL1             ;09E0; Make HL hold RPT.
  LD   B,(HL)              ;09E3; Fetch number of sectors used.
  INC  HL                  ;09E4;
  LD   C,(HL)              ;09E5;
  LD   (DFCA),BC           ;09E6; Store it for printing.
  LD   HL,($3DD8)          ;09EA; Add it to total number of sectors used
  ADD  HL,BC               ;09ED;
  LD   ($3DD8),HL          ;09EE;
  BIT  7,A                 ;09F1;
  JP   NZ,SCAN_NEXT        ;09F3; Jump if this entry is hidden.
  CALL MATCH_NAME          ;09F6;
  JP   NZ,SCAN_NEXT        ;09F9; Jump if filename doesn't match.
  BIT  1,(IX+4)            ;09FC;
  JR   NZ,SCAN_1           ;0A00; Jump with short CAT.
  CALL PROG_NUM            ;0A02; Calculate program number.
  PUSH DE                  ;0A05;
  LD   H,0                 ;0A06; Program number to HL.
  LD   L,A                 ;0A08;
  LD   A,32                ;0A09; Use leading spaces.
  CALL PRT_N10             ;0A0B; Print the program number.
  POP  DE                  ;0A0E; Restore sector address.
  CALL PRT_SPACE           ;0A0F; Print a space.
SCAN_1
  CALL PRT_NAME            ;0A12; Print filename.
  BIT  1,(IX+4)            ;0A15;
  JR   Z,EXT_CAT           ;0A19; Jump with extended CAT.
  LD   B,3                 ;0A1B; Otherwise print three columns wide.
  LD   A,($3E03)           ;0A1D; Except when using stream 3.
  CP   3                   ;0A20;
  JR   NZ,SCAN_2           ;0A22;
  SLA  B                   ;0A24; Then print six columns wide.
SCAN_2
  LD   A,($3DEB)           ;0A26; Increment column counter.
  INC  A                   ;0A29;
  CP   B                   ;0A2A;
  JR   Z,SCAN_3            ;0A2B; Jump if last column reached.
  LD   ($3DEB),A           ;0A2D; Otherwise store column counter and
  LD   A,32                ;0A30; separate the columns with a SPACE.
  JR   SCAN_4              ;0A32;

; This line is full, the next entry will be printed on the next line.

SCAN_3
  XOR  A                   ;0A34; Clear column counter.
  LD   ($3DEB),A           ;0A35;
  LD   A,13                ;0A38; Print a NEWLINE.
SCAN_4
  CALL PRT_A               ;0A3A;
  JR   SCAN_NEXT           ;0A3D; Continue with the next entry.

; With an extended CAT there has to be printed somewhat more.

EXT_CAT
  PUSH DE                  ;0A3F; Store track and sector number.
  LD   HL,(DFCA)           ;0A40; Fetch length of file in sectors.
  LD   A,32                ;0A43; Print it with leading spaces.
  CALL PRT_N100            ;0A45;
  CALL PRT_SPACE           ;0A48; Print a trailing space.
  CALL RPT_HL              ;0A4B; HL points to the start of the entry.
  LD   A,(HL)              ;0A4E; Fetch file type
  CALL PRT_TYPE            ;0A4F; and print it.
  POP  DE                  ;0A52; Restore track and sector number.
  JR   SCAN_NEXT           ;0A53; Continue with the next entry.

; Now the routine continues with the search part.

NO_CAT
  BIT  3,(IX+4)            ;0A55;
  JR   NZ,SCAN_NAME        ;0A59; Jump if searching for name and type.
  BIT  4,(IX+4)            ;0A5B;
  JR   Z,SCAN_5            ;0A5F; Jump if not searching for name alone.
SCAN_NAME
  CALL MATCH_NAME          ;0A61; Return with Zero flag set to signal
  RET  Z                   ;0A64; 'matching name (and type) found'.
SCAN_5
  BIT  5,(IX+4)            ;0A65;
  JR   Z,SCAN_NEXT         ;0A69; Jump if no disk map wanted.

; This part of the routine builds up the bitmap.

  PUSH IX                  ;0A6B;
  LD   (IX+13),15          ;0A6D; RPT points to the start of file bitmap
  CALL RPT_HL1             ;0A71; Make HL hold RPT.
  LD   IX,$3A00            ;0A74; Start of disk bitmap.
  LD   B,195               ;0A78; There are 1560 bits in the bitmap.
SCAN_MAP
  LD   A,(IX+0)            ;0A7A; Fetch a disk map byte.
  OR   (HL)                ;0A7D; Incorporate the corresponding file map
  LD   (IX+0),A            ;0A7E; byte.
  INC  IX                  ;0A81; Point to the next map bytes.
  INC  HL                  ;0A83;
  DJNZ SCAN_MAP            ;0A84; Repeat for all map bytes.
  POP  IX                  ;0A86; Restore disk channel pointer.

; Another entry has been handled, go on with the next.

SCAN_NEXT
  LD   A,(IX+14)           ;0A88; Fetch RPT-hi.
  CP   1                   ;0A8B; Jump if the second entry has been
  JR   Z,SCAN_6            ;0A8D; handled.
  CALL RES_RPT             ;0A8F; Reset RPT.
  INC  (IX+14)             ;0A92; Point to the second entry.
  JP   EACH_E1             ;0A95; Repeat for this entry.

; The next CAT sector has to be retrieved (if there is one).

SCAN_6
  CALL NEXT_SEC            ;0A98; Calculate next sector.
  JP   NZ,EACH_ENTRY       ;0A9B; Jump if on same track.
  INC  D                   ;0A9E; Otherwise next track.
  LD   A,D                 ;0A9F;
  CP   4                   ;0AA0;
  JP   NZ,EACH_ENTRY       ;0AA2; Jump if still a CATalogue track.
  AND  A                   ;0AA5; Otherwise signal 'unsuccessfull' and
  RET                      ;0AA6; exit.

; An unused entry was found, so if we are searching for one then exit else
; continue.

SCAN_FREE
  LD   A,(IX+4)            ;0AA7; Fetch scan-type.
  CPL                      ;0AAA; Invert all bits.
  BIT  6,A                 ;0AAB;
  RET  Z                   ;0AAD; Return if searching for a free entry.
  JR   SCAN_NEXT           ;0AAE; Otherwise continue with next entry.

; ----------------------------------------------
; THE 'MATCH NAME' SUBROUTINE

; This subroutine checks whether the filename and, when needed, directory
; description of the current entry matches the specification. If they don't
; match the Zero flag is returned reset.

MATCH_NAME
  PUSH IX                  ;0AB0; Store disk channel pointer.
  CALL RPT_HL              ;0AB2; HL points to the start of the entry.
  LD   B,11                ;0AB5; Length of file description.
  BIT  3,(IX+4)            ;0AB7;
  LD   IX,$3E05            ;0ABB; IX points to the file description in
                                         ; UFIA1.
  JR   Z,MATCH_N2          ;0ABF; Jump if directory description doesn't
                                         ; need to match.
MATCH_N1
  LD   A,(IX+0)            ;0AC1; Fetch character of search string.
  CP   "*"                 ;0AC4; Jump if it's a '*', then all other
  JR   Z,MATCH_N3          ;0AC6; characters don't matter.
  CP   "?"                 ;0AC8; Jump if it's a '?', then this
  JR   Z,MATCH_N2          ;0ACA; character doesn't matter.
  XOR  (HL)                ;0ACC; Compare with entries character.
  AND  $DF                 ;0ACD; Capitalize.
  JR   NZ,MATCH_N3         ;0ACF; Jump if they don't match.
MATCH_N2
  INC  IX                  ;0AD1; Next character.
  INC  HL                  ;0AD3;
  DJNZ MATCH_N1            ;0AD4; Repeat for all characters.
MATCH_N3
  POP  IX                  ;0AD6; Restore disk channel pointer.
  RET                      ;0AD8; Return with Zero set signalling
                                         ; 'match'.

; ----------------------------------------------
; THE 'OPEN A FILE FOR SAVE' SUBROUTINE

; This subroutine opens a file, with the specified filename, for saving. If
; the filename wasn't used the file is opened, a return is made with the Zero
; flag set to signal 'successfull'. If the filename was used, the 'OVERWRITE'
; message is printed, when the 'Y' key is pressed the existing file is ERASEd
; and the opening is retried.  Otherwise the routine returns with the Zero
; flag reset to signal 'unsuccessfull'.

OFSM_2
  PUSH IX                  ;0AD9; Store disk channel pointer.
  LD   A,($3DEF)           ;0ADB; This is (MAPUSED), the (in)famous
                                         ; @7663. It holds the number of files
                                         ; which are using the disk bitmap.
  CP   0                   ;0ADE;
  LD   A,%00010000         ;0AE0; Scan catalogue for specified filename.
  JR   NZ,OFSM_SCAN        ;0AE2; Jump if (@7663)<>0, the disk bitmap
                                         ; isn't to be rebuild.
  LD   HL,$3A00            ;0AE4; Otherwise clear the disk bitmap.
  LD   B,195               ;0AE7;
OFSM_CLR
  LD   (HL),0              ;0AE9;
  INC  HL                  ;0AEB;
  DJNZ OFSM_CLR            ;0AEC;
  LD   A,%00110000         ;0AEE; Scan catalogue for specified filename
                                         ; and produce a disk bitmap.
OFSM_SCAN
  CALL SCAN_CAT            ;0AF0;
  JR   NZ,OFSM_FREE        ;0AF3; Jump if filename not used.
  PUSH DE                  ;0AF5; Otherwise store sector address.
  RST  CALBAS              ;0AF6; Clear the lower part of the screen by
  DEFW CLS_LOWER           ;0AF7; calling 'CLS_LOWER' in 'main' ROM.
  SET  5,(IY+2)            ;0AF9; Signal 'lower screen has to be
                                         ; cleared'. (TV_FLAG)
  CALL MESG_1              ;0AFD; Print 'OVERWRITE' message.
  CALL PRT_NAME            ;0B00; Print filename.
  CALL MESG_3              ;0B03; Print 'Y/N' message.
  CALL TEST_Y              ;0B06; Test the 'Y' key.
  JR   Z,OFSM_ERASE        ;0B09; Jump if 'Y' was pressed.
  POP  DE                  ;0B0B; When any other key was pressed the
  POP  IX                  ;0B0C; routine returns with Zero reset to
  RET                      ;0B0E; signal 'unsuccessfull'.

; The filename existed already, the user wants it to be overwritten, so ERASE
; it.

OFSM_ERASE
  POP  DE                  ;0B0F; Restore track and sector number.
  CALL RPT_HL              ;0B10; Make HL point to the entry to be
                                         ; overwritten.
  LD   (HL),0              ;0B13; ERASE this file.
  CALL WSAD                ;0B15; Write the entry back to disk.
  POP  IX                  ;0B18; Restore disk channel pointer.
  JR   OFSM_2              ;0B1A; Retry opening the file.

; The filename wasn't used so now the file can be opened.

OFSM_FREE
  POP  IX                  ;0B1C; Restore disk channel pointer.
  PUSH IX                  ;0B1E;
  LD   B,0                 ;0B20; Clear the file entry space in the disk
OFSM_CLR
  LD   (IX+19),0           ;0B22; channel.
  INC  IX                  ;0B26;
  DJNZ OFSM_CLR            ;0B28;
  POP  IX                  ;0B2A; Restore disk channel pointer.
  PUSH IX                  ;0B2C;
  LD   HL,$3E05            ;0B2E; HL points to the file descriptor in
                                         ; UFIA1.
  LD   B,11                ;0B31; Length of file descriptor.
OFSM_FDESC
  LD   A,(HL)              ;0B33; Copy file descriptor to the file entry
  LD   (IX+19),A           ;0B34; space in the disk channel.
  INC  HL                  ;0B37;
  INC  IX                  ;0B38;
  DJNZ OFSM_FDESC          ;0B3A;
  POP  IX                  ;0B3C; Restore disk channel pointer.
  CALL MK_ALLOC            ;0B3E; Allocate a sector.
  CALL STORE_SEC           ;0B41; Store its track and sector number.
  LD   (IX+32),D           ;0B44; Store its sector address also into the
  LD   (IX+33),E           ;0B47; file entry space.
  CALL RES_RPT             ;0B4A; Reset RPT.
  LD   A,($3DEF)           ;0B4D; Increment (MAPUSED), there is one more
  INC  A                   ;0B50; file which uses the disk bitmap.
  LD   ($3DEF),A           ;0B51;
  XOR  A                   ;0B54; Return with Zero flag set to signal
  RET                      ;0B55; 'successfull'.

; ----------------------------------------------
; THE 'DECREMENT MAPUSE' SUBROUTINE

; This small subroutine decrements the MAPUSED system variable. This variable
; keeps track of the number of files using the disk bitmap. When it reaches 0
; the bitmap has to be rebuild.

DEC_MAPUSE
  PUSH AF                  ;0B56;
  LD   A,($3DEF)           ;0B57; Decrease (MAPUSED), the number of
  DEC  A                   ;0B5A; files using the disk bitmap.
  LD   ($3DEF),A           ;0B5B;
  POP  AF                  ;0B5E;
  RET                      ;0B5F;

; ----------------------------------------------
; THE 'TEST FOR YES' SUBROUTINE

; This subroutine tests whether the 'Y'-key is pressed, it returns with the
; Zero flag set if it was, reset otherwise.

TEST_Y
  CALL BEEP                ;0B60; Produce a 'middle C' for one second.
TEST_Y1
  RST  CALBAS              ;0B63; The 'main' ROM is called to scan the
  DEFW KEY_SCAN            ;0B64; keyboard.
  RST  CALBAS              ;0B66; It is also called to determine if a
  DEFW KEY_TEST            ;0B67; key was pressed.
  JR   NC,TEST_Y1          ;0B69; Repeat scanning and testing until a
                                         ; key has been pressed.
  AND  $DF                 ;0B6B; Capitalize.
  CP   "Y"                 ;0B6D; Set the Zero flag if it was the
  PUSH AF                  ;0B6F; 'Y'-key.
  RST  CALBAS              ;0B70; Again the 'main' ROM is called, this
  DEFW CLS_LOWER           ;0B71; time for clearing the lower screen.
  POP  AF                  ;0B73; Retrieve Zero flag.
  RET                      ;0B74; Finished.

; ----------------------------------------------
; THE 'MAKE A BEEP' SUBROUTINE

; This subroutine produces a beep (the note 'middle C' in fact) for one
; second.

BEEP
  PUSH HL                  ;0B75;
  PUSH DE                  ;0B76;
  PUSH BC                  ;0B77;
  PUSH IX                  ;0B78;
  LD   HL,1642             ;0B7A; Parameters needed by 'BEEPER' to
  LD   DE,261              ;0B7D; produce a 'middle C'.
  RST  CALBAS              ;0B80; Produce the note.
  DEFW BEEPER              ;0B81;
  POP  IX                  ;0B83;
  POP  BC                  ;0B85;
  POP  DE                  ;0B86;
  POP  HL                  ;0B87;
  RET                      ;0B88;

; ----------------------------------------------
; THE 'CLOSE A SAVE FILE' SUBROUTINE

; This subroutine closes a save file, by writing the last sector (contained in
; the data buffer) to disk and by writing the CATalogue entry.

CFSM
  CALL RPT_HL1             ;0B89; HL points to the first unused position
                                         ; in the data buffer.
  LD   A,C                 ;0B8C; C holds buffer offset-lo.
  AND  A                   ;0B8D;
  JR   NZ,CFSM_FILL        ;0B8E; Jump if buffer isn't full yet.
  LD   A,B                 ;0B90; B holds buffer offset-hi.
  CP   2                   ;0B91;
  JR   Z,CFSM_SAVE         ;0B93; Jump if buffer is full.
CFSM_FILL
  LD   (HL),0              ;0B95; Otherwise fill up buffer with zero's.
  CALL INC_RPT             ;0B97; Increment RPT.
  JR   CFSM                ;0B9A; And close the file.

; The last sector is ready to be saved, it has been filled up with zero's if
; needed.

CFSM_SAVE
  CALL FETCH_SEC           ;0B9C; Fetch last sector's track and sector
  CALL WSAD                ;0B9F; number and save it to disk.
  CALL DEC_MAPUSE          ;0BA2; One file less uses the disk bitmap.
  PUSH IX                  ;0BA5; Store disk channel pointer.
  LD   A,%01000000         ;0BA7; Search the CATalogue for an unused
  CALL SCAN_CAT            ;0BA9; entry.
  JP   NZ,REP_25           ;0BAC; If none found report 'Directory FULL'.
  CALL RPT_HL              ;0BAF; HL points to the entry.
  LD   ($3ACA),IX          ;0BB2; Store disk channel pointer 2, this one
                                         ; points to the DFCA.
  POP  IX                  ;0BB6; Restore disk channel pointer 1, this
                                         ; one can point to 'main' RAM (OPENTYPE)
  PUSH IX                  ;0BB8; Store it again.
  LD   B,0                 ;0BBA; Copy the file entry to the CAT entry
CFSM_ENTRY
  LD   A,(IX+19)           ;0BBC; in the data buffer.
  LD   (HL),A              ;0BBF;
  INC  IX                  ;0BC0;
  INC  HL                  ;0BC2;
  DJNZ CFSM_ENTRY          ;0BC3;
  LD   IX,($3ACA)          ;0BC5; Restore disk channel pointer 2.
  CALL WSAD                ;0BC9; Write the sector to disk.
  POP  IX                  ;0BCC; Restore disk channel pointer 1.
  RET                      ;0BCE; Finished.

; ----------------------------------------------
; THE 'OPEN A FILE FOR LOAD' SUBROUTINE

; This subroutine opens a file, with the specified filename, for loading. If
; the filename isn't found an error is given. If the filename is found it is
; opened and the first sector is loaded into the data buffer.

HGFLE_2
  LD   A,($3E04)           ;0BCF; Fetch device description from UFIA1.
  AND  $DF                 ;0BD2; Capitalize.
  CP   "P"                 ;0BD4;
  JR   NZ,HGFL_NONUM       ;0BD6; Jump if no program number specified.
  LD   A,%00000001         ;0BD8; Search for the specified program
  CALL SCAN_CAT            ;0BDA; number.
  JP   NZ,REP_26           ;0BDD; If file isn't found report 'File NOT
                                         ; FOUND'.
  CALL RPT_HL              ;0BE0; HL points to the entry.
  LD   DE,$3E05            ;0BE3; Copy the 11 byte file descriptor to
  LD   BC,11               ;0BE6; UFIA1.
  LDIR                     ;0BE9;
  LD   (IX+13),211         ;0BEB; RPT points to the file header of the
                                         ; file.
  CALL RPT_HL1             ;0BEF; Make HL point to it.
  LD   DE,$3E10            ;0BF2; Copy the 9 byte file header to UFIA1.
  LD   BC,9                ;0BF5;
  LDIR                     ;0BF8;
  JR   LOAD_1ST            ;0BFA; Jump forward to load the first sector.

; Now search for the file with the given name.

HGFL_NONUM
  LD   A,%00010000         ;0BFC; Search for the specified filename.
  CALL SCAN_CAT            ;0BFE; If file isn't found report 'File NOT
  JP   NZ,REP_26           ;0C01; FOUND'.
                                         ; Otherwise the first sector is loaded
                                         ; by entering the 'LOAD FIRST SECTOR'
                                         ; subroutine below.

; ----------------------------------------------
; THE 'LOAD FIRST SECTOR' SUBROUTINE

; When the CAT entry of the file to be loaded is found, this routine can be
; used to fetch the first sector of the file. The first sector holds the 9
; byte file header (with certain filetypes) which should be identical to the 9
; byte file header present in the CAT entry.

LOAD_1ST
  CALL RPT_HL              ;0C04; HL points to the entry.
  LD   DE,$3E1E            ;0C07; Copy the 11 byte file descriptor to
  LD   BC,11               ;0C0A; UFIA2.
  LDIR                     ;0C0D;
  LD   (IX+13),220         ;0C0F; RPT points to the SNAPSHOT registers,
                                         ; that is when they are present.
  CALL RPT_HL1             ;0C13; Make HL point to it.
  LD   DE,$3FEA            ;0C16; Copy the 22 SNAPSHOT values to the
  LD   BC,22               ;0C19; internal stack bottom.
  LDIR                     ;0C1C;
  LD   (IX+13),13          ;0C1E; RPT points to track and sector number.
  CALL RPT_HL1             ;0C22; Now HL points to it also.
  LD   D,(HL)              ;0C25; Fetch track and sector number.
  INC  HL                  ;0C26;
  LD   E,(HL)              ;0C27;
  JP   RSAD                ;0C28; And exit while loading the first
                                         ; sector.

; ----------------------------------------------
; THE 'FORMAT A DISK' ROUTINE

; This routine formats a disk by writing one track at a time to disk. The
; track is first build up in 'main' RAM. After the formatting is completed,
; the other disk is completely copied (cloned) or the disk is checked for bad
; sectors.

FORMAT_RUN
  CALL TEST_DRV            ;0C2B; See if the drive is defined.
  CALL SET_DRVSD           ;0C2E;
  LD   B,20                ;0C31; First step 20 times inward.
FRMT_1
  PUSH BC                  ;0C33;
  CALL STEP_IN             ;0C34;
  POP  BC                  ;0C37;
  DJNZ FRMT_1              ;0C38;
  CALL TRACK_0             ;0C3A; Then position the head above track 0.
  LD   IX,DFCA             ;0C3D;
FRMT_TRK
  CALL MK_TRK_DD           ;0C41; Build up a double density track.
  LD   C,%11110000         ;0C44; Write track, disable spin-up sequence,
                                         ; no delay, enable precompensation.
  CALL PRECOMP1            ;0C46; Why call this routine? The precomp.
                                         ; has already been enabled.
  LD   HL,49152            ;0C49; HL points to the track build up in
                                         ; 'main' memory.
  CALL WR_OP               ;0C4C; Write the track.
  CALL STEP_DELAY          ;0C4F; Wait a moment.
  INC  D                   ;0C52; Next track.
  CALL DRV_CAP             ;0C53; Get drive capacity in A.
  CP   D                   ;0C56;
  JR   Z,FRMT_DONE         ;0C57; Jump if all tracks have been formatted
  AND  $7F                 ;0C59; Mask off side.
  CP   D                   ;0C5B;
  JR   Z,FRMT_SIDE1        ;0C5C; Jump if side1 hasn't been formatted.
  CALL STEP_IN             ;0C5E; Next track.

; The following code determines the skew, i.e. the shifting between the
; sectors of a track and the previous track. The +D uses a skew of +2, so
; sector 1 on track T lies adjacent to sector 9 on track T+1.

  DEC  E                   ;0C61;
  JR   NZ,FRMT_2           ;0C62; Jump if sector >= 1.
  LD   E,10                ;0C64; Sector numbers have range 1..10.
FRMT_2
  DEC  E                   ;0C66;
  JR   NZ,FRMT_3           ;0C67; Jump if sector >= 1.
  LD   E,10                ;0C69; This instruction is never reached??
FRMT_3
  JP   FRMT_TRK            ;0C6B; Format the next track.

; If a double sided drive is used, the formatting continues on track 0 side 1.

FRMT_SIDE1
  CALL TRACK_0             ;0C6E; Reset drive head.
  LD   D,128               ;0C71; Track 0, side 1.
  CALL SET_DRVSD           ;0C73; Set drive, side, density, etc.
  JP   FRMT_TRK            ;0C76; Continue formatting.

; When the formatting of all tracks is completed, the routine checks whether
; it is supposed to copy another disk to this one, or to verify the disk.

FRMT_DONE
  CALL REST                ;0C79; Reset drive head.
  LD   A,(UFIA2)           ;0C7C;
  CP   $FF                 ;0C7F;
  JR   Z,FRMT_CHK          ;0C81; Jump if UFIA2 is empty.

; When the disk in the other drive is to be cloned, it will be copied a track
; at a time.

FRMT_COPY
  LD   HL,49152            ;0C83; Address of track buffer.
  LD   ($3AC5),HL          ;0C86; Store load address.
  LD   ($3AC8),HL          ;0C89; Store save address.
  LD   A,(UFIA2)           ;0C8C; Fetch source drive number from UFIA2.
  CALL TEST_DRV1           ;0C8F; Check and set drive.
FRMT_C1
  CALL RSAD                ;0C92; Load a sector.
  PUSH DE                  ;0C95; Store track and sector number.
  LD   HL,$3BD6            ;0C96; DRAM sector buffer address.
  LD   DE,($3AC5)          ;0C99; Fetch load address.
  LD   BC,512              ;0C9D; BC holds sector length.
  LDIR                     ;0CA0; Copy the contents of the buffer to
                                         ; 'main' RAM.
  LD   ($3AC5),DE          ;0CA2; Store new load address.
  POP  DE                  ;0CA6; Restore track and sector number.
  CALL NEXT_SEC            ;0CA7; Compute next sector number.
  JR   NZ,FRMT_C1          ;0CAA; Jump if there is still a sector on this
                                         ; track.
  LD   A,(UFIA1)           ;0CAC; Fetch destination drive from UFIA1.
  CALL TEST_DRV1           ;0CAF; Check and set drive.
FRMT_C2
  PUSH DE                  ;0CB2; Store track and sector number.
  LD   HL,($3AC8)          ;0CB3; Fetch save address.
  LD   DE,$3BD6            ;0CB6; DRAM sector buffer address.
  LD   BC,512              ;0CB9; BC holds sector length.
  LDIR                     ;0CBC; Copy a sector to the sector buffer.
  LD   ($3AC8),HL          ;0CBE; Store new save address.
  POP  DE                  ;0CC1; Restore track and sector number.
  CALL WSAD                ;0CC2; Save the sector.
  CALL NEXT_SEC            ;0CC5; Compute next sector number.
  JR   NZ,FRMT_C2          ;0CC8; Jump if not all sectors on this track
                                         ; have been written.
  CALL NXT_TRK             ;0CCA; Compute next track number.
  JR   NZ,FRMT_COPY        ;0CCD; Jump if not all tracks have been
                                         ; copied.
  EI                       ;0CCF; Enable interrupts and exit via
  JP   REST                ;0CD0; 'REST'.

; The routine now verifies if all sectors are readable. An error is given if a
; sector can't be read, it would have been more usefull if a 'badsectors' file
; was saved.

FRMT_CHK
  CALL RSAD                ;0CD3; Load a sector.
  CALL NEXT_SEC            ;0CD6; Compute next sector number.
  JR   NZ,FRMT_CHK         ;0CD9; Jump if not all sectors on one track
                                         ; have been loaded.
  CALL NXT_TRK             ;0CDB; Compute next track number.
  JR   NZ,FRMT_CHK         ;0CDE; Jump if not all tracks on the disk have
                                         ; been verified.
  EI                       ;0CE0; Enable interrupts and exit via
  JP   REST                ;0CE1; 'REST'.

; ----------------------------------------------
; THE 'NXT_TRK' SUBROUTINE

; This subroutine is almost the same as the 'NEXT_TRACK' subroutine at $0956.
; But the differences are essential. No error is given when a non existent
; track is reached and the Zero flag is used to signal 'no more tracks on this
; side' when set.

NXT_TRK
  INC  D                   ;0CE4; Increase track number.
  CALL DRV_CAP             ;0CE5; Get drive capacity in A.
  CP   D                   ;0CE8;
  RET  Z                   ;0CE9; Return with Zero set if last track
                                         ; reached.
  AND  $7F                 ;0CEA; Mask off side bit.
  CP   D                   ;0CEC;
  RET  NZ                  ;0CED; Return with Zero reset if last track
                                         ; on side0 hasn't been reached.
  CALL REST                ;0CEE; Reset drive head.
  LD   D,128               ;0CF1; Track 0, side 1.
  CP   D                   ;0CF3; Reset Zero flag.
  RET                      ;0CF4;

; ----------------------------------------------
; THE 'BUILD UP A DD TRACK' SUBROUTINE

; This subroutine builds up a double density track in the 'main' memory
; starting at address 49152.

MK_TRK_DD
  LD   HL,49152            ;0CF5; Start of track buffer.
  LD   BC,$3C4E            ;0CF8; Store 60 bytes $4E. GAP I.
  CALL B_TIMES_C           ;0CFB;
  LD   B,10                ;0CFE; Number of sectors on a track.
MK_TRK_DD1
  PUSH BC                  ;0D00;
  LD   BC,$0C00            ;0D01; 12 bytes $00. Last part of GAP III.
  CALL B_TIMES_C           ;0D04;
  LD   BC,$03F5            ;0D07; 3 bytes $F5 (written as $A1).
  CALL B_TIMES_C           ;0D0A;
  LD   BC,$01FE            ;0D0D; 1 byte  $FE (ID field ID).
  CALL B_TIMES_C           ;0D10;
  LD   A,D                 ;0D13; Fetch track number.
  AND  $7F                 ;0D14; Mask side bit.
  LD   C,A                 ;0D16;
  LD   B,1                 ;0D17; 1 byte  track number.
  CALL B_TIMES_C           ;0D19;
  LD   A,D                 ;0D1C; Fetch track again.
  AND  $80                 ;0D1D; Keep only side bit.
  RLCA                     ;0D1F; Rotate it to bit 0.
  LD   C,A                 ;0D20;
  LD   B,1                 ;0D21; 1 byte  side number.
  CALL B_TIMES_C           ;0D23;
  LD   C,E                 ;0D26; Fetch sector number.
  CALL NEXT_SEC            ;0D27; Increment sector number.
  LD   B,1                 ;0D2A; 1 byte  sector number.
  CALL B_TIMES_C           ;0D2C;
  LD   BC,$0102            ;0D2F; 1 byte  $02 (sector length = 512).
  CALL B_TIMES_C           ;0D32;
  LD   BC,$01F7            ;0D35; 1 byte  $F7 (two CRC bytes written).
  CALL B_TIMES_C           ;0D38;
  LD   BC,$164E            ;0D3B; 22 bytes $4E. GAP II.
  CALL B_TIMES_C           ;0D3E;
  LD   BC,$0C00            ;0D41; 12 bytes $00.
  CALL B_TIMES_C           ;0D44;
  LD   BC,$03F5            ;0D47; 3 bytes $F5 (written as $A1).
  CALL B_TIMES_C           ;0D4A;
  LD   BC,$01FB            ;0D4D; 1 byte  $FB (data field ID).
  CALL B_TIMES_C           ;0D50;
  LD   BC,$0000            ;0D53; 512 bytes $00. Data bytes.
  CALL B_TIMES_C           ;0D56;
  CALL B_TIMES_C           ;0D59;
  LD   BC,$01F7            ;0D5C; 1 byte  $F7 (two CRC bytes written).
  CALL B_TIMES_C           ;0D5F;
  LD   BC,$184E            ;0D62; 24 bytes $4E. First part of GAP III.
  CALL B_TIMES_C           ;0D65;
  POP  BC                  ;0D68; Retrieve sector counter.
  DEC  B                   ;0D69; Repeat until all 10 sectors have been
  JP   NZ,MK_TRK_DD1       ;0D6A; build up.
  LD   BC,$004E            ;0D6D; 768 bytes $00. GAP IV.
  CALL B_TIMES_C           ;0D70;
  CALL B_TIMES_C           ;0D73;
  JP   B_TIMES_C           ;0D76;

; ----------------------------------------------
; THE 'STORE B TIMES BYTE C' SUBROUTINE

; This subroutine is used in the construction of a track in memory, it stores
; the byte held in the C register, B times.

B_TIMES_C
  LD   (HL),C              ;0D79; Store C.
  INC  HL                  ;0D7A; Next address.
  DJNZ B_TIMES_C           ;0D7B; Repeat until B=0.
  RET                      ;0D7D;

; ----------------------------------------------
; THE 'NEXT SECTOR' SUBROUTINE

; This subroutine computes the next sector number in E, it returns with the
; Zero flag set indicating 'next track'.

NEXT_SEC
  INC  E                   ;0D7E; Increment sector number.
  LD   A,E                 ;0D7F;
  CP   11                  ;0D80;
  RET  NZ                  ;0D82; Return with Zero reset signalling
                                         ; 'same track'.
  LD   E,1                 ;0D83; Otherwise start with sector 1 again.
  RET                      ;0D85; Return with Zero set signalling 'next
                                         ; track'.

; ----------------------------------------------
; THE 'MAKE HL POINT TO BUFFER' SUBROUTINE

; This subroutine returns with HL holding the start of the data buffer. On
; entry IX must point to the start of the disk channel.

HL_BUFFER
  PUSH BC                  ;0D86;
  PUSH IX                  ;0D87; Disk channel pointer to BC.
  POP  BC                  ;0D89;
  LD   L,(IX+15)           ;0D8A; Fetch data buffer offset.
  LD   H,(IX+16)           ;0D8D;
  ADD  HL,BC               ;0D90; HL now points to the data buffer.
  POP  BC                  ;0D91;
  RET                      ;0D92;

; ----------------------------------------------
; THE 'FETCH RPT INTO HL' SUBROUTINE

; This subroutine returns with HL holding the RAM PoinTer, which points to the
; next data byte in the data buffer. When entering at $0D97, RPT-lo is first
; reset.

RPT_HL
  LD   (IX+13),0           ;0D93; Reset RPT-lo.
RPT_HL1
  CALL HL_BUFFER           ;0D97; HL points to the data buffer.
  LD   B,(IX+14)           ;0D9A; Fetch RPT offset into BC.
  LD   C,(IX+13)           ;0D9D;
  ADD  HL,BC               ;0DA0; Add the offset to the start of the
                                         ; data buffer.
  RET                      ;0DA1; Finished.

; ----------------------------------------------
; THE 'INCREMENT RPT' SUBROUTINE

; This small subroutine increments the RAM PoinTer offset.

INC_RPT
  INC  (IX+13)             ;0DA2; Increment RPT-lo.
  RET  NZ                  ;0DA5;
  INC  (IX+14)             ;0DA6; Increment RPT-hi when necessary.
  RET                      ;0DA9;

; ----------------------------------------------
; THE 'RESET RPT' SUBROUTINE

; This small subroutine resets the RAM PoinTer offset.

RES_RPT
  LD   (IX+13),0           ;0DAA; Clear RPT offset.
  LD   (IX+14),0           ;0DAE;
  RET                      ;0DB2;

; ----------------------------------------------
; THE 'FETCH SECTOR ADDRESS' SUBROUTINE

; This subroutine returns with DE holding the stored track and sector number.

FETCH_SEC
  LD   D,(IX+18)           ;0DB3;
  LD   E,(IX+17)           ;0DB6;
  RET                      ;0DB9;

; ----------------------------------------------
; THE 'STORE SECTOR ADDRESS' SUBROUTINE

; This subroutine stores the track and sector number held in DE into the disk
; channel.

STORE_SEC
  LD   (IX+18),D           ;0DBA;
  LD   (IX+17),E           ;0DBD;
  RET                      ;0DC0;

; ----------------------------------------------
; THE 'GET SECTOR ADDRESS' SUBROUTINE

; This subroutine returns with DE holding the stored track and sector number
; and the track and sector number held in HL stored into the disk channel.

GET_SECTOR
  CALL FETCH_SEC           ;0DC1; Fetch the stored track and sector
  LD   (IX+18),H           ;0DC4; number. And store the track and sector
  LD   (IX+17),L           ;0DC7; number held in HL.
  RET                      ;0DCA;

; ----------------------------------------------
; THE 'STEP' SUBROUTINES

; These two small subroutines are used to move the drive head one step in or
; out.

STEP_OUT
  LD   C,%01111000         ;0DCB; Step-out, update track register,
  JR   STEP                ;0DCD; disable spin-up sequence, no verify,
                                         ; step rate 6 ms.
STEP_IN
  LD   C,%01011000         ;0DCF; Step-in, update track register,
                                         ; disable spin-up sequence, no verify,
                                         ; step rate 6 ms.
STEP
  CALL LD_COM_REG          ;0DD1; Execute the command, move one track.
  JP   STEP_DELAY          ;0DD4; Wait for the number of msec's
                                         ; specified by (STPRAT).


; ===============================================================
; The 'Hook code' routines

; The following routines are called by the 'hook and command code' routine at
; $228E (in RAM) whenever a hook code was used.

; ----------------------------------------------
; THE 'HOOK CODE ADDRESSES' TABLE

; This jump table consists of the 24 addresses of the routines called by using
; the various 'hook codes' in the range $1B..$32 (27..50).

IF1_HOOK
  DEFW CONS_IN             ;0DD7; Hook code $1B, 27.
  DEFW CONS_OUT            ;0DD9; Hook code $1C, 28.
  DEFW BCHAN_IN            ;0DDB; Hook code $1D, 29.
  DEFW BCHAN_OUT           ;0DDD; Hook code $1E, 30.
  DEFW PRT_OUT             ;0DDF; Hook code $1F, 31.
  DEFW KBD_TEST            ;0DE1; Hook code $20, 32.
  DEFW SEL_DRIVE           ;0DE3; Hook code $21, 33.
  DEFW OP_TEMP_M           ;0DE5; Hook code $22, 34.
  DEFW CLOSE_M2            ;0DE7; Hook code $23, 35.
  DEFW ERASE               ;0DE9; Hook code $24, 36.
  DEFW READ_SEQ            ;0DEB; Hook code $25, 37.
  DEFW WR_RECD             ;0DED; Hook code $26, 38.
  DEFW RD_RANDOM           ;0DEF; Hook code $27, 39.
  DEFW RD_SECTOR           ;0DF1; Hook code $28, 40.
  DEFW RD_NEXT             ;0DF3; Hook code $29, 41.
  DEFW WR_SECTOR           ;0DF5; Hook code $2A, 42.
  DEFW SET_T_MCH           ;0DF7; Hook code $2B, 43.
  DEFW DEL_M_BUF           ;0DF9; Hook code $2C, 44.
  DEFW OP_TEMP_N           ;0DFB; Hook code $2D, 45.
  DEFW CLOSE_NET           ;0DFD; Hook code $2E, 46.
  DEFW GET_PACK            ;0DFF; Hook code $2F, 47.
  DEFW SEND_PACK           ;0E01; Hook code $30, 48.
  DEFW HOOK_31             ;0E03; Hook code $31, 49.
  DEFW HOOK_32             ;0E05; Hook code $32, 50.

; ----------------------------------------------
; THE 'RS232 NOT SUPPORTED' SUBROUTINE

; The 'BCHAN_IN' and 'BCHAN_OUT' 'hook codes' are not supported (the +D has no
; RS232 link).

UNDEFINED1
  RET                      ;0E07;

; ----------------------------------------------
; THE 'CONSOLE INPUT' SUBROUTINE

; Called by using 'hook code' 27 ($1B), it simply waits until a key is
; pressed. A return is made with the A register holding the character code.

CONS_IN
  RES  5,(IY+1)            ;0E08; Signal 'ready for a new key'.
WTKEY
  EI                       ;0E0C; Enable interrupts.
  HALT                     ;0E0D; Wait for an interrupt.
  RST  CALBAS              ;0E0E; Call the keyboard scan routine in the
  DEFW KEYBOARD            ;0E0F; 'main' ROM.
  BIT  5,(IY+1)            ;0E11; Repeat the scan until a key has been
  JR   Z,WTKEY             ;0E15; pressed.
  LD   A,(23560)           ;0E17; Fetch the character code from (LAST_K)
  RET                      ;0E1A;

; ----------------------------------------------
; THE 'CONSOLE OUTPUT' SUBROUTINE

; By using 'hook code' 28 ($1C) the character held in the A register is
; printed on the screen, with scroll suppressed.

CONS_OUT
  PUSH AF                  ;0E1B;
  LD   A,254               ;0E1C; Use stream '-2' (attached to "S" the
                                         ; channel).
OUT_CODE
  LD   HL,23692            ;0E1E; This is SCR_CT.
  LD   (HL),$FF            ;0E21; Set scroll counter.
  RST  CALBAS              ;0E23; Call 'CHAN_OPEN' in the 'main' ROM to
  DEFW CHAN_OPEN           ;0E24; make stream -2 the current.
  POP  AF                  ;0E26;
  RST  CALBAS              ;0E27; Print the character to the current
  DEFW PRINT_A_1           ;0E28; stream.
  RET                      ;0E2A;

; ----------------------------------------------
; THE 'PRINTER OUTPUT' SUBROUTINE

; This subroutine is called by using 'hook code' 31 ($1F). It is identical to
; the preceding one, but the output is directed to stream 3 (normally the
; printer).

PRT_OUT
  PUSH AF                  ;0E2B;
  LD   A,3                 ;0E2C; Select stream 3.
  JR   OUT_CODE            ;0E2E;

; ----------------------------------------------
; THE 'KEYBOARD TEST' SUBROUTINE

; This is called using 'hook code' 32 ($20). A return is made with the Zero
; flag reset if a key is pressed.

KBD_TEST
  XOR  A                   ;0E30; Clear A, allowing for the whole
                                         ; keyboard to be examined.
  IN   A,(254)             ;0E31; Read the keyboard.
  AND  $1F                 ;0E33; Keep only the keyboard bits.
  SUB  $1F                 ;0E35; Return with sign negative and Zero
  RET                      ;0E37; flag reset if a key is pressed.

; ----------------------------------------------
; THE 'SELECT DRIVE' SUBROUTINE

; This subroutine is called by using 'hook code' 33 ($21). On entry, A holds
; the drive number; if A isn't equal to 1 or 2 nothing is done.

SEL_DRIVE
  CP   1                   ;0E38;
  JR   Z,SEL_DRIVE1        ;0E3A; Jump if drive 1 is to be selected.
  CP   2                   ;0E3C;
  JR   Z,SEL_DRIVE1        ;0E3E; Jump if drive 2 is to be selected.
  XOR  A                   ;0E40;
  RET                      ;0E41; Otherwise exit.
SEL_DRIVE1
  LD   B,A                 ;0E42;
  LD   ($3ACE),A           ;0E43;
  LD   A,($3DDA)           ;0E46; Fetch current control port state.
  AND  $FC                 ;0E49; Drop the drive select bits.
  OR   B                   ;0E4B; Use the new drive.
  LD   ($3DDA),A           ;0E4C; Exit setting both current control port
  OUT  (239),A             ;0E4F; state and the control port itself.
  RET                      ;0E51;

; ----------------------------------------------
; THE 'OPEN TEMP. "M" CHANNEL' SUBROUTINE

; This subroutine is used to open a temporary "M" channel in the CHANS area.
; It is called by using 'hook code' 34 ($22). First a temporary "M" channel is
; created, then the drive whose number is held into 'D_STR1' is searched for a
; file whose name is held into 'N_STR1'. A sector map is created with each
; reset bit indicating a free sector.  Various flags are returned as follows:

    ; - bit 0 of CHFLAG                    set with 'write' files.
    ; - bit 1 of RECFLG                    set with 'EOF' block.
    ; - bit 2 of RECFLG                    set with PRINT-type files.

; On exit, HL holds a 'stream data' displacement that may be used to attach
; the channel to a stream.

OP_TEMP_M
  CALL SET_T_MCH           ;0E52; Create a temporary "M" channel.
  PUSH HL                  ;0E55; Save 'stream displacement'.
  LD   A,(IX+25)           ;0E56; Fetch the drive number (CHDRIV).
  CALL SEL_DRIVE           ;0E59; Select the drive.
  PUSH IX                  ;0E5C;
  LD   DE,14               ;0E5E; Make IX point to CHNAME, the name of
  ADD  IX,DE               ;0E61; the wanted file.
  CALL FIND_FILE           ;0E63; Search for the filename.
  JR   NZ,OP_T_2           ;0E66; Jump if not found.
  INC  HL                  ;0E68; Skip number of sectors used.
  INC  HL                  ;0E69;
  LD   D,(HL)              ;0E6A; Fetch first track and sector.
  INC  HL                  ;0E6B;
  LD   E,(HL)              ;0E6C;
  LD   IX,DFCA             ;0E6D;
  CALL RSAD                ;0E71; Read the first sector.
  POP  IX                  ;0E74; Restore channel pointer (in 'main'
  PUSH IX                  ;0E76; RAM).
  LD   DE,540              ;0E78; Microdrive type files consist of
                                         ; records with a length of 540 bytes
                                         ; each.
OP_T_1
  PUSH IX                  ;0E7B; Store data buffer pointer (in 'main'
                                         ; RAM).
  LD   IX,DFCA             ;0E7D;
  CALL LBYT                ;0E81; Fetch a byte.
  POP  IX                  ;0E84; Restore data buffer pointer.
  LD   (IX+55),A           ;0E86; Loading starts with the data block
                                         ; preamble (offset 55).
  INC  IX                  ;0E89;
  CALL DEC_DE              ;0E8B; Decrement DE.
  JR   NZ,OP_T_1           ;0E8E; Repeat until DE=0.
  POP  IX                  ;0E90;
  RES  0,(IX+24)           ;0E92; Signal 'read file'.
  POP  HL                  ;0E96; Restore stream 'stream data'.
  RET                      ;0E97; Finished.

OP_T_2
  LD   HL,$3A00            ;0E98; Clear the disk bitmap.
  LD   B,195               ;0E9B;
OP_T_3
  LD   (HL),0              ;0E9D;
  INC  HL                  ;0E9F;
  DJNZ OP_T_3              ;0EA0;
  LD   A,%00100000         ;0EA2; Make new disk bitmap.
  CALL SCAN_CAT            ;0EA4;
  POP  IX                  ;0EA7;
  PUSH IX                  ;0EA9;
  LD   HL,$3AD6            ;0EAB; Points to dir. descr. of DFCA.
  LD   (HL),6              ;0EAE; File is a 'Microdrive file'.
  INC  HL                  ;0EB0;
  LD   B,10                ;0EB1; Copy the 10 characters of the name.
OP_T_4
  LD   A,(IX+14)           ;0EB3;
  LD   (HL),A              ;0EB6;
  INC  IX                  ;0EB7;
  INC  HL                  ;0EB9;
  DJNZ OP_T_4              ;0EBA;
  LD   B,245               ;0EBC; Clear the rest of the CATalogue entry
OP_T_5
  LD   (HL),0              ;0EBE; of this file.
  INC  HL                  ;0EC0;
  DJNZ OP_T_5              ;0EC1;
  LD   HL,$0000            ;0EC3; Reset RPT.
  LD   ($3AD0),HL          ;0EC6;
  LD   HL,$3BD6            ;0EC9; Clear the first 256 bytes of the data
  LD   B,0                 ;0ECC; buffer.
OP_T_6
  LD   (HL),0              ;0ECE;
  INC  HL                  ;0ED0;
  DJNZ OP_T_6              ;0ED1;
  LD   IX,DFCA             ;0ED3;
  CALL MK_ALLOC            ;0ED7; Allocate the first free sector.
  LD   ($3AD4),DE          ;0EDA; Store the track and sector number.
  LD   IX,$3AD6            ;0EDE; Store them also into the CATalogue
  LD   (IX+13),D           ;0EE2; entry.
  LD   (IX+14),E           ;0EE5;
  POP  IX                  ;0EE8;
  RES  1,(IX+67)           ;0EEA; Signal 'Not the EOF block' (RECFLG).
  RES  2,(IX+67)           ;0EEE; Signal 'PRINT-type file' (opened for
  POP  HL                  ;0EF2; writing). Restore stream 'stream data'
  RET                      ;0EF3; Finished.

; ----------------------------------------------
; THE 'SET A TEMP. "M" CHANNEL' SUBROUTINE

; This subroutine is also called by using 'hook code' 43 ($2B). It sets a
; temporary "M" channel in the CHANS area. The subroutine returns with IX
; pointing to the start of the channel and HL holding a suitable displacement
; to be eventually inserted in the STRMS area to attach the channel to a
; stream.

SET_T_MCH
  LD   IX,(23631)          ;0EF4; Fetch (CHANS), the start of the
                                         ; channel area.
  LD   DE,20               ;0EF8; Make IX point to the start of the
  ADD  IX,DE               ;0EFB; 'new' channels.
SET_T_1
  LD   A,(IX+0)            ;0EFD;
  CP   128                 ;0F00;
  JR   Z,SET_T_3           ;0F02; Jump if the CHANS area is finished.
  LD   A,(IX+4)            ;0F04; Fetch the channel specifier.
  AND  $7F                 ;0F07; Clear bit 7 (drop temporary/permanent
                                         ; flag).
  CP   "M"                 ;0F09;
  JR   NZ,SET_T_2          ;0F0B; Jump if not a "M" channel.
  LD   A,(23766)           ;0F0D; Fetch drive number (D_STR1).
  CP   (IX+25)             ;0F10; Compare it with (CHDRIV).
  JR   NZ,SET_T_2          ;0F13; Jump if this channel uses a different
                                         ; drive.
  LD   BC,(23770)          ;0F15; Fetch length of filename (NSTR_1).
  LD   HL,(23772)          ;0F19; And its startaddress (NSTR_1+2).
  CALL CHK_NAME            ;0F1C; Check name against 'CHNAME' of this
                                         ; channel.
  JR   NZ,SET_T_2          ;0F1F; Jump if not the same file.
  BIT  0,(IX+24)           ;0F21;
  JR   Z,SET_T_2           ;0F25; Jump if it's a 'read file'.
  JP   MD_ERROR            ;0F27; Exit if the file is already opened for
                                         ; writing.
SET_T_2
  LD   E,(IX+9)            ;0F2A; Fetch the length of the channel.
  LD   D,(IX+10)           ;0F2D;
  ADD  IX,DE               ;0F30; Point to the next channel.
  JR   SET_T_1             ;0F32; Check next channel.

; Now the space for the new channel is created at the end of the CHANS area.

SET_T_3
  LD   HL,(23635)          ;0F34; Calculate end of CHANS area ((PROG)-1)
  DEC  HL                  ;0F37; i.e. the start of the channel.
  PUSH HL                  ;0F38;
  LD   BC,595              ;0F39; Length is '595' bytes.
  RST  CALBAS              ;0F3C; Create the required space by calling
  DEFW MAKE_ROOM           ;0F3D; 'MAKE_ROOM'.
  POP  DE                  ;0F3F; Restore start address of the channel.
  PUSH DE                  ;0F40;
  LD   HL,MCHAN_DATA       ;0F41; Start of "M" channel data.
  LD   BC,25               ;0F44;
  LDIR                     ;0F47; Store channel data into the channel.
  LD   A,(23766)           ;0F49; Fetch drive number (D_STR1).
  LD   (IX+25),A           ;0F4C; Store it into the channel (CHDRIV).
  LD   BC,595              ;0F4F; Length of the channel.
  PUSH IX                  ;0F52; Make HL point to the start of the
  POP  HL                  ;0F54; channel.
  CALL REST_F_AD           ;0F55; Restore 'start of filename' possibly
                                         ; moved during the 'insertion' of the
                                         ; channel.
  EX   DE,HL               ;0F58; The start address of the filename goes
                                         ; to HL.
  LD   BC,(23770)          ;0F59; Fetch length of filename (N_STR1).
  BIT  7,B                 ;0F5D; Jump if the name doesn't exist
  JR   NZ,SET_T_5          ;0F5F; (N_STR1 = $FFFF).

; The channel name is transferred into CHNAME.

SET_T_4
  LD   A,B                 ;0F61;
  OR   C                   ;0F62;
  JR   Z,SET_T_5           ;0F63; Jump if no more bytes left.
  LD   A,(HL)              ;0F65; Transfer a character of the name into
  LD   (IX+14),A           ;0F66; (CHNAME).
  INC  HL                  ;0F69; Point to next locations.
  INC  IX                  ;0F6A;
  DEC  BC                  ;0F6C; One byte less.
  JR   SET_T_4             ;0F6D; Continue with next character.

; Now the 'preambles' are stored into the channel.

SET_T_5
  POP  IX                  ;0F6F; Restore start address of channel.
  LD   DE,28               ;0F71; Offset for header block preamble.
  CALL SETUP_PRE           ;0F74; Set-up header preamble.
  LD   DE,55               ;0F77; Offset for data block preamble.
  CALL SETUP_PRE           ;0F7A; Set-up data block preamble.
  PUSH IX                  ;0F7D; Make HL point to the start of the
  POP  HL                  ;0F7F; channel.
  LD   DE,(23631)          ;0F80; Calculate the required 'stream offset'
  OR   A                   ;0F84; into HL (i.e. channel start-(CHANS)+1)
  SBC  HL,DE               ;0F85;
  INC  HL                  ;0F87;
  RET                      ;0F88; Finished.

; ----------------------------------------------
; THE 'SET-UP A PREAMBLE' SUBROUTINE

; The following subroutine passes a preamble to the specified channel
; position.  On entry IX points to the start of the channel and DE holds the
; required offset.

SETUP_PRE
  PUSH IX                  ;0F89; Pass start of channel to HL.
  POP  HL                  ;0F8B;
  ADD  HL,DE               ;0F8C; Add the offset.
  EX   DE,HL               ;0F8D; DE now points to the preamble area.
  LD   HL,$0F97            ;0F8E; Start of 'preamble' data.
  LD   BC,12               ;0F91; Preamble is 12 bytes long.
  LDIR                     ;0F94;
  RET                      ;0F96;

; ----------------------------------------------
; THE 'PREAMBLE DATA' TABLE

; The header and data block preambles consist of the following bytes:

PREAMBLE
  DEFB $00,$00,$00,$00,$00 ;0F97;
  DEFB $00,$00,$00,$00,$00 ;0F9C;
  DEFB $FF,$FF             ;0FA1;

; The Microdrive needs these bytes to fetch the start of a block of bytes when
; reading a cartridge.

; ----------------------------------------------
; THE 'RESTORE FILENAME ADDRESS' ROUTINE

; After the 'insertion' of some space, the 'filename' whose start addresses
; are held into (N_STR1+2) and (N_STR2+2) have been moved up in the workspace
; area. This routine is entered with HL holding the channel start address, and
; with BC holding the number of 'inserted' bytes. The addresses held into
; (N_STR1+2) and (N_STR2+2) are then updated, unless the filenames are stored
; into 'no-dynamic' areas (i.e. before the channel or after STKEND).

REST_F_AD
  PUSH HL                  ;0FA3; Save 'start of channel' twice.
  PUSH HL                  ;0FA4;
  LD   DE,(23780)          ;0FA5; Restore start address of the second
  CALL TST_PLACE           ;0FA9; filename.
  LD   (23780),DE          ;0FAC;
  POP  HL                  ;0FB0; Restore channel start address.
  LD   DE,(23772)          ;0FB1; Restore start address of the first
  CALL TST_PLACE           ;0FB5; filename.
  LD   (23772),DE          ;0FB8;
  POP  HL                  ;0FBC; Restore channel start address.
  RET                      ;0FBD; Finished.

; The following subroutine calculates the new filename address.

TST_PLACE
  SCF                      ;0FBE; Allow for a further byte.
  SBC  HL,DE               ;0FBF; No action is made if the filename is
  RET  NC                  ;0FC1; before the channel.
  LD   HL,(23653)          ;0FC2; Or if it is after (STKEND).
  SBC  HL,DE               ;0FC5;
  RET  C                   ;0FC7;
  EX   DE,HL               ;0FC8; Add to DE the number of 'inserted'
  ADD  HL,BC               ;0FC9; bytes, so returning the new filename
  EX   DE,HL               ;0FCA; address.
  RET                      ;0FCB; Finished.

; ----------------------------------------------
; THE 'CHECK NAME' SUBROUTINE

; Whenever a 'filename' is to be compared against the channel name CHNAME,
; this subroutine is called. On entry, HL must point to the filename to be
; compared, while C must contain its length. If the comparision is succesful,
; the Zero flag is returned set.

CHK_NAME
  PUSH IX                  ;0FCC; Save start of channel.
  LD   B,10                ;0FCE; Length of a filename.
CHK_NAME1
  LD   A,(HL)              ;0FD0; Fetch a byte from the name.
  CP   (IX+14)             ;0FD1;
  JR   NZ,CHK_NAME3        ;0FD4; Jump if it doesn't match.
  INC  HL                  ;0FD6; Point to the next character.
  INC  IX                  ;0FD7;
  DEC  B                   ;0FD9; One byte less.
  DEC  C                   ;0FDA; Repeat until all bytes of the name have
  JR   NZ,CHK_NAME1        ;0FDB; been matched.
  LD   A,B                 ;0FDD; CHNAME remaining length.
  OR   A                   ;0FDE;
  JR   Z,CHK_NAME3         ;0FDF; Exit if all bytes of CHNAME matched.
CHK_NAME2
  LD   A,(IX+14)           ;0FE1; Otherwise the remaining characters of
  CP   32                  ;0FE4; CHNAME have to be spaces.
  JR   NZ,CHK_NAME3        ;0FE6; Exit if not a space.
  INC  IX                  ;0FE8; Repeat until all bytes of CHNAME have
  DJNZ CHK_NAME2           ;0FEA; been examined.
CHK_NAME3
  POP  IX                  ;0FEC; Restore channel start address.
  RET                      ;0FEE; Finished.

; ----------------------------------------------
; THE 'CALL INP' ROUTINE

; This routine is the same as the Interface 1 'CALL_INP' routine which handles
; all IF1's channels. The +D uses this routine only for "M" channels, for "D"
; channels a similar routine located in RAM is used. (The only difference is
; the test of FLAGS3, i.e. IY+124 while emulating the IF1, $1ACF otherwise.)
; On entry HL holds the address of the service 'input' routine. The routine
; handles both INPUT and INKEY$ commands.

CALL_INP
  RES  3,(IY+2)            ;0FEF; Signal 'the mode is to be considered
                                         ; as being unchanged'.
  PUSH HL                  ;0FF3; Store address of service routine.
  LD   HL,(23613)          ;0FF4; HL points to error address (ERR_SP).
  LD   E,(HL)              ;0FF7; Fetch the error address.
  INC  HL                  ;0FF8;
  LD   D,(HL)              ;0FF9;
  AND  A                   ;0FFA;
  LD   HL,ED_ERROR         ;0FFB; If the error address is 'ED_ERROR'
  SBC  HL,DE               ;0FFE; ('main' ROM) then an INPUT command was
  JR   NZ,INKEY$           ;1000; used. Jump if unequal to 'ED_ERROR'.

; Now deal with an 'INPUT #' command referring to a "M" channel.

  POP  HL                  ;1002; Restore address of service routine.
  LD   SP,(23613)          ;1003; Clear the machine stack (ERR_SP).
  POP  DE                  ;1007; Remove 'ED_ERROR'.
  POP  DE                  ;1008;
  LD   (23613),DE          ;1009; Restore the old value of ERR_SP.
IN_AGAIN
  PUSH HL                  ;100D; Store address of service routine.
  LD   DE,INPUT_END        ;100E; Return address is 'INPUT_END' below.
  PUSH DE                  ;1011;
  JP   (HL)                ;1012; Jump to the service routine.

; When the byte has been read from the required channel, a return is made here
; to add the byte to the INPUT line, or to return if the byte is equal to CHR$
; 13, i.e.  ENTER.

INPUT_END
  JR   C,ACC_CODE          ;1013; Jump with acceptable codes.
  JR   Z,NO_READ           ;1015; Jump with no data read.
INPUT_ERR
  JP   MD_ERROR            ;1017; Otherwise jump to the 'hook code'
                                         ; error routine.
NO_READ
  POP  HL                  ;101A; Restore address of service routine and
  JR   IN_AGAIN            ;101B; try again.

; An acceptable code was received, it is added to the INPUT line.

ACC_CODE
  CP   13                  ;101D;
  JR   Z,END_INPUT         ;101F; Jump if the code is ENTER.
  RST  CALBAS              ;1021; Otherwise the byte is to be added to
  DEFW ADD_CHAR0           ;1022; the INPUT line. This is done by call-
                                         ; ing into the 'ADD_CHAR' subroutine.
  POP  HL                  ;1024; Restore address of the service routine
  JR   IN_AGAIN            ;1025; and read the next byte.

END_INPUT
  POP  HL                  ;1027; Drop the address of the service
  JP   UNPAGE_1            ;1028; routine and page-out the +D.

; Enter here to deal with the INKEY$ function (a single character is
; returned).

INKEY
  $     POP  HL                  ;102B; Restore address of the service routine
  LD   DE,INK      $_END   ;102C; Return address is 'INK$_END' below.
  PUSH DE                  ;102F;
  JP   (HL)                ;1030; Jump to the service routine.

INK
  $_END   RET  C                   ;1031; Return with acceptable codes or
  RET  Z                   ;1032; with no byte read.
  BIT  4,(IY+124)          ;1033; Otherwise EOF was reached, so jump to
  JR   Z,INPUT_ERR         ;1037; the error routine except when
                                         ; executing a 'MOVE' command.
  OR   1                   ;1039; Then return with Zero and Carry flags
  RET                      ;103B; both reset.

; ----------------------------------------------
; THE '"M" CHANNEL INPUT' ROUTINE

; The actual 'input' is handled via 'CALL_INP' above. The service routine is
; 'MCHAN_IN' below.

M_INPUT
  LD   IX,(23633)          ;103C; Make IX point to start of channel.
  LD   HL,MCHAN_IN         ;1040; Address of the service routine.
  JP   CALL_INP            ;1043; Jump to the control routine.

; ----------------------------------------------
; THE '"M" CHANNEL INPUT' SERVICE ROUTINE

; This is the actual read a byte from the "M" channel routine. The byte is
; read from the data buffer in the channel, if it is empty the next sector is
; loaded from disk (provided that the 'current' data block is not the EOF one)
; before reading the byte.

MCHAN_IN
  BIT  0,(IX+24)           ;1046; Jump to the 'hook code' error routine
  JP   NZ,MD_ERROR         ;104A; if (CHFLAG) indicates 'read' file.
TEST_M_BUF
  LD   E,(IX+11)           ;104D; Fetch current byte counter from
  LD   D,(IX+12)           ;1050; (CHBYTE).
  LD   L,(IX+69)           ;1053; Fetch record length from (RECLEN).
  LD   H,(IX+70)           ;1056;
  SCF                      ;1059; Include byte to be read.
  SBC  HL,DE               ;105A;
  JR   C,CHK_M_EOF         ;105C; Jump if all bytes have been read.
  INC  DE                  ;105E; Include byte to be read in the byte
                                         ; counter.
  LD   (IX+11),E           ;105F; And store it.
  LD   (IX+12),D           ;1062;
  DEC  DE                  ;1065; Position of character to be read.
  PUSH IX                  ;1066; Save start address of channel.
  ADD  IX,DE               ;1068; IX now points to 'byte to be
                                         ; read - 82'.
  LD   A,(IX+82)           ;106A; Fetch the byte.
  POP  IX                  ;106D; Restore start of channel.
  SCF                      ;106F; Signal 'acceptable code'.
  RET                      ;1070; Finished.

; If all bytes in the data block have been read, a check is made to see if it
; is the 'end of file' block, i.e. the last one.

CHK_M_EOF
  BIT  1,(IX+67)           ;1071; Jump if (RECFLG) indicates 'not the
  JR   Z,NEW_BUFF          ;1075; End Of File' block.
  XOR  A                   ;1077; Otherwise Zero and Carry flag are
                                         ; reset to signal 'EOF'.
  ADD  A,13                ;1078; Returned byte is CHR$ 13, i.e. ENTER.
  RET                      ;107A; Finished.

; A new data block is now read from the disk drive.

NEW_BUFF
  LD   DE,0                ;107B; Clear the byte counter.
  LD   (IX+11),E           ;107E;
  LD   (IX+12),D           ;1081;
  INC  (IX+13)             ;1084; Increment (CHREC), i.e. record number.
  CALL GET_RECD            ;1087; Fetch a new data block.
  JR   TEST_M_BUF          ;108A; Read the byte.

; ----------------------------------------------
; THE 'GET A RECORD' SUBROUTINE

; This subroutine is used to load a record of a 'MICRODRIVE'-type file.

GET_RECD
  LD   C,3                 ;108C; Three retries will be made before the
                                         ; routine is exitted when an error
                                         ; occurs.
  BIT  1,(IX+67)           ;108E;
  JR   NZ,GET_R3           ;1092; Jump if (RECFLG) indicates 'EOF' block
GET_R1
  PUSH IX                  ;1094; Store channel pointer (in 'main' RAM).
  LD   DE,540              ;1096; Microdrive file records have 540 bytes
                                         ; each.
GET_R2
  PUSH IX                  ;1099; Store data buffer pointer.
  LD   IX,DFCA             ;109B;
  CALL LBYT                ;109F; Fetch a byte.
  POP  IX                  ;10A2; Restore data buffer pointer.
  LD   (IX+55),A           ;10A4; Loading starts with the data block
                                         ; preamble (offset 55).
  INC  IX                  ;10A7;
  CALL DEC_DE              ;10A9; Decrement DE.
  JR   NZ,GET_R2           ;10AC; Repeat until DE=0.
  POP  IX                  ;10AE; Restore channel pointer.
  LD   A,(IX+68)           ;10B0; Fetch number of this record (RECNUM).
  CP   (IX+13)             ;10B3; Test it against wanted record number
  RET  Z                   ;10B6; (CHREC), exit if they are equal.
  BIT  1,(IX+67)           ;10B7; Jump to load the next record if
  JR   Z,GET_R1            ;10BB; (RECFLG) indicates that this isn't the
                                         ; EOF one.
GET_R3
  DEC  C                   ;10BD; Decrement retry counter.
  JR   Z,MD_ERROR1         ;10BE; Exit via the 'hook code' error routine
                                         ; when three retries have been made.

; Now the routine reloads the first sector of the file. With 'MICRODRIVE'-type
; files it is possible to have a 'read' channel attached to a file to which is
; also a 'write' channel attached. So the last record could have been read
; into the 'read' channels data buffer after which a new record was added by
; the 'write' channel. The reason why three retries are made is probably
; because of the ignoring of errors, signalled by a set Carry flag (remember
; this is a 'hook code' executing), reported by 'LBYT' and 'RSAD'. The routine
; does some retrying before quitting.

  PUSH HL                  ;10C0; Store the registers needed by the
  PUSH IX                  ;10C1; routine above.
  PUSH BC                  ;10C3;
  LD   A,(IX+25)           ;10C4; Fetch the drive number from CHDRIV.
  CALL SEL_DRIVE           ;10C7; Select the drive.
  LD   DE,14               ;10CA; Make IX point to CHNAME, the name of
  ADD  IX,DE               ;10CD; the requested file.
  CALL FIND_FILE           ;10CF; Search for the filename.
  JR   NZ,MD_ERROR1        ;10D2; Jump if not found.
  INC  HL                  ;10D4; Skip 'number of sectors used'.
  INC  HL                  ;10D5;
  LD   D,(HL)              ;10D6; Fetch first track and sector.
  INC  HL                  ;10D7;
  LD   E,(HL)              ;10D8;
  LD   IX,DFCA             ;10D9;
  CALL RSAD                ;10DD; Read the first sector.
  POP  BC                  ;10E0; Restore registers.
  POP  IX                  ;10E1;
  POP  HL                  ;10E3;
  JR   GET_R1              ;10E4; Try to find the right record again.

; ----------------------------------------------
; THE 'JUMP TO ERROR ROUTINE'

; Because this jump is only two times 'jump relatived to', it wastes one byte.

MD_ERROR1
  JP   MD_ERROR            ;10E6; Jump to the 'hook code' error routine.

; ----------------------------------------------
; THE '"M" CHANNEL DATA' TABLE

; The '25' bytes that compose the initial part of an "M" channel are as
; follows:

MCHAN_DATA
  DEFW $0008               ;10E9; Main ROM 'output' routine.
  DEFW $0008               ;10EB; Main ROM 'input' routine.
  DEFB "M"+128             ;10ED; Channel specifier.
  DEFW MCHAN_OUT           ;10EE; +D ROM 'output' routine.
  DEFW M_INPUT             ;10F0; +D ROM 'input' routine.
  DEFW 595                 ;10F2; Channel length.
  DEFW $0000               ;10F4; Default for CHBYTE.
  DEFB $00                 ;10F6; Default for CHREC.
  DEFM "          "        ;10F7; Default for CHNAME (10 spaces).
  DEFB $FF                 ;1101; Default for CHFLAG ('write' channel).

; ----------------------------------------------
; THE 'CLOSE FILE' SUBROUTINE

; By using 'hook code' 35 ($23) the following subroutine is called. It CLOSEs
; an "M" channel which start adddress is held in the IX register. If the
; channel is used for reading, then it is reclaimed; but if it is used for
; writing, any unsent data in the buffer is written to disk before reclaiming
; the channel.

CLOSE_M2
  BIT  0,(IX+24)           ;1102; Jump if (CHFLAG) indicates that this
  JR   Z,CLOSE_M1          ;1106; is a 'read' channel.
  SET  1,(IX+67)           ;1108; Otherwise signal 'EOF record',
  CALL WR_RECD             ;110C; and save it on disk.
  PUSH IX                  ;110F; Save channel pointer.
  LD   IX,DFCA             ;1111;
  CALL CFSM                ;1115; Close the File Sector Map.
  POP  IX                  ;1118; Restore channel pointer.
CLOSE_M1
  CALL DEL_M_BUF           ;111A; Reclaim the channel.
  RET                      ;111D;

; ----------------------------------------------
; THE 'ERASE' SUBROUTINE

; This subroutine is called using 'hook code' 36 ($24). It deals with the
; ERASEing of all file types. It differs from the +D's ERASE 'command code':
; this routine uses a temporary channel and the IF1's extra system variables
; to ERASE a file. On entry 'D_STR1' must hold the drive number and 'N_STR1'
; the length and the start of the filename.

ERASE
  CALL SET_T_MCH           ;111E; Create a temporary "M" channel.
  PUSH IX                  ;1121; Store channel pointer.
  LD   DE,14               ;1123; Make IX point to CHNAME, the name of
  ADD  IX,DE               ;1126; the file to be ERASEd.
  CALL FIND_FILE           ;1128; Search for the file.
  POP  IX                  ;112B; Restore channel pointer.
  PUSH AF                  ;112D; Save flags.
  JR   NZ,ERASE_1          ;112E; Jump if the file wasn't found.
  LD   HL,$3BD6            ;1130; Point to the start of the disk buffer.
  ADD  HL,BC               ;1133; BC holds the directory entries offset
                                         ; (i.e. 0 for first, 256 for second).
  LD   (HL),0              ;1134; Signal 'ERASEd file'.
  PUSH IX                  ;1136; Store channel pointer.
  LD   IX,DFCA             ;1138;
  CALL WSAD                ;113C; Write sector DE.
  POP  IX                  ;113F; Restore channel pointer.
ERASE_1
  CALL DEL_M_BUF           ;1141; Reclaim the channel.
  POP  AF                  ;1144; Exit with Zero reset indicating 'file
  RET                      ;1145; not found'.

; ----------------------------------------------
; THE 'FIND A FILE' SUBROUTINE

; This routine searches the disk CATalogue for the filename pointed to by the
; IX register.  On exit, Zero reset signals 'file not found'.

FIND_FILE
  CALL REST                ;1146; Reset drive to track 0.
  LD   ($3ACA),IX          ;1149; Store the pointer to filename
                                         ; requested.
FIND_F1
  LD   IX,DFCA             ;114D;
  CALL RSAD                ;1151; Load a sector to the disk buffer.
  LD   BC,0                ;1154; First entry's offset.
FIND_F2
  LD   HL,$3BD6            ;1157; Point to the start of the disk buffer.
  ADD  HL,BC               ;115A; Point to directory entry.
  LD   A,(HL)              ;115B;
  CP   0                   ;115C;
  JR   Z,FIND_F4           ;115E; Jump if the file is ERASEd.
  INC  HL                  ;1160; Point to the filename.
  LD   IX,($3ACA)          ;1161; Fetch pointer to filename requested.
  LD   A,10                ;1165; Length of filename.
  LD   ($3DF3),A           ;1167;
FIND_F3
  LD   A,(IX+0)            ;116A; Fetch a byte from requested name.
  XOR  (HL)                ;116D; Compare against found name.
  AND  $DF                 ;116E; Capitalize.
  JR   NZ,FIND_F4          ;1170; Jump if they don't match.
  INC  IX                  ;1172; Next characters.
  INC  HL                  ;1174;
  LD   A,($3DF3)           ;1175;
  DEC  A                   ;1178;
  LD   ($3DF3),A           ;1179;
  JR   NZ,FIND_F3          ;117C; Repeat for all characters in the name.
  RET                      ;117E; Return with Zero set to indicate 'file
                                         ; found'.

; The requested filename wasn't found yet, so examine the next file.

FIND_F4
  LD   A,B                 ;117F;
  CP   1                   ;1180;
  JR   Z,FIND_F5           ;1182; Jump if second entry handled.
  LD   A,($3DDA)           ;1184;
  AND  $04                 ;1187; Jump if using single density, i.e.
  JR   NZ,FIND_F5          ;1189; each sector holds one entry.
  LD   BC,256              ;118B; Otherwise examine second entry.
  JR   FIND_F2             ;118E;

; The next CATalogue sector has to be loaded, if present.

FIND_F5
  INC  E                   ;1190; Next sector.
  LD   A,E                 ;1191;
  CP   11                  ;1192; Jump if last sector on current track
  JR   NZ,FIND_F1          ;1194; hasn't been loaded yet.
  LD   E,1                 ;1196; Otherwise start with sector 1
  INC  D                   ;1198; on the next track.
  LD   A,D                 ;1199;
  CP   4                   ;119A; Jump if last track in CATalogue hasn't
  JR   NZ,FIND_F1          ;119C; been handled yet.
  CP   0                   ;119E; Otherwise reset Zero flag to signal
  RET                      ;11A0; 'file not found' and exit.

; ----------------------------------------------
; THE 'READ SEQUENTIAL' SUBROUTINE

; This is called by using 'hook code' 37 ($25). The subroutine reads into the
; data block of the current "M" channel, the next record of a named PRINT-type
; file. On entry IX must hold the "M" channel start address, and CHREC the
; number of the current record.  CHREC will be automatically incremented.
; CHDRIV must hold the drive number and CHNAME must hold the filename.

READ_SEQ
  BIT  1,(IX+67)           ;11A1; Jump if (RECFLG) indicates that the
  JR   Z,INCREC            ;11A5; current record isn't the EOF one.
  JP   MD_ERROR            ;11A7; Otherwise exit via the 'hook code'
                                         ; error routine.
INCREC
  INC  (IX+13)             ;11AA; Increment the record number (CHREC)
                                         ; and continue into 'RD_RANDOM'.

; ----------------------------------------------
; THE 'READ RANDOM' SUBROUTINE

; This subroutine is called by using 'hook code' 39 ($27). The record number
; CHREC of a PRINT-type file is loaded into the data block. The other
; variables are to be set as for 'READ_SEQ' above.

RD_RANDOM
  CALL GET_RECD            ;11AD; Load CHREC record.
  BIT  2,(IX+67)           ;11B0; Return only if (RECFLG) indicates that
  RET  Z                   ;11B4; it is a PRINT-type file.
  CALL DEL_M_BUF           ;11B5; Otherwise reclaim the channel and exit
  JP   MD_ERROR            ;11B8; via the 'hook code' error routine.

; ----------------------------------------------
; THE '"M" CHANNEL OUTPUT' ROUTINE

; This routine handles the "M" channel output. The byte stored in the A
; register is stored into the 512-byte buffer. When it is filled, the record
; is written onto disk.

MCHAN_OUT
  LD   IX,$FFFA            ;11BB; This is -6.
  ADD  IX,DE               ;11BF; Point to the start of the channel.
  BIT  0,(IX+24)           ;11C1; Continue only if (CHFLAG) indicates
  JP   Z,MD_ERROR          ;11C5; that this is a 'write' file.
  LD   E,(IX+11)           ;11C8; Fetch the byte pointer (CHBYTE).
  LD   D,(IX+12)           ;11CB;
  PUSH IX                  ;11CE; Save start address of channel.
  ADD  IX,DE               ;11D0; Point to 'first free byte in
                                         ; buffer'-82.
  LD   (IX+82),A           ;11D2; Store the byte into the buffer.
  POP  IX                  ;11D5; Restore start of channel.
  INC  DE                  ;11D7; Update (CHBYTE).
  LD   (IX+11),E           ;11D8;
  LD   (IX+12),D           ;11DB;
  BIT  1,D                 ;11DE; Return if the buffer is not filled
  RET  Z                   ;11E0; (position 512 has not been reached).

; If the buffer is filled, the routine continues into 'WR_RECD' below.

; ----------------------------------------------
; THE 'WRITE RECORD' SUBROUTINE

; This subroutine is called by using 'hook code' 38 ($26). The record held in
; the "M" channel pointed by the IX register (with name CHNAME and number
; CHREC), is written onto the disk inserted into drive CHDRIV.

WR_RECD
  LD   A,(IX+25)           ;11E1; Fetch the drive number (CHDRIV).
  CALL SEL_DRIVE           ;11E4; Select the drive.
  PUSH IX                  ;11E7; Save start address of channel.
  LD   B,10                ;11E9; Counts ten characters.
CP_NAME
  LD   A,(IX+14)           ;11EB; Copy CHNAME into RECNAM.
  LD   (IX+71),A           ;11EE;
  INC  IX                  ;11F1;
  DJNZ CP_NAME             ;11F3;
  POP  IX                  ;11F5; Restore start of channel.
  LD   C,(IX+11)           ;11F7; Copy CHBYTE into RECLEN.
  LD   (IX+69),C           ;11FA;
  LD   A,(IX+12)           ;11FD;
  LD   (IX+70),A           ;1200;
  LD   A,(IX+13)           ;1203; Copy CHREC into RECNUM.
  LD   (IX+68),A           ;1206;
  PUSH IX                  ;1209; Make HL point to the start of the data
  POP  HL                  ;120B; workspace,
  LD   DE,67               ;120C; i.e. RECFLG.
  ADD  HL,DE               ;120F;
  CALL CHKS_HD_R           ;1210; Calculate DESCHK checksum.
  LD   DE,15               ;1213; Make HL point to the start of the
  ADD  HL,DE               ;1216; 512-byte buffer.
  CALL CHKS_BUF            ;1217; Calculate DCHK checksum.
  CALL SAVE_RECD           ;121A; Save the record to disk.
  LD   DE,0                ;121D; Clear CHBYTE.
  LD   (IX+11),E           ;1220;
  LD   (IX+12),D           ;1223;
  INC  (IX+13)             ;1226; Increment the record number (CHREC).
  RET                      ;1229; Finished.

; ----------------------------------------------
; THE 'CALCULATE/COMPARE CHECKSUM' ROUTINE

; This routine is used to calculate DESCHK and DCHK checksums, or to compare
; the previous checksum against the current one; the Zero flag is returned set
; if the checksums match.  The entry point is CHK_HD_R for DESCHK, or
; CHKS_BUFF for DCHK checksum. On entry in both cases HL must contain the
; start address of the block for which the checksum is to be obtained.

CHKS_HD_R
  LD   BC,14               ;122A; The block length.
  JR   CHKS_ALL            ;122D; Calculate checksum for the block.

CHKS_BUF
  LD   BC,512              ;122F; The block length.
CHKS_ALL
  PUSH HL                  ;1232; The start address is preserved.
  LD   E,0                 ;1233; Clear checksum.
CHKS_1
  LD   A,E                 ;1235; Add the current byte to the previous
  ADD  A,(HL)              ;1236; sum.
  INC  HL                  ;1237; Point to next location.
  ADC  A,1                 ;1238; Include also the carry + 1.
  JR   Z,CHKS_2            ;123A; Jump if A reaches zero.
  DEC  A                   ;123C; Otherwise balance the 'ADC' above.
CHKS_2
  LD   E,A                 ;123D; Update sum.
  DEC  BC                  ;123E; One byte less to add.
  LD   A,B                 ;123F;
  OR   C                   ;1240;
  JR   NZ,CHKS_1           ;1241; Repeat until all bytes have been added
  LD   A,E                 ;1243;
  CP   (HL)                ;1244; Compare with previous checksum.
  LD   (HL),A              ;1245; Store the new one.
  POP  HL                  ;1246; Restore start address.
  RET                      ;1247; Finished.

; ----------------------------------------------
; THE 'SAVE A RECORD' SUBROUTINE

; This subroutine saves the 540 byte Microdrive-file record to disk.

SAVE_RECD
  PUSH IX                  ;1248; Save the channel pointer.
  PUSH IX                  ;124A;
  POP  HL                  ;124C; Calculate the address of the first
  LD   DE,55               ;124D; byte to SAVE, i.e. the data block
  ADD  HL,DE               ;1250; preamble (offset 55).
  LD   DE,540              ;1251; Length of the record to be written.
  LD   IX,DFCA             ;1254;
SAVE_REC1
  LD   A,(HL)              ;1258; Fetch a byte.
  CALL SBYT                ;1259; Save it to disk.
  INC  HL                  ;125C;
  CALL DEC_DE              ;125D; Decrement DE.
  JR   NZ,SAVE_REC1        ;1260; Repeat until DE=0.
  POP  IX                  ;1262; Restore the channel pointer.
  RET                      ;1264; Finished.

; ----------------------------------------------
; THE 'DECREMENT DE' SUBROUTINE

; This very small subroutine decrements DE and returns with the Zero flag
; indicating if DE holds zero on exit. The purpose of this three-byte
; subroutine is unclear, it doesn't save a single byte (a CALL instruction
; takes also three bytes so this subroutine makes the code only longer), and
; the readability of the code (or the source) doesn't improve really.

DEC_DE
  DEC  DE                  ;1265; DE=DE-1.
  LD   A,D                 ;1266;
  OR   E                   ;1267; Set Zero flag if DE=0.
  RET                      ;1268; Finished.

; ----------------------------------------------
; THE 'READ SECTOR' SUBROUTINE

; This subroutine is not implemented, it is called by using 'hook code' 40
; ($28).  When used with an IF1 the sector, which number is held in CHREC, is
; read into the channel area. If the sector doesn't belong to a PRINT-type
; file the data buffer is cleared before returning. On entry the required
; drive motor has to be turned on.

RD_SECTOR
  RET                      ;1269;

; ----------------------------------------------
; THE 'READ NEXT SECTOR' SUBROUTINE

; This subroutine called by using 'hook code' 41 ($29) isn't implemented
; either.  It should load into the channel area the first header and data
; block that pass through the Microdrive head. The required drive motor has to
; be started before calling this routine.

RD_NEXT
  RET                      ;126A;

; ----------------------------------------------
; THE 'WRITE SECTOR' SUBROUTINE

; Another unimplemented subroutine, called by using 'hook code' 42 ($2A) it
; writes the data block in the current channel (pointed to by IX) to the
; sector specified by CHREC.  The required Microdrive has to be started and
; all channel variables, such as CHNAME, are to be set as required before
; calling the routine.

WR_SECTOR
  RET                      ;126B;

; ----------------------------------------------
; THE 'RECLAIM "M" CHANNEL' SUBROUTINE

; This subroutine (also called by using 'hook code' 44 ($2C)) is used to
; reclaim the "M" channel pointed by the IX register. Unlike the IF1 routine
; this routine neither closes the stream(s) attached to this channel, nor
; updates the stream data for channels moved down after the reclaiming.

DEL_M_BUF
  PUSH IX                  ;126C; Make HL point to the start of the
  POP  HL                  ;126E; channel.
  LD   BC,595              ;126F; Length of the channel.
  RST  CALBAS              ;1272; Delete the channel area by calling
  DEFW RECLAIM_2           ;1273; 'RECLAIM_2' in the 'main' ROM.
  RET                      ;1275; Finished.

; ----------------------------------------------
; THE 'OPEN TEMP. "N" CHANNEL' SUBROUTINE

; The +D doesn't support the use of "N" channels, temporary or permanent, by
; the user.  This routine is called by using 'hook code' 45 ($2D).

OP_TEMP_N
  RET                      ;1276;

; ----------------------------------------------
; THE 'CLOSE NETWORK CHANNEL' SUBROUTINE

; Because the +D doesn't support "N" channels, the CLOSEing of them isn't
; supported either ('hook code' 46 ($2E)).

CLOSE_NET
  RET                      ;1277;

; ----------------------------------------------
; THE 'GET PACKET FROM NETWORK' SUBROUTINE

; Called by using 'hook code' 47 ($2F), this subroutine to fetch a header and
; data block from the network isn't implemented.

GET_PACK
  RET                      ;1278;

; ----------------------------------------------
; THE 'SEND PACKET' SUBROUTINE

; The +D doesn't support the sending of a header and data block over the
; network ('hook code' 48 ($30)).

SEND_PACK
  RET                      ;1279;

; ----------------------------------------------
; THE 'CREATE IF1 VARIABLES' SUBROUTINE

; This subroutine (called by using 'hook code' 49 ($31)) has the task of
; creating the IF1's new system variables if nonexistent. Many variables are
; initialised to their default values.

HOOK_31
  LD   HL,(23631)          ;127A; Fetch start of channel area (CHANS).
  LD   DE,$A349            ;127D; This is -23735.
  ADD  HL,DE               ;1280; The Carry flag is now set if the CHANS
                                         ; area starts after address 23734, i.e.
                                         ; the 'new' variables exist already.
  JR   C,VAR_EXIST         ;1281; Jump if they exist already.
  LD   HL,(23651)          ;1283; Clear the calculator stack by copying
  LD   (23653),HL          ;1286; (STKBOT) into (STKEND).
  LD   HL,23698            ;1289; Set (MEM) with the address of the
  LD   (23656),HL          ;128C; MEMBOT area.
  LD   HL,23733            ;128F; One location before the new space is
                                         ; needed.
  LD   BC,58               ;1292; There are 58 new variables.
  RST  CALBAS              ;1295; Use 'main' ROM 'MAKE_ROOM' to create
  DEFW MAKEROOM            ;1296; the space.
  LD   HL,IF1_VARS         ;1297; Address of 'default values' table.
  LD   BC,19               ;129B; There are 19 default values.
  LD   DE,23734            ;129E; Start of 'new' variables area.
  LDIR                     ;12A1; Store default values.
  LD   A,1                 ;12A3; Set (COPIES) to 1.
  LD   (23791),A           ;12A5;
  RET                      ;12A8; Finished.

VAR_EXIST
  RES  1,(IY+124)          ;12A9; Signal 'new variables already exist'.
  RET                      ;12AD;

; ----------------------------------------------
; THE 'SYSTEM VARS DEFAULT VALUES' TABLE

; This table contains the default values of all the 'new' IF1 system variables
; from FLAGS3 to SER_FL.

IF1_VARS
  DEFB $02                 ;12AE; Default for FLAGS3 (bit 1 is set to
                                         ; signal that the shadow ROM has been
                                         ; paged in for the first time).
  DEFW $01F0               ;12AF; Default for VECTOR is the IF1's
                                         ; 'ERR_6' address (nonsense for +D).
  LD   HL,$0000            ;12B1; This short subroutine is used to call
  CALL $0000               ;12B4; 'main' ROM routines from the IF1 ROM,
  LD   (23738),HL          ;12B7; it isn't used with the +D.
  RET                      ;12BA;
  DEFW $000C               ;12BB; Default for BAUD, i.e. 9600 baud.
  DEFB $01                 ;12BD; Default for NSTAT.
  DEFB $00                 ;12BE; Default for IOBORD, the colour during
                                         ; IF1 I/O (black).
  DEFW $0000               ;12BF; Default for SER_FL.

; ----------------------------------------------
; THE 'CALL IF1 SUBROUTINE' SUBROUTINE

; This subroutine, called by using 'hook code' 50 ($32), is designed to call
; IF1 ROM-routines when the 'main' ROM is paged in. The difference with IF1 is
; that the +D uses DE to pass the address to be called.

HOOK_32
  EX   DE,HL               ;12C1;
  JP   (HL)                ;12C2;

; ----------------------------------------------
; THE 'HOOK CODE ERROR' ROUTINE

; Whenever an error is encountered in the 'hook code' routines a jump is made
; here to signal the error and clear the machine stack when necessary.

MD_ERROR
  CALL BORD_REST           ;12C3; Restore the border colour.
  LD   HL,($2066)          ;12C6;
  LD   A,H                 ;12C9;
  OR   L                   ;12CA;
  JR   Z,MD_ERR1           ;12CB; Jump if the stack isn't to be cleared.
  LD   SP,HL               ;12CD; Otherwise clear the stack.
MD_ERR1
  XOR  A                   ;12CE;
  DEC  A                   ;12CF;
  SCF                      ;12D0; Exit with A holding 255 and Carry flag
  RET                      ;12D1; set.


; ===============================================================
; The Printer routines

; ----------------------------------------------
; THE 'NORMAL SCREENDUMP' SUBROUTINE

; This routine dumps a normal screendump to the printer. It can be called also
; by using command code 58 ($3A).

COPS
  CALL SYSTEM_Z            ;12D2; If a system file has been loaded
  CALL Z,JCOPS             ;12D5; call it's screendump routine.
  LD   HL,16384            ;12D8; Start of screen.
  LD   DE,N_per_72_LSPC    ;12DB; Print the escape sequence for n/72 inch
  CALL PO_ESC_SEQ          ;12DE; line feeds.
  LD   A,8                 ;12E1; Make it 8/72.
  CALL PNTP                ;12E3;
C1_LINE
  LD   DE,GRAPH_DPI        ;12E6; Print the escape sequence for a normal
  CALL PO_ESC_SEQ          ;12E9; screendump. (60 dpi)
  LD   A,0                 ;12EC; Signal '256 dot columns will follow'
  CALL PNTP                ;12EE; to the printer.
  LD   A,1                 ;12F1;
  CALL PNTP                ;12F3;
  PUSH HL                  ;12F6;
C1_CHAR
  LD   B,8                 ;12F7; Eight pixels in each byte.
C1_PIXEL
  PUSH HL                  ;12F9;
C1_PIXROW
  CALL PIXEL_COL           ;12FA; Get pixel colour.
  AND  $04                 ;12FD;
  JR   NZ,C1_ADDDOT        ;12FF; Jump with colour codes 4-7 (no dot).
  SCF                      ;1301; Set a dot for colour codes 0-3.
C1_ADDDOT
  LD   A,($3E4F)           ;1302; Incorporate one dot in dot column.
  RLA                      ;1305;
  LD   ($3E4F),A           ;1306;
  INC  H                   ;1309; Next pixel row.
  LD   A,H                 ;130A;
  AND  $07                 ;130B;
  JR   NZ,C1_PIXROW        ;130D; Repeat until all eight pixelrows have
                                         ; been 'scanned'.
  LD   A,($3E4F)           ;130F;
  CALL PNTP                ;1312; Print the dot column.
  POP  HL                  ;1315; Repeat until all eight pixels in a byte
  DJNZ C1_PIXEL            ;1316; have been printed. One character cell
                                         ; (64 pixels) has been printed now.
  INC  L                   ;1318; Next character position.
  LD   A,L                 ;1319;
  AND  $1F                 ;131A;
  JR   NZ,C1_CHAR          ;131C; Loop for all 32 character columns.
  CALL ADV_PAPER           ;131E; Advance printer paper one line.
  POP  HL                  ;1321;
  LD   A,H                 ;1322; Make HL point to the next screen third
  ADD  A,8                 ;1323; 'N_CHARROW' will adjust HL if
  LD   H,A                 ;1325; necessary.
  CALL N_CHARROW           ;1326; Calculate the address of the next
  JR   NZ,C1_LINE          ;1329; characterrow and loop until end of
                                         ; pixel area reached.
  JP   DUMP_EXIT           ;132B; Exit via 'DUMP_EXIT' to reset printer.

; ----------------------------------------------
; THE 'ADVANCE PRINTER PAPER' SUBROUTINE

; This subroutine advances the paper by sending a CR (carriage return) and
; (when needed) a LF (line feed) to the printer.

ADV_PAPER
  LD   A,13                ;132E; Send a CR to the printer.
  CALL PNTP                ;1330;
  LD   A,($2008)           ;1333; This is 'LFEED'.
  AND  A                   ;1336;
  RET  Z                   ;1337; Return if no LF has to be printed.
  LD   A,10                ;1338; Otherwise send a LF.
  CALL PNTP                ;133A;
  RET                      ;133D; Finished.

; ----------------------------------------------
; THE 'GREYSCALE SCREENDUMP' SUBROUTINE

; This routine prints a large screendump. It can also be called by using
; command code 66 ($42).

COPS2
  CALL SYSTEM_Z            ;133E; If a system file has been loaded
  CALL Z,JCOPS2            ;1341; call it's screendump routine.
  LD   HL,$57E0            ;1344; Address of the lowest pixelrow of the
                                         ; charactersquare in bottom left corner.
  LD   DE,N_per_72_LSPC    ;1347; Print the escape sequence for n/72
  CALL PO_ESC_SEQ          ;134A; inch line feeds.
  LD   A,6                 ;134D; Make it 6/72.
  CALL PNTP                ;134F;
  LD   B,128               ;1352; There are 128 2-pixel columns.
  LD   C,8                 ;1354; 8 pixels make one byte. Start with
                                         ; leftmost bit in a byte.
C2_2PIXCOL
  PUSH BC                  ;1356;
  PUSH HL                  ;1357;
  LD   DE,GREY_BITIM       ;1358; Print the escape sequence for the
  CALL PO_ESC_SEQ          ;135B; greyscale bitimage mode.
  LD   B,24                ;135E; There are 24 characterrows.
C2_SCRROW
  PUSH BC                  ;1360;
  PUSH HL                  ;1361;
  LD   B,8                 ;1362; A character has 8 pixelrows.
C2_PIXROW
  PUSH BC                  ;1364;
  PUSH HL                  ;1365;
  LD   DE,$3BD6            ;1366; Clear the buffer for the 2 pixels.
  LD   B,3                 ;1369;
C2_CLRBUF
  XOR  A                   ;136B;
  LD   (DE),A              ;136C;
  INC  DE                  ;136D;
  DJNZ C2_CLRBUF           ;136E;
  LD   B,2                 ;1370; The dot columns for 2 pixels are build
                                         ; up each time.
C2_2PIX
  PUSH BC                  ;1372;
  PUSH HL                  ;1373;
  LD   B,C                 ;1374;
  CALL PIXEL_COL           ;1375; Get the colour of the (B-1)th pixel.
  AND  $07                 ;1378; Keep only the least significant 3 bits
  INC  A                   ;137A; Make the range 1..8.
  LD   B,A                 ;137B;
  LD   C,0                 ;137C; Set the bit in the C register which
  SCF                      ;137E; corresponds to the colour.
C2_MK_MASK
  RL   C                   ;137F;
  DJNZ C2_MK_MASK          ;1381;
  LD   DE,GREYSCALE        ;1383; DE points to the 'GREYSCALE' table.
  LD   HL,$3BD6            ;1386; HL points to the 2-pixel buffer.
  LD   B,3                 ;1389; Each pixel is printed as 3*3 dots.
C2_DOTCOL
  PUSH BC                  ;138B;
  LD   B,3                 ;138C;
C2_DOTROW
  LD   A,(DE)              ;138E; Get colour pattern.
  AND  C                   ;138F; Only keep the bit with the right
  LD   A,(HL)              ;1390; colour.
  JR   Z,C2_ADD_DOT        ;1391; Jump if bit isn't set.
  SCF                      ;1393; Otherwise set this dot.
C2_ADD_DOT
  RL   A                   ;1394; Incorporate this dot.
  LD   (HL),A              ;1396;
  INC  DE                  ;1397; Next entry in 'GREYSCALE' table.
  DJNZ C2_DOTROW           ;1398; Repeat for 3 dotrows.
  INC  HL                  ;139A;
  POP  BC                  ;139B;
  DJNZ C2_DOTCOL           ;139C; Repeat for 3 dotcolumns.
  POP  HL                  ;139E;
  POP  BC                  ;139F;
  DEC  C                   ;13A0; Next pixel.
  DJNZ C2_2PIX             ;13A1; Two pixels are handled at a time.
  LD   B,3                 ;13A3; Three dotcolumns are to be printed.
  LD   HL,$3BD6            ;13A5;
C2_PRT3X3
  LD   A,(HL)              ;13A8; Print each dotcolumn in turn.
  CALL PNTP                ;13A9;
  INC  HL                  ;13AC;
  DJNZ C2_PRT3X3           ;13AD; Repeat for all three.
  POP  HL                  ;13AF;
  DEC  H                   ;13B0; Next pixelrow.
  POP  BC                  ;13B1; Repeat for the eight pixelrows in a
  DJNZ C2_PIXROW           ;13B2; character square.
  POP  HL                  ;13B4;
  LD   A,L                 ;13B5; One character row up.
  SUB  32                  ;13B6;
  LD   L,A                 ;13B8;
  JR   NC,C2_CHRROW        ;13B9; Jump if still within the same third.
  LD   A,H                 ;13BB; Otherwise update MSB of address.
  SUB  8                   ;13BC;
  LD   H,A                 ;13BE;
C2_CHRROW
  POP  BC                  ;13BF;
  DJNZ C2_SCRROW           ;13C0; Repeat for the 24 rows on the screen.
  CALL ADV_PAPER           ;13C2; Advance the paper.
  POP  HL                  ;13C5;
  POP  BC                  ;13C6;
  DEC  C                   ;13C7; Skip the two pixels which have already
  DEC  C                   ;13C8; been printed.
  JR   NZ,C2_BYTE          ;13C9; Jump if not all pixels within this
                                         ; byte have been printed.
  LD   C,8                 ;13CB; Otherwise reset 'pixels in a byte'
  INC  HL                  ;13CD; counter and point to the next
                                         ; character position to the right.
C2_BYTE
  DJNZ C2_2PIXCOL          ;13CE; Repeat for the 128 2-pixelcolumns.
  LD   B,4                 ;13D0; Advance the paper for four lines.
C2_ADVPAP
  CALL ADV_PAPER           ;13D2;
  DJNZ C2_ADVPAP           ;13D5;
DUMP_EXIT
  LD   DE,N_per_72_LSPC    ;13D7; Print the escape sequence for n/72 inch
  CALL PO_ESC_SEQ          ;13DA; line feeds.
  LD   A,($2007)           ;13DD; Make it (LSPCE)/72.
  JP   PNTP                ;13E0; Exit via 'PNTP'.

; ----------------------------------------------
; THE 'PIXEL COLOUR' SUBROUTINE

; This routine returns with the low 3 bits of the A register holding the
; colour of the Bth pixel from address HL (i.e. the paper colour for an 'off'
; pixel and the ink colour for an 'on' pixel).

PIXEL_COL
  PUSH HL                  ;13E3; Save address of current 8-pixels.
  PUSH BC                  ;13E4; Save pixel number (range 1..8).
  XOR  A                   ;13E5;
  SCF                      ;13E6;
PIXEL_COL1
  RLA                      ;13E7; Now set (B-1)th bit of A (range 0..7).
  DJNZ PIXEL_COL1          ;13E8;
  AND  (HL)                ;13EA; Zero flag now reflects state of pixel
  PUSH AF                  ;13EB; (i.e. set means pixel set).
  LD   A,H                 ;13EC; Calculate attribute address.
  RRCA                     ;13ED;
  RRCA                     ;13EE;
  RRCA                     ;13EF;
  AND  $03                 ;13F0;
  OR   $58                 ;13F2;
  LD   H,A                 ;13F4;
  POP  AF                  ;13F5;
  LD   A,(HL)              ;13F6; Fetch the attribute.
  POP  BC                  ;13F7;
  POP  HL                  ;13F8;
  RET  NZ                  ;13F9; Return if ink colour is to be used.
  RRCA                     ;13FA; Otherwise move paper colour
  RRCA                     ;13FB; to the lower three bits.
  RRCA                     ;13FC;
  RET                      ;13FD;

; ----------------------------------------------
; THE 'NEXT CHAR. ROW ADDRESS' SUBROUTINE

; This subroutine calculates the address of the next characterrow, if the end
; of the pixel area is reached a return with Zero set will be made.

N_CHARROW
  LD   A,L                 ;13FE; Update low address byte to next
                                         ; character row.
  ADD  A,32                ;13FF; The carry will be reset within display
  LD   L,A                 ;1401; thirds.
  CCF                      ;1402; Invert carry.
  SBC  A,A                 ;1403; A holds $FF within same third, 0 else.
  AND  $F8                 ;1404; A will hold $F8 (i.e. -8) within a
  ADD  A,H                 ;1406; third, but 0 when a new third is
  LD   H,A                 ;1407; reached. Update high byte (which was
                                         ; already incremented by 8).
  CP   $58                 ;1408; Return with the Zero flag set if
  RET                      ;140A; attributes reached.

; ----------------------------------------------
; THE 'PRINT ESCAPE SEQUENCE' SUBROUTINE

; This subroutine is used to send escape sequences to the printer. The start
; of the sequence is held in the DE register, a sequence ends with a CHR$ 128.

PO_ESC_SEQ
  LD   A,(DE)              ;140B; Fetch a code.
  CP   128                 ;140C;
  RET  Z                   ;140E; Exit if it's 128.
  CALL PNTP                ;140F; Otherwise send it to the printer.
  INC  DE                  ;1412; Continue until the sequence is
  JR   PO_ESC_SEQ          ;1413; finished.

; ----------------------------------------------
; THE '"P" CHANNEL OUTPUT' ROUTINE

; This routine handles the +D's "P" channel, the @6 system variable (PCODE)
; signals if it's to be handled as a "t" or a "b" channel. (As with the Opus
; Discovery and the ZX Interface 1.)

PCHAN_OUT
  CALL SYSTEM_Z            ;1415; If the system file is loaded call the
  CALL Z,JPCHAN            ;1418; alternative routine.
  LD   A,($2006)           ;141B; This is PCODE.
  AND  A                   ;141E;
  LD   A,($3E4F)           ;141F; Fetch the code to be send to the
  JP   NZ,PNTP             ;1422; printer, send it right away if
                                         ; (PCODE)=1, i.e. when the +D
                                         ; mustn't interfere.
  LD   HL,($2063)          ;1425; Jump to the appropriate 'output'
  JP   (HL)                ;1428; routine.

; This is the normal 'output' routine, but a few (control) characters are
; followed by one or two operands, these have to be handled different. This is
; done by altering the 'output' routine address.

P_ALL
  LD   HL,$2005            ;1429; This is 'WIDTH'.
  CP   32                  ;142C;
  JP   NC,P_NOCTRL         ;142E; Jump if not a control code (>=32).
  CP   6                   ;1431; This is the "PRINT comma" code.
  JP   C,P_ESCAPE          ;1433; Jump with codes < 6.
  JR   NZ,P_NOCOMMA        ;1436; Jump with codes > 6.
  LD   A,(HL)              ;1438; Fetch the number of characters per
  SRL  A                   ;1439; line, divide it by two.
  LD   B,A                 ;143B;
  LD   HL,$3E4E            ;143C; $3E4E holds the position on the
                                         ; current line (i.e. the number of
                                         ; characters already printed on this
  SUB  (HL)                ;143F; line).
  JR   C,P_NEWLINE         ;1440; Jump if already on 2nd half of line.
  LD   H,B                 ;1442; Otherwise jump with H holding the
  JP   P_TAB               ;1443; center position of the line.

P_NOCOMMA
  CP   8                   ;1446; This is "cursor left" or "backspace".
  JP   C,P_ESCAPE          ;1448; Jump with codes < 8.
  JR   NZ,P_NOBACK         ;144B; Jump with codes > 8 (examine further).
  LD   HL,$3E4E            ;144D; Get current position.
  LD   A,(HL)              ;1450;
  AND  A                   ;1451;
  RET  Z                   ;1452; Return if already on leftmost position
  DEC  (HL)                ;1453; Otherwise decrement current position.
  LD   A,127               ;1454; This isn't "BACKSPACE", this is
                                         ; "DELETE" !
  JP   PNTP                ;1456; Print a "DELETE".

P_NOBACK
  CP   13                  ;1459; This is "ENTER" or "CARRIAGE RETURN".
  JR   C,P_ESCAPE          ;145B; Jump with codes < 13.
  JR   NZ,P_NOENTER        ;145D; Jump with codes > 13.
  LD   HL,$2065            ;145F; This flag, when set, indicates that a
  BIT  1,(HL)              ;1462; newline has already been send to the
                                         ; printer. I.e. the previous line was
                                         ; full (see $15C0).
  RES  1,(HL)              ;1464; Reset the flag.
  RET  NZ                  ;1466; Return if this newline has been send
                                         ; already.
P_NEWLINE
  LD   HL,$2065            ;1467; Signal 'newline has been send'.
  RES  1,(HL)              ;146A;
  LD   HL,$3E4E            ;146C;
  LD   (HL),0              ;146F; Set current position to 0.
  LD   A,($2008)           ;1471; Fetch (LFEED), the number of line
  AND  A                   ;1474; feeds needed after a carriage return.
  JR   Z,P_CARRET          ;1475; Jump if it is 0.
  LD   B,A                 ;1477; Otherwise send the line feeds.
P_LFEED
  LD   A,10                ;1478; CHR$ 10 is line feed.
  CALL PNTP                ;147A;
  DJNZ P_LFEED             ;147D; Loop until (LFEED) line feeds send.
P_CARRET
  LD   A,13                ;147F; Now send the carriage return.
  CALL PNTP                ;1481;
  LD   A,($2009)           ;1484; Fetch (LMARG), that is the left margin
  AND  A                   ;1487;
  RET  Z                   ;1488; Return if it is 0.
  LD   B,A                 ;1489; Otherwise send (LMARG) spaces.
  LD   (HL),A              ;148A; Adjust current print position.
P_LMARGE
  LD   A,32                ;148B;
  CALL PNTP                ;148D;
  DJNZ P_LMARGE            ;1490; Loop until (LMARG) spaces send.
  RET                      ;1492; Finished.

; Now the control codes with operands are handled. The control codes from INK
; to OVER (16..21) and ESC (27) require a single operand, whereas the control
; characters AT & TAB are required to be followed by two operands. The
; following routines leads to the control character code being stored in
; TVDATA-lo, the first operand in TVDATA-hi or the A register if there is only
; a single operand required, and the second operand in the A register. The ESC
; control code is handled separately, the single operand is send directly to
; the printer.

P_NOENTER
  CP   16                  ;1493; This is "INK control".
  JR   C,P_ESCAPE          ;1495; Jump with codes < 16.
  CP   24                  ;1497; This is "TAB control"+1.
  JR   NC,P_ESCAPE         ;1499; Jump with codes >= 24.
  CP   22                  ;149B; This is "AT control".
  JR   NC,P_2_OPER         ;149D; Jump with AT & TAB.
  LD   DE,P_CONT           ;149F; Otherwise the '"P" channel output'
                                         ; routine is to be changed to 'P_CONT'.
P_TV_1
  LD   (23566),A           ;14A2; Store the control character code in
                                         ; (TVDATA-lo).

; The current 'output' routine address is changed temporarily.

P_CHANGE
  LD   HL,$2063            ;14A5; HL points to the 'output' routine
  LD   (HL),E              ;14A8; address. Enter the new 'output'
  INC  HL                  ;14A9; routine address and thereby force the
  LD   (HL),D              ;14AA; next character to be considered as an
  RET                      ;14AB; operand.

; Once the operands have been collected the routine continues.

P_CONT
  LD   DE,P_ALL            ;14AC; Restore the original address for
  CALL P_CHANGE            ;14AF; 'P_ALL'.
  LD   HL,(23566)          ;14B2; Fetch the control code and the first
                                         ; operand if there are indeed two
                                         ; operands (TVDATA).
  LD   D,A                 ;14B5; The 'last' operand and the control
  LD   A,L                 ;14B6; code are moved.
  CP   22                  ;14B7;
  JR   C,P_CO_TEMPS        ;14B9; Jump if handling INK to OVER.
  JR   NZ,P_TAB            ;14BB; Jump if handling TAB.
  JR   P_AT                ;14BD; Jump if handling AT.

; The control codes INK to OVER are handled by the 'main' ROM 'CO_TEMP'
; routine.  It is entered with the control code in the A register and the
; parameter in the D register. Note that all changes are to the 'temporary'
; system variables.

P_CO_TEMPS
  LD   HL,CO_TEMP_5        ;14BF; Return via the calling routine to
  EX   (SP),HL             ;14C2; 'CO_TEMP' in the 'main' ROM.
  PUSH HL                  ;14C3;
  RET                      ;14C4;

P_TV_2
  LD   DE,P_CONT           ;14C5; Store the first operand in TVDATA-hi
  LD   (23567),A           ;14C8; and change the address of the 'output'
  JR   P_CHANGE            ;14CB; routine to 'P_CONT'.

; Enter here when handling the control codes AT & TAB.

P_2_OPER
  LD   DE,P_TV_2           ;14CD; The control code will be stored in
  JR   P_TV_1              ;14D0; TVDATA-lo and the address of the
                                         ; 'output' routine changed to 'P_TV_2'.

P_ESCAPE
  CP   27                  ;14D2;
  JR   NZ,P_QUEST          ;14D4; Print a '?' if it isn't ESC.
  LD   DE,P_ESC            ;14D6; Otherwise change the address of the
  JP   P_CHANGE            ;14D9; 'output' routine to 'P_ESC'.

; Enter here when handling the ESC control code, the character code following
; the ESC is send directly to the printer.

P_ESC
  LD   DE,P_ALL            ;14DC; Restore the original address for
  CALL P_CHANGE            ;14DF; 'P_ALL'.
  JP   PNTP                ;14E2; Send the code following the ESC to the
                                         ; printer.

; A question mark is printed whenever an attempt is made to print an
; unprintable character code.

P_QUEST
  LD   A,63,"?"            ;14E5; The character '?'.
  JR   P_NOCTRL            ;14E7; Send it to the printer.

; Now deal with the TAB control code.

P_TAB
  LD   A,($2005)           ;14E9; Fetch (WIDTH), that is the line length
  LD   B,A                 ;14EC;
  LD   A,H                 ;14ED; Fetch the position where to TAB
  SUB  B                   ;14EE; (or AT) to.
  JR   C,P_INRANGE         ;14EF; Jump if position is on this line.
  LD   HL,REPORT_B         ;14F1; Otherwise return to 'REPORT_B' in the
  EX   (SP),HL             ;14F4; 'main' ROM ('Integer out of range').
  PUSH HL                  ;14F5;
  RET                      ;14F6;
P_INRANGE
  LD   A,($3E4E)           ;14F7; Fetch current position.
  LD   B,A                 ;14FA;
  LD   A,H                 ;14FB;
  SUB  B                   ;14FC;
  PUSH HL                  ;14FD; Print on a new line if print position
  CALL C,P_NEWLINE         ;14FE; exceeds TAB position.
  POP  HL                  ;1501;
  LD   A,($3E4E)           ;1502; Fetch the current position again.
  SUB  H                   ;1505; Calculate the number of spaces wanted.
  RET  Z                   ;1506; Return if already there.
  CPL                      ;1507; The number is negative so make it
  INC  A                   ;1508; positive.
  LD   B,A                 ;1509; Print the needed spaces.
P_SPACE
  LD   A,32                ;150A;
  PUSH BC                  ;150C;
  CALL P_ALL               ;150D;
  POP  BC                  ;1510;
  DJNZ P_SPACE             ;1511;
  RET                      ;1513;

; Enter here when handling AT.

P_AT
  LD   H,D                 ;1514; Store the second operand and continue
  JR   P_TAB               ;1515; in the TAB routine.

; The 'not control' characters are divided into four groups: the ordinary
; characters, the tokens, the graphics and the user-defined graphics.

P_NOCTRL
  CP   128                 ;1517; This is the first graphic.
  JR   C,P_ASCII           ;1519; Jump with ASCII characters (< 128).
  CP   144                 ;151B; This is the first UDG.
  JR   NC,P_TOK      &UDG  ;151D; Jump with UDG's and tokens.
  LD   B,A                 ;151F; Construct the graphic in the
  RST  CALBAS              ;1520; calculator's memory area by calling
  DEFW PO_GR_1             ;1521; 'PO_GR_1' in the 'main' ROM.
  LD   HL,23698            ;1523; HL points to the start of the graphic
                                         ; form; i.e. MEMBOT.
  JR   P_GRAPH             ;1526; Jump to print the graphic character.

P_TOK
  &UDG  SUB  165                 ;1528; This is the RND token.
  JR   C,P_UDGS            ;152A; Jump with UDG's (< 165).
  LD   HL,PO_TOKENS        ;152C; The routine indirectly jumps to the
  EX   (SP),HL             ;152F; 'PO_TOKENS' routine in the 'main' ROM
  PUSH HL                  ;1530; to expand the token. That routine then
  RET                      ;1531; calls recursively the 'P_ALL' routine
                                         ; above for each character of the token.

P_UDGS
  ADD  A,21                ;1532; Adjust range, UDG's now from 0..20.
  LD   BC,(23675)          ;1534; BC points to the start of the UDG area
  LD   H,0                 ;1538; (UDG).
  LD   L,A                 ;153A; Pass the code to HL.
  ADD  HL,HL               ;153B; Each UDG is made by eight bytes, so
  ADD  HL,HL               ;153C; multiply the code by eight.
  ADD  HL,HL               ;153D;
  ADD  HL,BC               ;153E;
P_GRAPH
  LD   DE,$3E3D            ;153F; Move the eight bytes to the +Ds
  LD   BC,8                ;1542; internal printerbuffer.
  LDIR                     ;1545;

; Now the eight pixelrows are converted to eight dotcolumns.

  PUSH IX                  ;1547;
  LD   IX,$3E4C            ;1549; The last address of the dotcolumns.
  LD   B,8                 ;154D; Each graphic has eight pixelrows.
P_GRAPH1
  LD   HL,$3E3D            ;154F; Address of the graphic's pixelrows.
  LD   C,8                 ;1552; Each pixelrow has eight pixels.
P_GRAPH2
  LD   D,(HL)              ;1554; Each bit is moved in turn into the E
  RR   D                   ;1555; register.
  LD   (HL),D              ;1557;
  RL   E                   ;1558;
  INC  HL                  ;155A;
  DEC  C                   ;155B;
  JR   NZ,P_GRAPH2         ;155C; Repeat for the eight pixels.
  LD   (IX+0),E            ;155E; Store the dotcolumn.
  DEC  IX                  ;1561;
  DJNZ P_GRAPH1            ;1563; Repeat for the eight rows.
  POP  IX                  ;1565;
  LD   DE,GRAPH_DPI        ;1567; Print the escape sequence for
  CALL PO_ESC_SEQ          ;156A; graphic images.
  LD   A,8                 ;156D; Signal to the printer 'there follow
  CALL PNTP                ;156F; eight bytes of bitimage data'.
  LD   A,0                 ;1572;
  CALL PNTP                ;1574;
  LD   B,8                 ;1577; Send the eight bytes to the printer.
P_GRAPH3
  LD   A,(HL)              ;1579;
  CALL PNTP                ;157A;
  INC  HL                  ;157D;
  DJNZ P_GRAPH3            ;157E;
  JR   P_UP_POS            ;1580; Update the current position.

; Now deal with the printing of normal ASCII characters.

P_ASCII
  LD   HL,$2065            ;1582;
  RES  1,(HL)              ;1585; Reset 'newline already send' flag.
  LD   ($3E4F),A           ;1587;
  LD   A,($200A)           ;158A; Fetch (GRAPH), when it's 1 the +D
  AND  A                   ;158D; has to generate the graphic
  LD   A,($3E4F)           ;158E; representation of some characters.
  JR   Z,P_OTHERS          ;1591; Jump if the normal code has to be send

; Because some Spectrum characters aren't supported by all printers the +D can
; send the graphic representation of those characters instead of the original
; character code. The characters supported £, # and (c).

  CP   96                  ;1593; Pound sign?
  JR   NZ,P_NOPOUND        ;1595; Jump if it isn't '£'.
  LD   HL,pound_sign       ;1597; Point to the bitimage data for '£'.
  JP   P_GRAPH             ;159A; Handle it as an ordinary graphic.
P_NOPOUND
  CP   "#"                 ;159D;
  JR   NZ,P_NOHASH         ;159F; Jump if it isn't '#'.
  LD   HL,hash_sign        ;15A1; Point to the bitimage data for '#'.
  JP   P_GRAPH             ;15A4; Handle it as a graphic.
P_NOHASH
  CP   127                 ;15A7; Copyright sign?
  JR   NZ,P_OTHERS         ;15A9; Jump to handle all non '(c)' characters.
  LD   HL,copyright_sign   ;15AB; Point to the bitimage data for '(c)'.
  JP   P_GRAPH             ;15AE; Handle it as a graphic.

; Finally the normal characters can be send to the printer.

P_OTHERS
  CALL PNTP                ;15B1; Send the character to the printer.
P_UP_POS
  LD   A,($3E4E)           ;15B4; Update the current position.
  INC  A                   ;15B7;
  LD   ($3E4E),A           ;15B8;
  LD   HL,$2005            ;15BB; HL points to WIDTH.
  SUB  (HL)                ;15BE;
  RET  C                   ;15BF; Return if the line isn't full yet.
  CALL P_NEWLINE           ;15C0; Otherwise someone has forgotten that
  LD   HL,$2065            ;15C3; printer lines aren't endless, so print
  SET  1,(HL)              ;15C6; a 'NEWLINE' and signal 'ignore next
  RET                      ;15C8; character if it is a CR'.

; ----------------------------------------------
; THE 'SEND A BYTE TO PRINTER' SUBROUTINE

; This routine is also called by using command code 57 ($39). It sends the 8
; bit code in the A register to the printer port, after checking if the
; printer is busy. The BREAK key is tested.

PNTP
  LD   ($3E4F),A           ;15C9; Store the code temporarily.
PNTP_1
  CALL TST_BREAK           ;15CC; Exit if the BREAK key is pressed.
  IN   A,(247)             ;15CF; Test the BUSY line of the printer.
  BIT  7,A                 ;15D1;
  JR   NZ,PNTP_1           ;15D3; Wait until printer isn't BUSY.
  IN   A,(247)             ;15D5;
  BIT  7,A                 ;15D7;
  JR   NZ,PNTP_1           ;15D9;
  IN   A,(247)             ;15DB;
  BIT  7,A                 ;15DD;
  JR   NZ,PNTP_1           ;15DF;
  LD   A,($3E4F)           ;15E1; Send the code to the printer port.
  OUT  (247),A             ;15E4;
  LD   A,($3DDA)           ;15E6; Fetch current control port status.
  OR   $40                 ;15E9; Give a STROBE.
  OUT  (239),A             ;15EB;
  AND  $BF                 ;15ED; Reset STROBE.
  OUT  (239),A             ;15EF;
  LD   A,($3E4F)           ;15F1; Return with the A register holding the
                                         ; outputted byte, 'RET' forgotten?


; ===============================================================
; The flag set and test routines

; ----------------------------------------------
; THE 'SIGNAL ..' SUBROUTINES

; These subroutines are used to signal various states of the +D. The
; corresponding test routines are located from $161C and onwards. Clearing is
; done by loading 0 into FLASG3, resetting all flags at once.

SIGN_0
  RST  F_ADDR              ;15F4;
  SET  0,(HL)              ;15F5;
  POP  HL                  ;15F7;
  RET                      ;15F8;

SIGN_1
  RST  F_ADDR              ;15F9;
  SET  1,(HL)              ;15FA;
  POP  HL                  ;15FC;
  RET                      ;15FD;

SIGN_2
  RST  F_ADDR              ;15FE;
  SET  2,(HL)              ;15FF;
  POP  HL                  ;1601;
  RET                      ;1602;

SIGN_3
  RST  F_ADDR              ;1603;
  SET  3,(HL)              ;1604;
  POP  HL                  ;1606;
  RET                      ;1607;

SIGN_4
  RST  F_ADDR              ;1608;
  SET  4,(HL)              ;1609;
  POP  HL                  ;160B;
  RET                      ;160C;

SIGN_5
  RST  F_ADDR              ;160D;
  SET  5,(HL)              ;160E;
  POP  HL                  ;1610;
  RET                      ;1611;

SIGN_6
  RST  F_ADDR              ;1612;
  SET  6,(HL)              ;1613;
  POP  HL                  ;1615;
  RET                      ;1616;

SIGN_7
  RST  F_ADDR              ;1617;
  SET  7,(HL)              ;1618;
  POP  HL                  ;161A;
  RET                      ;161B;

; ----------------------------------------------
; THE 'TEST ..' SUBROUTINES

; These subroutines are used to test the various states of the +D system.

TEST_0
  RST  F_ADDR              ;161C;
  BIT  0,(HL)              ;161D;
  POP  HL                  ;161F;
  RET                      ;1620;

TEST_1
  RST  F_ADDR              ;1621;
  BIT  1,(HL)              ;1622;
  POP  HL                  ;1624;
  RET                      ;1625;

TEST_2
  RST  F_ADDR              ;1626;
  BIT  2,(HL)              ;1627;
  POP  HL                  ;1629;
  RET                      ;162A;

TEST_3
  RST  F_ADDR              ;162B;
  BIT  3,(HL)              ;162C;
  POP  HL                  ;162E;
  RET                      ;162F;

TEST_4
  RST  F_ADDR              ;1630;
  BIT  4,(HL)              ;1631;
  POP  HL                  ;1633;
  RET                      ;1634;

TEST_5
  RST  F_ADDR              ;1635;
  BIT  5,(HL)              ;1636;
  POP  HL                  ;1638;
  RET                      ;1639;

TEST_6
  RST  F_ADDR              ;163A;
  BIT  6,(HL)              ;163B;
  POP  HL                  ;163D;
  RET                      ;163E;

TEST_7
  RST  F_ADDR              ;163F;
  BIT  7,(HL)              ;1640;
  POP  HL                  ;1642;
  RET                      ;1643;


; ===============================================================
; The error restarts

; ----------------------------------------------
; THE 'ERROR' RESTARTS

; The following 32 routines consist each of a call to the +D error routine
; directly followed by the error byte.

REP_0
  RST  DISC_ERR            ;1644;
  DEFB $00                 ;1645; 'Nonsense in G+DOS'
REP_1
  RST  DISC_ERR            ;1646;
  DEFB $01                 ;1647; 'Nonsense in GNOS'
REP_2
  RST  DISC_ERR            ;1648;
  DEFB $02                 ;1649; 'Statement END error'
REP_3
  RST  DISC_ERR            ;164A;
  DEFB $03                 ;164B; 'BREAK requested'
REP_4
  RST  DISC_ERR            ;164C;
  DEFB $04                 ;164D; ',SECTOR error'
REP_5
  RST  DISC_ERR            ;164E;
  DEFB $05                 ;164F; 'FORMAT data lost'
REP_6
  RST  DISC_ERR            ;1650;
  DEFB $06                 ;1651; 'CHECK DISC in drive'
REP_7
  RST  DISC_ERR            ;1652;
  DEFB $07                 ;1653; 'No "+ SYS " file'
REP_8
  RST  DISC_ERR            ;1654;
  DEFB $08                 ;1655; 'Invalid FILE NAME'
REP_9
  RST  DISC_ERR            ;1656;
  DEFB $09                 ;1657; 'Invalid STATION'
REP_10
  RST  DISC_ERR            ;1658;
  DEFB $0A                 ;1659; 'Invalid DEVICE'
REP_11
  RST  DISC_ERR            ;165A;
  DEFB $0B                 ;165B; 'VARIABLE not found'
REP_12
  RST  DISC_ERR            ;165C;
  DEFB $0C                 ;165D; 'VERIFY failed'
REP_13
  RST  DISC_ERR            ;165E;
  DEFB $0D                 ;165F; 'Wrong FILE type'
REP_14
  RST  DISC_ERR            ;1660;
  DEFB $0E                 ;1661; 'MERGE error'
REP_15
  RST  DISC_ERR            ;1662;
  DEFB $0F                 ;1663; 'CODE error'
REP_16
  RST  DISC_ERR            ;1664;
  DEFB $10                 ;1665; 'PUPIL set'
REP_17
  RST  DISC_ERR            ;1666;
  DEFB $11                 ;1667; 'Invalid CODE'
REP_18
  RST  DISC_ERR            ;1668;
  DEFB $12                 ;1669; 'Reading a WRITE file'
REP_19
  RST  DISC_ERR            ;166A;
  DEFB $13                 ;166B; 'Writing a READ file'
REP_20
  RST  DISC_ERR            ;166C;
  DEFB $14                 ;166D; 'O.K. G+DOS'
REP_21
  RST  DISC_ERR            ;166E;
  DEFB $15                 ;166F; 'Network OFF'
REP_22
  RST  DISC_ERR            ;1670;
  DEFB $16                 ;1671; 'Wrong DRIVE'
REP_23
  RST  DISC_ERR            ;1672;
  DEFB $17                 ;1673; 'Disc WRITE protected'
REP_24
  RST  DISC_ERR            ;1674;
  DEFB $18                 ;1675; 'Not enough SPACE on disc'
REP_25
  RST  DISC_ERR            ;1676;
  DEFB $19                 ;1677; 'Directory FULL'
REP_26
  RST  DISC_ERR            ;1678;
  DEFB $1A                 ;1679; 'File NOT FOUND'
REP_27
  RST  DISC_ERR            ;167A;
  DEFB $1B                 ;167B; 'END of file'
REP_28
  RST  DISC_ERR            ;167C;
  DEFB $1C                 ;167D; 'File NAME used'
REP_29
  RST  DISC_ERR            ;167E;
  DEFB $1D                 ;167F; 'NO G+DOS loaded'
REP_30
  RST  DISC_ERR            ;1680;
  DEFB $1E                 ;1681; 'STREAM used'
REP_31
  RST  DISC_ERR            ;1682;
  DEFB $1F                 ;1683; 'CHANNEL used'


; ===============================================================
; Miscalleneous routines II

; ----------------------------------------------
; THE 'FLASH BORDER' SUBROUTINE

; When +D system variable RBCC (address @0) doesn't hold zero, this subroutine
; flashes the border. The border colour is then obtained by masking the E
; register (holds sectornumber) with RBCC.

FLASH_BORD
  LD   A,($2000)           ;1684; Fetch RBCC.
  AND  E                   ;1687; Incorporate sectornumber.
  RET  Z                   ;1688; Return if 'no flashing'.
  AND  $07                 ;1689; Keep border colour only.
  OUT  (254),A             ;168B; Set the border and finished.
  RET                      ;168D;

; ----------------------------------------------
; THE 'BORDER COLOUR RESTORE' SUBROUTINE

; This subroutine is used whenever the border colour was changed during an I/
; O operation, and needs to be restored to its original state.

BORD_REST
  PUSH AF                  ;168E;
  LD   A,(23624)           ;168F; Fetch lower screen attribute (BORDCR).
  AND  $38                 ;1692; Only the border bits.
  RRCA                     ;1694; Move the bits to 0-2.
  RRCA                     ;1695;
  RRCA                     ;1696;
  OUT  (254),A             ;1697; Restore colour.
  POP  AF                  ;1699;
  RET                      ;169A;

; ----------------------------------------------
; THE 'PRINT DIRECTORY DESCR.' SUBROUTINE

; This subroutine is used to print the directory description of a file during
; an 'extended CAT' command. On entry the A register holds the directory
; description.

PRT_TYPE
  PUSH AF                  ;169B;
  LD   HL,TYPE_TABLE       ;169C; Start of messages table.
  LD   BC,85               ;169F; Length of table excluding 'WHAT?'.
  CPIR                     ;16A2; Make HL point to right message. HL
                                         ; points to 'WHAT?' with unknown types.
  CALL PRT_MSG_HL          ;16A4; Print the message.
  POP  AF                  ;16A7; Restore file type.
  CP   1                   ;16A8;
  JR   NZ,PRT_NOBAS        ;16AA; Jump with no 'BASIC' files.
  LD   (IX+13),219         ;16AC; Make RPT point to autostart line high.
  CALL RPT_HL1             ;16B0; HL points to it now.
  LD   A,(HL)              ;16B3;
  AND  192                 ;16B4;
  JR   NZ,PRT_EXIT         ;16B6; Jump if no autostart line present.
  LD   D,(HL)              ;16B8; Otherwise fetch it.
  DEC  HL                  ;16B9;
  LD   E,(HL)              ;16BA;
  EX   DE,HL               ;16BB;
  CALL PRT_NUM             ;16BC; Print it.
  JR   PRT_EXIT            ;16BF;

; Now the other directory descriptions are handled.

PRT_NOBAS
  CP   4                   ;16C1;
  JR   NZ,PRT_EXIT         ;16C3; Jump with no 'CODE' files.
  LD   (IX+13),215         ;16C5; RPT points to file address high byte.
  CALL RPT_HL1             ;16C9; Make HL hold RPT.
  LD   D,(HL)              ;16CC; Fetch file address.
  DEC  HL                  ;16CD;
  LD   E,(HL)              ;16CE;
  EX   DE,HL               ;16CF;
  PUSH DE                  ;16D0;
  CALL PRT_NUM             ;16D1; Print file address.
  LD   A,44                ;16D4; Print a ','.
  CALL PRT_A               ;16D6;
  POP  HL                  ;16D9;
  DEC  HL                  ;16DA;
  LD   D,(HL)              ;16DB; Fetch file length.
  DEC  HL                  ;16DC;
  LD   E,(HL)              ;16DD;
  EX   DE,HL               ;16DE;
  LD   A,0                 ;16DF; Ignore leading zero's.
  CALL PRT_N10000          ;16E1; Print the length.
PRT_EXIT
  LD   A,13                ;16E4; Print a NEWLINE and exit.
  JP   PRT_A               ;16E6;

; ----------------------------------------------
; THE 'DIRECTORY DESCRIPTION' TABLE

; This table contains the directory description messages as printed with an
; 'extended CAT'. Each message is preceeded by is description value.

TYPE_TABLE
  DEFB 1                   ;16E9;
  DEFM "BAS "              ;16EA;
  DEFB 2                   ;16EE;
  DEFM "D.ARRAY"           ;16EF;
  DEFB 3                   ;16F6;
  DEFM "$.ARRAY"           ;16F7;
  DEFB 4                   ;16FE;
  DEFM "CDE "              ;16FF;
  DEFB 5                   ;1703;
  DEFM "SNP 48k"           ;1704;
  DEFB 6                   ;170B;
  DEFM "MD.FILE"           ;170C;
  DEFB 7                   ;1713;
  DEFM "SCREEN$"           ;1714;
  DEFB 8                   ;171B;
  DEFM "SPECIAL"           ;171C;
  DEFB 9                   ;1723;
  DEFM "SNP 128k"          ;1724;
  DEFB 10                  ;172C;
  DEFM "OPENTYPE"          ;172D;
  DEFB 11                  ;1735;
  DEFM "EXECUTE"           ;1736;
  DEFB 12                  ;173D;
  DEFM "WHAT?"             ;173E;
  DEFB 0                   ;1743;

; ----------------------------------------------
; THE 'PRINT NUMBER' SUBROUTINE

; This subroutine prints the number held in the HL register. Entering the
; routine at $1744 prints leading spaces, while the other entry points prints
; the character held in the A register in place of leading zero's. A value of
; 0 means don't print anything.

PRT_NUM
  LD   A,32                ;1744; Spaces are printed in place of leading
                                         ; zero's.
  LD   DE,10000            ;1746; Start printing with tens-of-thousands.
  CALL PRT_DIGIT           ;1749;
PRT_N1000
  LD   DE,1000             ;174C; Start printing with thousands.
  CALL PRT_DIGIT           ;174F;
PRT_N100
  LD   DE,100              ;1752; Start printing with hundreds.
  CALL PRT_DIGIT           ;1755;
PRT_N10
  LD   DE,10               ;1758; Start printing with tens.
  CALL PRT_DIGIT           ;175B;
  LD   A,L                 ;175E; Print units.
  ADD  A,"0"               ;175F; Add ASCII offset for digits.
  JR   PRT_A               ;1761;

; ----------------------------------------------
; THE 'PRINT DIGIT' SUBROUTINE

; This subroutine is used to print a digit, the HL register holds the number
; and the DE register the value for 'repeated subtraction'.

PRT_DIGIT
  PUSH AF                  ;1763; Preserve leading character.
  XOR  A                   ;1764; Clear Carry and counter.
PRT_DIG1
  SBC  HL,DE               ;1765; The 'trial' subtraction.
  JR   C,PRT_DIG2          ;1767; Jump if exhausted.
  INC  A                   ;1769; Count each trial.
  JR   PRT_DIG1            ;176A; Jump back for next try.

; The A register now holds the digit to be printed.

PRT_DIG2
  ADD  HL,DE               ;176C; Restore last subtraction.
  AND  A                   ;176D;
  JR   NZ,PRT_DIG3         ;176E; Jump if a non zero value is to be
                                         ; printed.
  POP  DE                  ;1770; Retrieve the leading character into D.
  ADD  A,D                 ;1771; Add it to zero.
  RET  Z                   ;1772; Return if nothing has to be printed.
  JR   PRT_A               ;1773; Otherwise print the leading character.

; Now print the digit.

PRT_DIG3
  ADD  A,"0"               ;1775; Add ASCII offset for digits.
  CALL PRT_A               ;1777; Print the digit.
  POP  DE                  ;177A; Balance the stack.
  LD   A,"0"               ;177B; All zeroes after any non zero digit
  RET                      ;177D; will be printed as '0'.

; ----------------------------------------------
; THE 'PRINT OUT MESSAGE' SUBROUTINE

; This subroutine handles the printing of messages directly following the
; 'CALL' instruction to this routine. When the +D's own error stack pointer
; (D_ERR_SP) holds a non-zero value, i.e during hook and command codes, no
; printing has to take place. The carry flag is set and the A register then
; holds 32, signalling 'error during hook/command code execution' as usual.

PO_MSG
  LD   HL,($2066)          ;177E; Fetch (D_ERR_SP).
  LD   A,H                 ;1781;
  OR   L                   ;1782;
  JR   Z,PO_MSG1           ;1783; Jump if it isn't used.
  LD   SP,HL               ;1785; Clear machine stack.
  LD   A,32                ;1786; Signal 'error 32'.
  SCF                      ;1788;
  RET                      ;1789; Exit.

; Now the message can be printed.

PO_MSG1
  POP  HL                  ;178A; HL points to the message to be printed
PO_MSG2
  LD   A,(HL)              ;178B; Fetch a character.
  AND  $7F                 ;178C;
  CALL PRT_A               ;178E; Print it.
  BIT  7,(HL)              ;1791; Bit 7 set signals 'End of message'.
  RET  NZ                  ;1793;
  INC  HL                  ;1794;
  JR   PO_MSG2             ;1795; Repeat for all characters.

; ----------------------------------------------
; THE 'PRINT A SPACE' SUBROUTINE

; This subroutine prints a space to the current stream.

PRT_SPACE
  LD   A,32                ;1797; Continue in the 'PRT_A' routine.

; ----------------------------------------------
; THE 'PRINT CHARACTER' SUBROUTINE

; This subroutine prints the character held in the A register to the current
; stream.

PRT_A
  PUSH AF                  ;1799;
  PUSH BC                  ;179A;
  PUSH DE                  ;179B;
  PUSH HL                  ;179C;
  PUSH IX                  ;179D;
  RST  CALBAS              ;179F; Print the character in the A register
  DEFW PRINT_A_1           ;17A0; by calling the 'main' ROM routine.
  POP  IX                  ;17A2;
  POP  HL                  ;17A4;
  POP  DE                  ;17A5;
  POP  BC                  ;17A6;
  POP  AF                  ;17A7;
  RET                      ;17A8;

; ----------------------------------------------
; THE 'ROM' MESSAGES

; Now follow some messages used by the +D system.

MESG_0
  CALL PO_MSG              ;17A9;
  DEFB $0D,$0D,$0D,$0D,$0D,$0D;17AC;
  DEFM "        "SYSTEM" LOADING";17B2;
  DEFB $0D,$0D             ;17CA;
  DEFM "          PLEASE  WAIT";17CC;
  DEFB $0D,$0D             ;17E2;
  DEFM "        (+D ROM Ver 1.A)";17E4;
  DEFB $0D,$8D             ;17FC;

MESG_1
  CALL PO_MSG              ;17FE;
  DEFM "OVERWRITE "        ;1801;
  DEFB '"'+128             ;180B;

MESG_2
  CALL PO_MSG              ;180C;
  DEFM "Are you SURE ? (y/n";180F;
  DEFB ")"+128             ;1822;

MESG_3
  CALL PO_MSG              ;1823;
  DEFM " (y/n)"            ;1826;
  DEFB ")"+128             ;182C;


; ===============================================================
; The error routines

; ----------------------------------------------
; THE '+D ERROR' ROUTINE

; Whenever a +D error is encountered this routine is executed to handle it.
; During syntax checking the error is handled by the 'main' ROM error handler.
; Whenever an error is found while executing a command code, a return is made
; with the Carry flag set and the A register holding the error number. Only
; during runtime the error message is printed.

D_ERROR
  CALL BORD_REST           ;182D; Restore normal border colour.
  LD   ($3DED),DE          ;1830; Track & sector with sector error.
  XOR  A                   ;1834;
  LD   ($3ACF),A           ;1835; Clear FLAGS3.
  POP  HL                  ;1838; Fetch return address.
  LD   DE,($2066)          ;1839; Fetch (D_ERR_SP).
  LD   A,D                 ;183D;
  OR   E                   ;183E;
  LD   A,(HL)              ;183F; Fetch error code.
  JR   Z,D_ERROR1          ;1840; Jump if (D_ERR_SP) isn't used.

; Whenever hook or command codes are being executed, errors are reported to
; the calling routine by setting the carry flag. The A register holds the
; error code.

  LD   SP,($2066)          ;1842; Clear the machine stack.
  SCF                      ;1846; Carry set to signal 'error'.
  RET                      ;1847;

; The routine continues here when an error message is to be printed.

D_ERROR1
  LD   (23610),A           ;1848; Store error code into (ERR_NR).
  RES  5,(IY+1)            ;184B; Signal 'ready for a new key'.
  LD   SP,(23613)          ;184F; Clear machine stack by using (ERR_SP).
  RST  SYNTAX_Z            ;1853; Return via 'main' ROM 'SET_STK'
  LD   HL,SET_STK          ;1854; routine to the error handler during
  JP   Z,UNPAGE_HL         ;1857; syntax checking.
  LD   HL,0                ;185A;
  LD   (IY+55),H           ;185D; Clear FLAGX.
  LD   (IY+38),H           ;1860; And X_PTR-hi.
  LD   (23563),HL          ;1863; Clear DEFADD.
  INC  L                   ;1866; Ensure that stream 0 points to channel
  LD   (23574),HL          ;1867; 'K'.
  RST  CALBAS              ;186A; Clear all the work areas and the
  DEFW SET_MIN             ;186B; calculator stack.
  LD   A,(23728)           ;186D;
  AND  A                   ;1870; Exit via 'END' if error messages are
  JP   NZ,END              ;1871; to be supressed.
  RES  5,(IY+55)           ;1874; Signal 'EDIT mode' FLAGX.
  RST  CALBAS              ;1878; Clear the lower screen.
  DEFW CLS_LOWER           ;1879;
  SET  5,(IY+2)            ;187B; Signal 'lower screen will require
                                         ; clearing'. (TV_FLAG)
  RES  3,(IY+2)            ;187F; Signal 'mode is to be considered
                                         ; unchanged'.
  LD   A,(23610)           ;1883;
  CP   4                   ;1886;
  JR   NZ,D_ERROR2         ;1888; Jump if error isn't 'SECTOR error'.
  PUSH AF                  ;188A;
  LD   DE,($3DED)          ;188B; Fetch track and sector where error
  LD   H,0                 ;188F; was signalled.
  LD   L,D                 ;1891;
  PUSH DE                  ;1892;
  XOR  A                   ;1893; Print the track number, no leading
  CALL NUM_100             ;1894; characters.
  LD   A,58,":"            ;1897; Print a colon.
  CALL PRT_A               ;1899;
  POP  DE                  ;189C;
  LD   H,0                 ;189D;
  LD   L,E                 ;189F;
  XOR  A                   ;18A0; Print the sector number, no leading
  CALL NUM_10              ;18A1; characters.
  POP  AF                  ;18A4;

; The routine now continues with the printing of the error message.

D_ERROR2
  LD   HL,ERR_MSGS         ;18A5; HL points to the error message table.
  LD   BC,503              ;18A8; Length of error message table.
  CPIR                     ;18AB; Search for the message.
  CALL PRT_MSG_HL          ;18AD; Print it.
  INC  SP                  ;18B0; Drop address of 'main' ROM error
  INC  SP                  ;18B1; handler.
  LD   HL,MAIN_5A          ;18B2; Print the line and statement number by
  JP   UNPAGE_HL           ;18B5; jumping into the Spectrum error
                                         ; handler.

; ----------------------------------------------
; THE 'PRINT MESSAGE HL' SUBROUTINE

; This subroutine prints the message pointed to by the HL register.

PRT_MSG_HL
  LD   A,(HL)              ;18B8; Fetch a character.
  CP   32                  ;18B9;
  RET  C                   ;18BB; Exit if it isn't printable, message is
                                         ; finished.
  CALL PRT_A               ;18BC; Print the character.
  INC  HL                  ;18BF;
  JR   PRT_MSG_HL          ;18C0; Continue until message end is reached.

; ----------------------------------------------
; THE 'ERROR MESSAGES' TABLE

; The following table contains the +D's error messages. Each message starts
; with it's error number.

ERR_MSGS
  DEFB $00                 ;18C2;
  DEFM "Nonsense in G+DOS" ;18C3;
  DEFB $01                 ;18D4;
  DEFM "Nonsense in GNOS"  ;18D5;
  DEFB $02                 ;18E5;
  DEFM "Statement END error";18E6;
  DEFB $03                 ;18F9;
  DEFM "BREAK requested"   ;18FA;
  DEFB $04                 ;1909;
  DEFM ",SECTOR error"     ;190A;
  DEFB $05                 ;1917;
  DEFM "FORMAT data lost"  ;1918;
  DEFB $06                 ;1928;
  DEFM "CHECK DISC in drive";1929;
  DEFB $07                 ;193C;
  DEFM "No "+ SYS  " file" ;193D;
  DEFB $08                 ;194D;
  DEFM "Invalid FILE NAME" ;194E;
  DEFB $09                 ;195F;
  DEFM "Invalid STATION"   ;1960;
  DEFB $0A                 ;196F;
  DEFM "Invalid DEVICE"    ;1970;
  DEFB $0B                 ;197E;
  DEFM "VARIABLE not found";197F;
  DEFB $0C                 ;1991;
  DEFM "VERIFY failed"     ;1992;
  DEFB $0D                 ;199F;
  DEFM "Wrong FILE type"   ;19A0;
  DEFB $0E                 ;19AF;
  DEFM "MERGE error"       ;19B0;
  DEFB $0F                 ;19BB;
  DEFM "CODE error"        ;19BC;
  DEFB $10                 ;19C6;
  DEFM "PUPIL set"         ;19C7;
  DEFB $11                 ;19D0;
  DEFM "Invalid CODE"      ;19D1;
  DEFB $12                 ;19DD;
  DEFM "Reading a WRITE file";19DE;
  DEFB $13                 ;19F2;
  DEFM "Writing a READ file";19F3;
  DEFB $14                 ;1A06;
  DEFM "O.K. G+DOS"        ;1A07;
  DEFB $15                 ;1A11;
  DEFM "Network OFF"       ;1A12;
  DEFB $16                 ;1A1D;
  DEFM "Wrong DRIVE"       ;1A1E;
  DEFB $17                 ;1A29;
  DEFM "Disc write PROTECTED";1A2A;
  DEFB $18                 ;1A3E;
  DEFM "Not enough SPACE on disc";1A3F;
  DEFB $19                 ;1A57;
  DEFM "Directory FULL"    ;1A58;
  DEFB $1A                 ;1A66;
  DEFM "File NOT FOUND"    ;1A67;
  DEFB $1B                 ;1A75;
  DEFM "END of file"       ;1A76;
  DEFB $1C                 ;1A81;
  DEFB "File NAME used"    ;1A82;
  DEFB $1D                 ;1A90;
  DEFM "NO G+DOS loaded"   ;1A91;
  DEFB $1E                 ;1AA0;
  DEFM "STREAM used"       ;1AA1;
  DEFB $1F                 ;1AAC;
  DEFM "CHANNEL used"      ;1AAD;
  DEFB $00                 ;1AB9;

; $1ABA..$1FFF Unused locations (All filled with $FF)


; ===============================================================
; The +D system variables and tables

; ----------------------------------------------
; THE 'SYSTEM VARIABLES'

; These variables hold various settings for drives etc. The variables starting
; at address $2000 can be accessed from BASIC with POKE @p,n. Where p is 0 for
; RBCC at $2000.

RBCC
  DEFB $07                 ;2000; Flashing borders.
TRAKS1
  DEFB 80+128              ;2001; Drive 1 80 tracks double sided.
TRAKS2
  DEFB 80+128              ;2002; Drive 2 80 tracks double sided.
STPRAT
  DEFB 0                   ;2003; "Steprate" 0 msec.
NSTAT
  DEFB 1                   ;2004; Network on?
WIDTH
  DEFB 80                  ;2005; Printer right margin.
PCODE
  DEFB 0                   ;2006; Expand tokens, etc. before printing.
LSPCE
  DEFB 12                  ;2007; Line spacing 12/72 inch.
LFEED
  DEFB 1                   ;2008; Number of line feeds after CR 1.
LMARG
  DEFB 0                   ;2009; Left margin at 0.
GRAPH
  DEFB 0                   ;200A; Print special graphics off.
ZXPNT
  DEFB 0                   ;200B; +D printer port on.
RESERVED
  DEFW $0000               ;200C;
ONERR
  DEFW $0000               ;200E; Address of routine called after an
                                         ; error has occurred.
EVERY_INT
  DEFW $208F               ;2010; Address of routine called at every
                                         ; interrupt.

; ----------------------------------------------
; THE 'PRINTER CODES' TABLE

; Here the printer control codes are stored.

; XXX TODO -- rename labels, these are the default data

INIT_PRT
  DEFB 27,"@",$80,$80      ;2012;
  DEFB $80,$80,$80,$80     ;2016;
CHAR_PITCH
  DEFB $80,$80,$80,$80     ;201A;
  DEFB $80,$80,$80,$80     ;201E;
N_per_72_LSPC
  DEFB 27,"A",$80,$80      ;2022;
  DEFB $80,$80,$80,$80     ;2026;
GRAPH_DPI
  DEFB 27,"*",5,$80        ;202A;
  DEFB $80,$80,$80,$80     ;202E;
INIT_PRT2
  DEFB $80,$80,$80,$80     ;2032;
  DEFB $80,$80,$80,$80     ;2036;

; ----------------------------------------------
; THE 'GRAPHIC REPRESENTATION' TABLE

; This table consists of the graphic representations of the £, # and © signs.
; The 'GRAPH' system variable (@10) determines whether the normal code or the
; graphic representation is outputted to the printer.

pound_sign
  DEFB %00011000           ;203A;
  DEFB %00100000           ;203B;
  DEFB %00100000           ;203C;
  DEFB %01111000           ;203D;
  DEFB %00100000           ;203E;
  DEFB %00100000           ;203F;
  DEFB %01111100           ;2040;
  DEFB %00000000           ;2041;

hash_sign
  DEFB %00000000           ;2042;
  DEFB %00100100           ;2043;
  DEFB %01111110           ;2044;
  DEFB %00100100           ;2045;
  DEFB %00100100           ;2046;
  DEFB %01111110           ;2047;
  DEFB %00100100           ;2048;
  DEFB %00000000           ;2049;

copyright_sign
  DEFB %01111110           ;204A;
  DEFB %10000001           ;204B;
  DEFB %10111101           ;204C;
  DEFB %10100001           ;204D;
  DEFB %10100001           ;204E;
  DEFB %10111101           ;204F;
  DEFB %10000001           ;2050;
  DEFB %01111110           ;2051;

; ----------------------------------------------
; THE 'GREYSCALE' PRINTER CONTROL CODE

; This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

GREY_BITIM
  DEFB 27,"*",5,$40        ;2052;
  DEFB $02,$80,$80,$80     ;2056;

; ----------------------------------------------
; THE 'GREYSCALE' TABLE

; This table consists of three times three bytes of greyscale info. Each
; screen pixel is converted into 3x3 printer dots during greyscale printing.
; The printer dots are ordered as follows: The first dot row is produced from
; the first three bytes by taking the bit, which number is corresponding with
; the colour number, from each of the three bytes. E.g.  for colour 2 (=red)
; bit 2 is used. In the same way the second and third dot rows are produced
; from the second and third three bytes respectively.  The following eight 3x3
; matrices are produced:

 W
  hite  Yellow  Cyan  Green Magenta  Red    Blue  Black
  000    000    100    000    100    010    110    111
  000    010    010    101    111    111    111    111
  000    000    001    000    001    010    011    111

; Note that some greytones aren't right. E.g. cyan is darker than green, which
; isn't so on the screen.

;                      colour
;                     76543210

GREYSCALE
  DEFB %00101011           ;205A;
  DEFB %00011111           ;205B; first row
  DEFB %00000001           ;205C;

  DEFB %00000111           ;205D;
  DEFB %01101111           ;205E; second row
  DEFB %00000111           ;205F;

  DEFB %00000001           ;2060;
  DEFB %00011111           ;2061; third row
  DEFB %00101011           ;2062;

  DEFW P_ALL               ;2063; Address of 'output' routine for "P".
  DEFB $00                 ;2065; The 'ENTER' flag.
  DEFW $0000               ;2066; D_ERR_SP
  DEFB $00                 ;2067;

; ----------------------------------------------
; THE 'SNAPSHOT-FILE' UFIA

; The following bytes are the last 20 bytes of a snapshot file UFIA.

SNAP_UFIA
  DEFB 0                   ;2068; Directory description.
  DEFM "Snap      "        ;2069; File name.
  DEFB 3                   ;2073; File type.
  DEFW $0000               ;2074; File length.
  DEFW $0000               ;2076; File address.
  DEFW $0000               ;2078; Not used with Snap's.
  DEFW $FFFF               ;207A; Not used with Snap's.

; ----------------------------------------------
; SOME 'LOST' ASSEMBLER TEXT

; Miles-Gordon seem to have lost some of their assembler text.

  DEFM "JP"                ;207C;
  DEFB $07                 ;207E;
  DEFB "Z"                 ;207F;

; ----------------------------------------------
; THE 'RAM JUMPS'

; These 13 'jumps' are used from the ROM to call +D System routines present in
; RAM (after the System file has been loaded).

JCOPS
  NOP                      ;2080; The small dump isn't patched.
  NOP                      ;2081;
  RET                      ;2082;
JCOPS2
  NOP                      ;2083; Neither is the greyscale dump.
  NOP                      ;2084;
  RET                      ;2085;
JPCHAN
  NOP                      ;2086; Nor the PCHAN_OUT routine.
  NOP                      ;2087;
  RET                      ;2088;
JPOKE
  NOP                      ;2089; Nor the POKE routine.
  NOP                      ;208A;
  RET                      ;208B;
JPRTR
  NOP                      ;208C; Even the TAKE_PRTR routine isn't
  NOP                      ;208D; patched.
  RET                      ;208E;
JJIFFY
  NOP                      ;208F; Called EVERY_INT.
  NOP                      ;2090;
  RET                      ;2091;
JLOAD
  JP   LD_VF_MR1           ;2092; Load the file.
JHXFER
  JP   HXFER               ;2095; Transfer UFIA to DFCA.
JKSCAN
  JP   JIFFY               ;2098; Called every interrupt.
JMSG3
  JP   MSG_3               ;209B; Give the copyright message.
JHOOK
  JP   HOOK_CODE           ;209E; Execute the hook or command code.
JSNAP
  JP   SNAP                ;20A1; Continue with the Snapshot routine.
JCTRL
  JP   CTRL                ;20A4; Continue with the control routine.

; ----------------------------------------------
; THE 'CONTROL ROUTINE' CONTINUED

; The final part of the control routine determines which command failed the
; Spectrum syntax. If it is a +D command then the apropriate routine is
; executed.

CTRL
  PUSH AF                  ;20A7;
  LD   HL,$3DF4            ;20A8;
  LD   BC,60               ;20AB;
RESET_VARS
  LD   (HL),255            ;20AE; Reset +D work areas, including UFIA1
  INC  HL                  ;20B0; and UFIA2.
  DEC  BC                  ;20B1;
  LD   A,B                 ;20B2;
  OR   C                   ;20B3;
  JR   NZ,RESET_VARS       ;20B4;
  LD   ($3ACF),A           ;20B6; Clear FLAGS3.
  LD   IX,DFCA             ;20B9;
  POP  AF                  ;20BD; Fetch the command.
  LD   ($3DFF),A           ;20BE; Store it.
  CP   207                 ;20C1; Is the command 'CAT' ?
  JP   Z,CAT               ;20C3; Jump to the CAT routine if so.
  CP   208                 ;20C6; Also for 'FORMAT',...
  JP   Z,FORMAT            ;20C8;
  CP   209                 ;20CB; ...'MOVE',...
  JP   Z,MOVE              ;20CD;
  CP   210                 ;20D0; ...'ERASE',...
  JP   Z,ERASE             ;20D2;
  CP   211                 ;20D5; ...'OPEN #',...
  JP   Z,OPEN              ;20D7;
  CP   212                 ;20DA; ...'CLOSE #',...
  JP   Z,CLOSE             ;20DC;
  CP   213                 ;20DF; ...'MERGE',...
  JP   Z,MERGE             ;20E1;
  CP   214                 ;20E4; ...'VERIFY',...
  JP   Z,VERIFY            ;20E6;
  CP   239                 ;20E9; ...'LOAD',...
  JP   Z,LOAD              ;20EB;
  CP   248                 ;20EE; ...'SAVE',...
  JP   Z,SAVE              ;20F0;
  CP   251                 ;20F3; ...'CLS',...
  JP   Z,CLS               ;20F5;
  CP   253                 ;20F8; ...'CLEAR',...
  JP   Z,CLEAR             ;20FA;
  CP   255                 ;20FD; ...'COPY',...
  JP   Z,COPY              ;20FF;
  LD   HL,($200E)          ;2102; Fetch ONERR address.
  LD   A,H                 ;2105;
  OR   L                   ;2106;
  RET  Z                   ;2107; Return if no ON ERROR address.
  LD   ($2110),HL          ;2108; Store it so it can be CALBASsed.
  POP  HL                  ;210B; Drop return address.
  LD   A,($3DFF)           ;210C; Fetch command which has to be examined
  RST  CALBAS              ;210F; by user-routine (BASIC extensions).
  DEFW $0000               ;2110; CALL the extend BASIC routine(s).
  JP   END                 ;2112; Test end of command and exit.

; ----------------------------------------------
; THE 'SNAPSHOT ROUTINE' CONTINUED

; Here the snapshot routine continues with the disk related functions, keys
; 3-5.

SNAP
  LD   HL,16384            ;2115; start of RAM (also start of SCR$).
  BIT  2,E                 ;2118;
  JR   NZ,NO_SCR           ;211A; 3: Save SCREEN$.
  LD   A,7                 ;211C; type=SCR$.
  LD   DE,6912             ;211E; length of SCR$.
  JR   SNAP_SAVE           ;2121;

NO_SCR
  BIT  3,E                 ;2123;
  JR   NZ,NO_SNP48         ;2125; 4: 48K Snapshot.
  LD   A,5                 ;2127; type=48K Snap.
  LD   DE,49152            ;2129; length of 48K RAM.
  JR   SNAP_SAVE           ;212C;

NO_SNP48
  BIT  4,E                 ;212E;
  RET  NZ                  ;2130; Exit if not 5: 128K Snapshot.
  LD   A,9                 ;2131; Type=128K Snap.
  LD   DE,16384            ;2133; Length of a RAM-page.
  LD   HL,49152            ;2136; Start of a RAM-page.
SNAP_SAVE
  LD   ($2068),A           ;2139; Store type in snapshot UFIA.
  LD   ($2074),DE          ;213C; Store length in UFIA.
  LD   ($2076),HL          ;2140; And the start-address.
  POP  AF                  ;2143; Drop return addres.
  LD   B,$FE               ;2144; Key CAPS-V I/O address.
  IN   A,(C)               ;2146;
  BIT  0,A                 ;2148;
  JR   NZ,SNAP_NAME        ;214A; If CAPS is pressed the Snap goes to
  LD   A,($3ACE)           ;214C; the other drive.
  XOR  $03                 ;214F;
  LD   ($3ACE),A           ;2151;
SNAP_NAME
  LD   A,%01000000         ;2154;
  CALL SCAN_CAT            ;2156; Search first free catalogue entry.
  RET  NZ                  ;2159; Exit if catalogue full.
  LD   A,D                 ;215A; Track to A.
  AND  $07                 ;215B; Jump if CAT-entry will be located
  JR   Z,SNAP_N1           ;215D; on track 0.

; The name a snapshot-file is given, depends on the position it's going to
; occupy in the directory. When the entry will be located on the first track
; the names range from 'Snap A' to 'Snap T', if however the entry will be
; located on track 1 to 3 the character after 'Snap' will be the track number.
; I.e. 'Snap1A' to 'Snap1T' for track 1, etc.  Notice that the character after
; 'Snap' is never set to a ' '.

  ADD  A,48                ;215F; ASCII offset for '0'.
  LD   ($206D),A           ;2161; Store a 1, 2 or 3 in name-part of UFIA.
SNAP_N1
  LD   L,E                 ;2164; Store sector in L.
  SLA  L                   ;2165; Two entries per sector.
  DEC  L                   ;2167;
  LD   A,(IX+14)           ;2168; Is it the first or second entry in the
  ADD  A,L                 ;216B; CAT-sector.
  ADD  A,64                ;216C; Add ASCII 'A' offset.
  LD   ($206E),A           ;216E; Store 'A' to 'T' in name-part of UFIA.
  LD   HL,SNAP_UFIA        ;2171; Copy UFIA to DFCA.
  LD   DE,$3E05            ;2174;
  LD   BC,20               ;2177;
  LDIR                     ;217A;
  CALL OFSM_2              ;217C; Open the file.
  LD   HL,$3FEA            ;217F; Copy snap registers to catalogue entry.
  LD   DE,$3BB2            ;2182;
  LD   BC,22               ;2185;
  LDIR                     ;2188;
  LD   A,($2068)           ;218A; Get directory description.
  CP   9                   ;218D;
  JP   NZ,NO_SNP128        ;218F; Jump if not a 128K Snapshot.
  LD   HL,49152            ;2192; Now the 5 first bytes of the current
  LD   DE,$3BD6            ;2195; RAM-page are saved in the +D RAM
  LD   BC,5                ;2198; and replaced by the "BRUCE" message.
  LDIR                     ;219B; This is done to determine the currently
  LD   HL,BRUCE            ;219D; paged in RAM-page.
  LD   DE,49152            ;21A0;
  LD   BC,5                ;21A3;
  LDIR                     ;21A6;
  XOR  A                   ;21A8; Signal '128K ROM bank active'.
  LD   ($3E19),A           ;21A9;
  CALL D_ROMBANK           ;21AC; Determine current 'main' ROM bank.
  JR   NZ,SNP128_1         ;21AF; Jump if 128K ROM bank.
  LD   A,$10               ;21B1; Signal '48K ROM bank active'.
  LD   ($3E19),A           ;21B3;
SNP128_1
  CALL REST_PBUF           ;21B6; Restore printer buffer contents.
  LD   A,($3E19)           ;21B9;
  CALL RAMPAGE_A           ;21BC; Page in current ROM bank & RAM page 0.

; The code now tests which screen is active. Because it isn't possible to
; detect which is the active screen, the user is consulted. By making nice
; border stripes the user is signalled that 'Y' (meaning: yes, screen changed)
; or 'N' (meaning: no, screen hasn't changed) has to be pressed.

SNP128_2
  LD   BC,$DFFE            ;21BF; Keyboard port and I/O address for Y-P.
  IN   E,(C)               ;21C2;
  BIT  4,E                 ;21C4;
  JR   Z,CHANGED_S         ;21C6; Jump if 'Y' was pressed, screen changed
  LD   B,$7F               ;21C8; I/O address for B-SPACE.
  IN   E,(C)               ;21CA;
  BIT  3,E                 ;21CC;
  JR   Z,SAME_S            ;21CE; Jump if 'N' was pressed, same screen.
  INC  A                   ;21D0;
  AND  $07                 ;21D1;
  OUT  (C),A               ;21D3; Make nice stripes in border again.
  JR   SNP128_2            ;21D5; Only 'Y' or 'N' is accepted.

CHANGED_S
  LD   A,($3E19)           ;21D7;
  OR   $08                 ;21DA; Signal 'screen 1'.
N_RAMBANK
  LD   ($3E19),A           ;21DC;
  CALL RAMPAGE_A           ;21DF; Page in active ROM bank and screen.

; Now the 'which RAM bank' test is executed. The active RAM bank is determined
; by searching which bank has been given the "BRUCE" message.

SAME_S
  LD   DE,49152            ;21E2; Here the message has been placed.
  LD   HL,BRUCE            ;21E5; Message to be found.
  LD   B,5                 ;21E8; There are five bytes in the message.
BRUCE_1
  LD   A,(DE)              ;21EA;
  CP   (HL)                ;21EB;
  JR   Z,BRUCE_2           ;21EC; Jump if characters match.
  LD   A,($3E19)           ;21EE; Otherwise it has to be one of the other
  INC  A                   ;21F1; banks.
  JR   N_RAMBANK           ;21F2;

BRUCE_2
  INC  DE                  ;21F4;
  INC  HL                  ;21F5;
  DJNZ BRUCE_1             ;21F6; All five characters have to match.
  LD   HL,$3BD6            ;21F8; The active RAM bank has been found,
  LD   DE,49152            ;21FB; restore the original five bytes.
  LD   BC,5                ;21FE;
  LDIR                     ;2201;
  LD   A,($3E19)           ;2203;
  PUSH AF                  ;2206; Save the page-configuration byte in the
  CALL SBYT                ;2207; snapshot file.
  AND  $F8                 ;220A; Mask RAM bank, start with 0.
  LD   B,8                 ;220C; There are eight RAM banks
SAVE_BANK
  PUSH AF                  ;220E;
  PUSH BC                  ;220F;
  CALL RAMPAGE_A           ;2210; Page in RAM bank.
  LD   HL,($2076)          ;2213;
  LD   DE,($2074)          ;2216;
  CALL HSVBK_2             ;221A; Save DE bytes starting at address HL.
  POP  BC                  ;221D;
  POP  AF                  ;221E;
  INC  A                   ;221F; Next RAM bank.
  DJNZ SAVE_BANK           ;2220; Loop for all eight 16K RAM banks.
  POP  AF                  ;2222;
  CALL RAMPAGE_A           ;2223; Page in original RAM bank.
  JR   SNAP_CLOSE          ;2226;

BRUCE
  DEFM "BRUCE"             ;2228;

NO_SNP128
  CP   7                   ;222D; Copy the 9 header bytes to the file if
  CALL Z,SAVE_HEAD1        ;222F; it is a SCREEN$.
  LD   HL,($2076)          ;2232;
  LD   DE,($2074)          ;2235;
  CALL HSVBK_2             ;2239; Save DE bytes starting at address HL.
SNAP_CLOSE
  JP   CFSM                ;223C; Close the file.

; ----------------------------------------------
; THE 'PAGE 128K RAM' ROUTINE

; The 128K RAM-bank contained in the A register is paged-in.

RAMPAGE_A
  LD   BC,$7FFD            ;223F; 128K bank-switch port address.
  OUT  (C),A               ;2242; Select RAM bank.
  RET                      ;2244;

; ----------------------------------------------
; THE 'JIFFY' CALL

; This routine is executed whenever KEY-SCAN in the Spectrum ROM is reached at
; $028E. It can be used to executed a routine with every interrupt.

JIFFY
  LD   HL,($2010)          ;2245; Call routine which has to be called
  JP   (HL)                ;2248; every 'interrupt'. (Normal $208F)


; ----------------------------------------------
; THE 'MOUSE' ROUTINE

; This routine is also present in the DISCiPLE and tests a mouse-like device.
; Pointers which seem to keep track of screen coordinates are updated when
; necessary.

TEST_MOUSE
  LD   BC,$03FF            ;2249; The MGT mouse port?
  IN   A,(C)               ;224C;
  BIT  7,A                 ;224E;
  RET  NZ                  ;2250; Return if no activity.
  CPL                      ;2251;
  AND  $05                 ;2252; Return if there was no horizontal or
  RET  Z                   ;2254; vertical movement.
  LD   HL,SIGN_MOUSE       ;2255;
  PUSH HL                  ;2258;
  LD   HL,MOVE_VERT        ;2259;
  PUSH HL                  ;225C;
  IN   D,(C)               ;225D; Read mouse bits again.
  LD   HL,$3DF1            ;225F; Mouses x-coordinate.
  BIT  0,D                 ;2262;
  RET  NZ                  ;2264; Return to vertical movement test.
  BIT  1,D                 ;2265;
  JR   Z,MOVE_RIGHT        ;2267; Jump if mouse was moved right.
  LD   A,0                 ;2269; Left side of screen.
  CP   (HL)                ;226B;
  RET  Z                   ;226C; Return if left movement isn't possible.
  DEC  (HL)                ;226D; Otherwise decrement x-coordinate.
  RET                      ;226E;

MOVE_RIGHT
  LD   A,255               ;226F; Right side of screen.
  CP   (HL)                ;2271;
  RET  Z                   ;2272; Return if right movement impossible.
  INC  (HL)                ;2273; Otherwise increment x.
  RET                      ;2274;

MOVE_VERT
  LD   HL,$3DF2            ;2275; Y-coordinate of mouse.
  BIT  2,D                 ;2278;
  RET  NZ                  ;227A; Return to signal mouse.
  BIT  3,D                 ;227B;
  JR   NZ,MOVE_UP          ;227D; Jump if mouse was moved up.
  LD   A,0                 ;227F; Bottom side of screen.
  CP   (HL)                ;2281;
  RET  Z                   ;2282; Return if bottom has been reached.
  DEC  (HL)                ;2283; Otherwise move towards it.
  RET                      ;2284;

MOVE_UP
  LD   A,175               ;2285; Top side of screen.
  CP   (HL)                ;2287;
  RET  Z                   ;2288; Return if top was reached.
  INC  (HL)                ;2289; Otherwise increment y-coordinate.
  RET                      ;228A;

SIGN_MOUSE
  OUT  (C),D               ;228B; Give original signal to mouse.
  RET                      ;228D;


; ===============================================================
; The Hook and Command code routine & The Command code table

; This routine is entered with the A register holding an 'IF1 hook code', a
; '+D command code' or an invalid error code. The routine calls a set of
; subroutines in the +D system, and is intended to help machine-code access to
; the drives. There are two tables containing addresses of the routines, the
; first is located in ROM (at $0DD7) and consists of the addresses of the
; routines for the IF1 hookcodes. The second table is located at address $22DE
; and consists of the addresses of the +D command code routines.

HOOK_CODE
  LD   ($3AC5),DE          ;228E;
  CP   24                  ;2292;
  JR   NC,COMM_CODE        ;2294; Jump if code isn't a hook code.
  LD   DE,IF1_HOOK         ;2296; Address of hook (IF1) code table.
CODE_CONT
  LD   (IY+0),$FF          ;2299; Clear error.
  SET  2,(IY+1)            ;229D; What's the purpose of this?
  INC  HL                  ;22A1; Advance return address past the code.
  PUSH HL                  ;22A2;
  ADD  A,A                 ;22A3; Table is made of two byte addresses, so
  LD   L,A                 ;22A4; double code.
  LD   H,0                 ;22A5;
  ADD  HL,DE               ;22A7; Point codes entry in table.
  LD   E,(HL)              ;22A8; Fetch the address of the routine.
  INC  HL                  ;22A9;
  LD   D,(HL)              ;22AA;
  LD   HL,HOOK_RET         ;22AB; Return address after completion of
  PUSH HL                  ;22AE; code.
  LD   ($2066),SP          ;22AF; Set D_ERR_SP.
  EX   DE,HL               ;22B3;
  LD   DE,($3AC5)          ;22B4; Restore DE and A.
  LD   A,( $3E4F)          ;22B8;
  JP   (HL)                ;22BB; Jump to the routine.

COMM_CODE
  SUB  24                  ;22BC; Adjust range for command codes
(0
  ..20).
  CP   21                  ;22BE;
  JP   NC,REP_17           ;22C0; Give error if not a command code.
  LD   DE,MGT_HOOK         ;22C3; Address of command code table.
  JR   CODE_CONT           ;22C6; Continue with command codes.

; ----------------------------------------------
; THE 'HOOK_RET' ROUTINE

; This routine is entered whenever a hook or command code is finished.

HOOK_RET
  PUSH HL                  ;22C8;
  LD   HL,$0000            ;22C9;
  LD   ($2066),HL          ;22CC; Clear D_ERR_SP.
  POP  HL                  ;22CF;
  CALL BORD_REST           ;22D0; Return to the calling routine with the
  JP   UNPAGE_1            ;22D3; 'main' ROM paged in.

; ----------------------------------------------
; THE 'PAGE-IN +D' SUBROUTINE

; This is called by using 'command code' 71. On return the +D is paged-in and
; the HL register contains 0, to indicate that this is a +D (with a DISCiPLE
; HL holds 1).

PATCH
  POP  HL                  ;22D6; Drop 'HOOK_RET' return address.
  LD   HL,$0000            ;22D7; Clear 'D_ERR_SP'.
  LD   ($2066),HL          ;22DA;
  RET                      ;22DD; HL=0, meaning 'this is a +D'.

; ----------------------------------------------
; THE 'COMMAND CODE ADRESSES' TABLE

; This jump table consists of the 21 addresses of the routines called by using
; the various 'command codes'.

MGT_HOOK
  DEFW HXFER               ;22DE; Command code $33, 51.
  DEFW OFSM                ;22E0; Command code $34, 52.
  DEFW HOFLE               ;22E2; Command code $35, 53.
  DEFW SBYT                ;22E4; Command code $36, 54.
  DEFW HSVBK               ;22E6; Command code $37, 55.
  DEFW CFSM                ;22E8; Command code $38, 56.
  DEFW PNTP                ;22EA; Command code $39, 57.
  DEFW COPS                ;22EC; Command code $3A, 58.
  DEFW HGFLE               ;22EE; Command code $3B, 59.
  DEFW LBYT                ;22F0; Command code $3C, 60.
  DEFW HLDBK               ;22F2; Command code $3D, 61.
  DEFW JWSAD               ;22F4; Command code $3E, 62.
  DEFW JRSAD               ;22F6; Command code $3F, 63.
  DEFW REST                ;22F8; Command code $40, 64.
  DEFW HERAZ               ;22FA; Command code $41, 65.
  DEFW COPS2               ;22FC; Command code $42, 66.
  DEFW PCAT                ;22FE; Command code $43, 67.
  DEFW HRSAD               ;2300; Command code $44, 68.
  DEFW HWSAD               ;2302; Command code $45, 69.
  DEFW OTFOC               ;2304; Command code $46, 70.
  DEFW PATCH               ;2305; Command code $47, 71.


; ===============================================================
; The BASIC command execution routines I

; ----------------------------------------------
; THE 'COPY FILE(S)' ROUTINE

; This routine handles the copying of files. It is executed as soon as the
; 'EXPT_PARMS' routine at $2665 finds a 'TO' keyword. The return address to
; the routine which called 'EXPT_PARMS' is dropped at $230E.

TO
  CALL TEST_SAVE           ;2308;
  JP   Z,REP_0             ;230B; Give error if not SAVEing.
  POP  HL                  ;230E; Drop return address to SAVE routine.
  CALL SWAP_UFIAS          ;230F; Swap the UFIAS.
  RST  NEXT_C              ;2312;
  AND  $DF                 ;2313; Drop lower case bit.
  CP   "D"                 ;2315;
  JP   NZ,REP_0            ;2317; Jump if 2nd device isn't "D".
  LD   ($3E04),A           ;231A; Store it in DEV_TYPE1.
  CALL EXPT_DEVN           ;231D; Evaluate drive num., store it in UFIA1.
  CALL SEPARATOR           ;2320; Test for a separator, jump if one
  JR   Z,TO_1              ;2323; found, i.e. a 2nd name is given.
  CALL SIGN_4              ;2325; Used here to signal 'use source
                                         ; filename for destination file'.
TO_1
  CALL Z,EXPT_FNAME        ;2328; Evaluate filename if there was a
                                         ; separator.
  CALL SWAP_UFIAS          ;232B; Swap the UFIAS again.
  CALL ST_END_RAM          ;232E; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   HL,$3E1E            ;2331; Copy the second filename and directory
  LD   DE,$3E32            ;2334; description.
  LD   BC,11               ;2337;
  LDIR                     ;233A;
  LD   HL,$0001            ;233C; Track 0 sector 1.
  LD   ($3DED),HL          ;233F;
  LD   HL,$0000            ;2342; Disk buffer offset $0000.
  LD   ($3DEB),HL          ;2345;
TO_2
  CALL TEST_DRV            ;2348; Is the drive defined?
  CALL TO_SEARCH           ;234B; Search for a file to be copied.
  JP   NZ,TO_EXIT          ;234E; Jump if there are no files left.
  CALL LOAD_1ST            ;2351; Copy file description (directory
                                         ; description and filename) to UFIA2 and
                                         ; load the first sector of the file into
                                         ; the disk buffer.
  LD   A,($3E1E)           ;2354; Get directory description.
  CP   5                   ;2357;
  JR   Z,TO_2              ;2359; Jump with 'Snapshot 48K'.
  CP   6                   ;235B;
  JR   Z,TO_2              ;235D; Jump with 'Microdrive file'.
  CP   9                   ;235F;
  JR   Z,TO_2              ;2361; Jump with 'Snapshot 128K'.
  CP   10                  ;2363;
  JR   Z,TO_2              ;2365; Jump with 'Opentype file'.
  CP   11                  ;2367;
  JR   Z,TO_2              ;2369; Jump with 'Execute file'.
                                         ; These five file types can't be copied
                                         ; with the 'SAVE .. TO ..' command.

; Now the file is going to be copied.  NOTE: The file to be copied will
; destroy everything above 'start of BASIC'+256 and no checks are made if the
; file fits in memory and if the stack isn't overwritten.

  CALL LOAD_HEAD2          ;236B; Copy the file header (the 9 bytes
                                         ; consisting of filetype, length, etc.)
                                         ; to UFIA2.
  LD   HL,(23635)          ;236E; Fetch start of BASIC program (PROG).
  INC  H                   ;2371; Add 256 to it.
  LD   DE,($3E2A)          ;2372; Fetch length of file (LENGTH2_1).
  CALL LOAD_FILE           ;2376; Load DE bytes, starting at address HL.
  CALL TO_MSG              ;2379; Print the message "CHANGE disc ...." if
                                         ; source drive is destination drive.
  CALL SWAP_UFIAS          ;237C; Swap the UFIA's again. The header of
                                         ; the loaded file is now held in UFIA1.
  CALL TEST_4              ;237F; Used here to test whether a 2nd
  JR   NZ,TO_5             ;2382; filename was given. Jump if not.
  LD   HL,$3E33            ;2384; Here the 2nd filename was stored.
  LD   DE,$3E06            ;2387; Start of filename of loaded file.
  LD   B,10                ;238A; Filename length.

; Now the characters from the filename of the loaded file are replaced by the
; characters of the 2nd filename. Except when the wildcard characters '*' and
; '?' were used in the 2nd name. With '*' all next characters are left
; unchanged, with '?' the current character isn't changed.

TO_3
  LD   A,(HL)              ;238C;
  CP   "*"                 ;238D; With a '*' don't replace the remaining
  JR   Z,TO_5              ;238F; characters.
  CP   "?"                 ;2391; With a '?' in name 2 don't replace this
  JR   Z,TO_4              ;2393; character.
  LD   (DE),A              ;2395; Store this character.
TO_4
  INC  HL                  ;2396;
  INC  DE                  ;2397;
  DJNZ TO_3                ;2398; Repeat for all 'normal' characters.
TO_5
  CALL TEST_DRV            ;239A;
  CALL OFSM_2              ;239D; Open the file for SAVEing.
  JR   NZ,TO_6             ;23A0; Jump if file existed already and the
                                         ; user didn't want to overwrite it.
  CALL SAVE_HEAD1          ;23A2; SAVE the 9 header bytes to the file.
  LD   HL,(23635)          ;23A5; Fetch start of BASIC (PROG), and add
  INC  H                   ;23A8; 256 to it. (here the file was loaded)
  LD   DE,($3E11)          ;23A9; Length of file.
  CALL HSVBK_2             ;23AD; Save the file.
  CALL CFSM                ;23B0; Close the file.
TO_6
  CALL SWAP_UFIAS          ;23B3; Swap the UFIA's again.
  CALL SIGN_0              ;23B6; Signal 'at least one file has been
                                         ; copied'
  CALL TO_MSG              ;23B9; Print message "Input ..." if necessary
  JP   TO_2                ;23BC; Repeat until no more files have to be
                                         ; copied.

ROM_NEW EQU $11B7

TO_EXIT
  CALL TEST_0              ;23BF; Give error if there isn't one file
  JP   Z,REP_26            ;23C2; copied.
  LD   HL,ROM_NEW          ;23C5; Otherwise jump to the appropriate 'NEW'
  JP   TO_NEW              ;23C8; routine (128K or 48K).

; ----------------------------------------------
; THE 'PRINT "CHANGE DISC"' SUBROUTINE

; This subroutine tests whether source and destination drives are equal. If
; they are the messages "Insert SOURCE disc - press SPACE" and "Insert TARGET
; disc - press SPACE" are printed in turn.

TO_MSG
  LD   A,(UFIA1)           ;23CB; Fetch source drive.
  LD   B,A                 ;23CE;
  LD   A,(UFIA2)           ;23CF; Fetch destination drive.
  CP   B                   ;23D2;
  RET  NZ                  ;23D3; Return if they aren't equal.
  RST  CALBAS              ;23D4; Otherwise clear lower screen area.
  DEFW CLS_LOWER           ;23D5;
  SET  5,(IY+2)            ;23D7; Signal 'lower screen has to be cleared'
  CALL TO_MSG1             ;23DB; Print "Input ... disc" message.
  CALL BEEP                ;23DE; Give a beep.
TO_WSPC
  LD   A,$7F               ;23E1; Keyboard row B-SPACE address.
  IN   A,(254)             ;23E3;
  RRA                      ;23E5;
  JR   C,TO_WSPC           ;23E6; Jump unless the SPACE key is pressed.
  RST  CALBAS              ;23E8; Clear lower screen.
  DEFW CLS_LOWER           ;23E9;
  RET                      ;23EB; Finished.

; ----------------------------------------------
; THE 'SEARCH FILES' SUBROUTINE

; This subroutine searches for files which have to be copied. It returns with
; the Zero flag set if the current file is to be copied, if the complete
; directory is searched the routine returns with Zero reset.

TO_SEARCH
  LD   DE,($3DED)          ;23EC; Track & sector to DE.
  LD   A,D                 ;23F0;
  CP   4                   ;23F1; Jump if not reached track 4, i.e.
  JR   NZ,TO_SEARCH1       ;23F3; directory hasn't been read completely.
  CP   0                   ;23F5; Reset Zero flag.
  RET                      ;23F7;

; The directory isn't finished yet, so read sector and test the file(s).

TO_SEARCH1
  CALL RSAD                ;23F8; Read sector E from track D.
TO_SEARCH2
  CALL TO_COPY             ;23FB; Check if this file is to be copied.
  PUSH AF                  ;23FE; Store result (Zero flag).
  LD   HL,($3DEB)          ;23FF; Disk buffer offset to HL.
  LD   A,H                 ;2402;
  CP   1                   ;2403;
  JR   Z,TO_NXTSEC         ;2405; Jump if second entry.
  LD   A,($3DDA)           ;2407; Fetch current control port status.
  AND  $04                 ;240A;
  JR   NZ,TO_NXTSEC        ;240C; Jump with single density.
  LD   HL,256              ;240E; Otherwise offset is for second entry.
  LD   ($3DEB),HL          ;2411;
  POP  AF                  ;2414; Restore Zero flag.
  RET  Z                   ;2415; Return if this file is to be copied.
  JR   TO_SEARCH2          ;2416; Otherwise next file.

; The file entries of the current sector have been tested so point to the next
; sector.

TO_NXTSEC
  LD   HL,0                ;2418; Offset is for first entry.
  LD   DE,($3DED)          ;241B; Fetch track and sector.
  INC  E                   ;241F; Next sector.
  LD   A,E                 ;2420;
  CP   11                  ;2421;
  JR   NZ,TO_NXT1          ;2423; Jump if not last sector on this track.
  LD   E,1                 ;2425; Start with sector 1.
  INC  D                   ;2427; Next track.
TO_NXT1
  LD   ($3DED),DE          ;2428; Store track & sector.
  LD   ($3DEB),HL          ;242C; Store disk buffer offset.
  POP  AF                  ;242F; Restore Zero flag.
  RET  Z                   ;2430; Return if previous file is to be
  JR   TO_SEARCH           ;2431; copied. Otherwise jump.

; ----------------------------------------------
; THE 'COPY THIS FILE ?' SUBROUTINE

; This subroutine checks if the 'current' filename is to be  copied. The
; routine returns with the Zero flag set to signal yes and RPT pointing to the
; directory description of the file to be copied.

TO_COPY
  LD   HL,$3BD6            ;2433; Point to start of sector.
  LD   DE,($3DEB)          ;2436; Offset to DE.
  LD   (IX+14),D           ;243A; Update RPT (RAM PoinTer (?)).
  ADD  HL,DE               ;243D; Update HL.
  LD   A,(HL)              ;243E; Fetch directory description.
  AND  A                   ;243F;
  JR   NZ,TO_COPY1         ;2440; Jump if the file isn't ERASEd.
  INC  A                   ;2442; Reset Zero flag to signal 'do not copy
  RET                      ;2443; this file' and exit.

TO_COPY1
  INC  HL                  ;2444; Step past directory descriptor.
  LD   DE,$3E06            ;2445; DE now points to FILE_NAME1.
  LD   B,10                ;2448; A filename is 10 characters long.
TO_COPY2
  LD   A,(DE)              ;244A; Fetch character.
  CP   "*"                 ;244B; If it was a '*' all other characters
  RET  Z                   ;244D; don't matter. Signal 'copy this one'.
  CP   "?"                 ;244E; If it was a '?' this character doesn't
  JR   Z,TO_COPY3          ;2450; matter.
  XOR  (HL)                ;2452;
  AND  $DF                 ;2453; Upper and lower case? don't bother.
  RET  NZ                  ;2455; Exit if characters are unequal.
TO_COPY3
  INC  DE                  ;2456; Check next character.
  INC  HL                  ;2457;
  DJNZ TO_COPY2            ;2458;
  RET                      ;245A; Finished.

; ----------------------------------------------
; THE 'CAT' COMMAND SYNTAX ROUTINE

; This routine checks that the command is in the form CAT <#s;>d<<;>n$> .

CAT
  LD   IX,DFCA             ;245B;
  LD   HL,$3E06            ;245F; "*" is the default name of the files
  LD   (HL),42,"*"         ;2462; being CATted.
  LD   HL,$3E03            ;2464; Just like #2 is the default output
  LD   (HL),2              ;2467; stream.
  RST  NEXT_C              ;2469; Get next character.
  CP   13                  ;246A; Give an error if an 'end of line' (CR)
  JP   Z,REP_2             ;246C; is found right after "CAT".
  CP   ":"                 ;246F;
  JP   Z,REP_2             ;2471; Same error for ":".
  CP   "#"                 ;2474; Jump if no stream specified, use
  JR   NZ,CAT_DRV          ;2476; default stream #2.
  CALL EXPT_      #NR      ;2478; Evaluate stream number.
  CALL SEPARATOR           ;247B; Check if there is a separator.
  JP   NZ,REP_0            ;247E; Give an error if no separator found.
CAT_DRV
  CALL EXPT_DEVN2          ;2481; Evaluate drive number.
  CALL SEPARATOR           ;2484; Evaluate filename if there is a
  CALL Z,EXPT_FNAME        ;2487; separator.
  CP   "!"                 ;248A; If there is no "!" then an extended
  JR   NZ,EXT_CAT          ;248C; catalogue is given.
  RST  NEXT_C              ;248E; Next character.
  CALL ST_END_RAM          ;248F; Confirm end of statement and exit when
                                         ; syntax checking.
  CALL TEST_DRV            ;2492; See if drive is defined.
  LD   A,%00000010         ;2495; Signal 'small' CAT.
  JR   DO_CAT1             ;2497;

EXT_CAT
  CALL ST_END_RAM          ;2499; Confirm end of statement and exit
                                         ; during syntax time.
  RST  CALBAS              ;249C; Clear the screen by calling 'main' ROM
  DEFW CL_ALL              ;249D; routine.
DO_CAT
  CALL TEST_DRV            ;249F; See if drive is defined.
  LD   A,%00000100         ;24A2; Signal extended CAT.
DO_CAT1
  CALL CAT_RUN             ;24A4; Give the CAT.
  JP   END                 ;24A7; Finished.

; ----------------------------------------------
; THE 'CAT' COMMAND ROUTINE

; This routine makes a catalogue of the disk inserted in the specified drive,
; by calling the +D ROM routine 'SCAN_CAT'.

CAT_1
  LD   HL,$3E06            ;24AA; Point to name.
  LD   (HL),42,"*"         ;24AD; All files.
  LD   HL,$3E03            ;24AF; Point to stream number.
  LD   A,2                 ;24B2; Make it stream 2.
  LD   (HL),A              ;24B4;
CAT_RUN
  PUSH AF                  ;24B5;
  LD   A,($3E03)           ;24B6;
  RST  CALBAS              ;24B9; Open the desired stream by calling
  DEFW CHAN_OPEN           ;24BA; 'CHAN_OPEN' in the 'main' ROM.
  LD   A,13                ;24BC;
  CALL PRT_A               ;24BE; Printing starts on the next line.
  CALL MSG_0               ;24C1; Print the 1st part of "DIR"-message.
  LD   A,($3ACE)           ;24C4; Fetch current drive.
  AND  $03                 ;24C7; Only bits 0&1.
  OR   $30                 ;24C9; Make ASCII "1" or "2".
  CALL PRT_A               ;24CB; Print drive number.
  CALL MSG_1               ;24CE; Print the 2nd part of "DIR"-message.
  LD   HL,0                ;24D1; Reset 'total number of sectors'
  LD   ($3DD8),HL          ;24D4; occupied.
  POP  AF                  ;24D7; Restore 'CAT' type.
  CALL SCAN_CAT            ;24D8; Print the CAT entries.
  CALL MSG_2               ;24DB; Print "Free ..." message.
  CALL DRV_CAP             ;24DE; Get drive capacity in A register.
  PUSH BC                  ;24E1;
  BIT  7,A                 ;24E2;
  JR   Z,CAT_RUN1          ;24E4; Jump if drive is single sided.
  ADD  A,A                 ;24E6; Otherwise double the number of tracks
                                         ; and get rid of the side bit.
CAT_RUN1
  SUB  4                   ;24E7; Subtract number of catalogue tracks.
  LD   HL,0                ;24E9;
  LD   B,10                ;24EC; Each track has 10 sectors.
  LD   D,0                 ;24EE; Number of tracks to DE.
  LD   E,A                 ;24F0;
CAT_RUN2
  ADD  HL,DE               ;24F1; Calculate total number of sectors.
  DJNZ CAT_RUN2            ;24F2;
  POP  BC                  ;24F4;
  NOP                      ;24F5; New code is two bytes shorter.
  NOP                      ;24F6;
  LD   DE,($3DD8)          ;24F7; Get number of used sectors.
  XOR  A                   ;24FB; Clear carry.
  SBC  HL,DE               ;24FC; Calculate number of free sectors.
  SRL  H                   ;24FE; Divide it by two to get number of free
  RR   L                   ;2500; K-bytes.
  XOR  A                   ;2502;
  CALL PRT_N1000           ;2503; Print the number.
  LD   A,13                ;2506;
  CALL PRT_A               ;2508; Print a newline.
  RET                      ;250B;

; ----------------------------------------------
; THE 'ERASE' COMMAND SYNTAX ROUTINE

; This routine checks that the command is in the form ERASE *n$ to erase a
; file or ERASE *n1$ TO n2$ to rename a file. The '*' stands for +D syntax
; ('d'd<;>) or Microdrive syntax ('"m"';d;).

ERASE
  RST  NEXT_C              ;250C; Get next character.
  LD   ($3E04),A           ;250D; Store the device descriptor.
  CP   '"'                 ;2510; Test for Microdrive syntax if it was a
  CALL Z,MD_SYN1           ;2512; quote.
  CALL EXPT_DEVN           ;2515; Evaluate the drive number.
  CALL SEPARATOR           ;2518; Test for a separator.
  JP   NZ,REP_0            ;251B; Give error if none found.
  CALL EXPT_FNAME          ;251E; Evaluate filename.
  CP   204,"TO"            ;2521; Is the filename followed by "TO"?
  JR   Z,RENAME            ;2523; Jump if so, rename is wanted.
  CALL ST_END_RAM          ;2525; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   A,($3E04)           ;2528; Fetch device descriptor.
  AND  $DF                 ;252B; Drop lower case bit.
  CP   "D"                 ;252D;
  JR   Z,ERASE_RUN         ;252F; Jump if it was "D".
  CP   "M"                 ;2531;
  JP   NZ,REP_10           ;2533; Give error if it wasn't "M".

; ----------------------------------------------
; THE 'ERASE A FILE' ROUTINE

; This routine deletes the specified file(s) on the specified drive. First it
; calls the routine 'FIND_FILE' to find a matching name, then it marks the
; file ERASEd by setting the directory description to 0, the dir. entry is
; then SAVEd back to disc.

ERASE_RUN
  CALL TEST_DRV            ;2536; See if drive is defined.
ERASE_LOOP
  CALL FIND_FILE           ;2539; Find the file.
  JR   NZ,NOT_FOUND        ;253C; Jump if not found.
  LD   (HL),0              ;253E; Directory description 0 means ERASEd.
  CALL WSAD                ;2540; Write sector DE.
  CALL SIGN_0              ;2543; Signal 'at least one file ERASEd'.
  JR   ERASE_LOOP          ;2546; ERASE all files with this filename.

NOT_FOUND
  CALL TEST_0              ;2548; Give an error if there wasn't at least
  JP   Z,REP_26            ;254B; one file ERASEd.
ERASE_EXIT
  LD   A,($3E04)           ;254E;
  CP   "D"                 ;2551; If the device descriptor was a
  CALL Z,CAT_1             ;2553; (capital) "D", then give a CATalogue.
  JP   END                 ;2556; Finished.

; ----------------------------------------------
; THE 'FIND A FILE' SUBROUTINE

; This routine searches the directory for a matching filename by calling the
; +D ROM routine 'SCAN_CAT', it returns with HL pointing to the directory
; description of the matching file. This routine is also called by command
; code 65 routine.

FIND_FILE
  LD   A,%00010000         ;2559; Scan the CATalogue for a matching
  CALL SCAN_CAT            ;255B; filename.
  JP   RPT_HL              ;255E; Make HL point to the start of the dir.
                                         ; entry buffer and exit.

; ----------------------------------------------
; THE 'RENAME A FILE' ROUTINE

; This routine renames a file by replacing its filename, given first, by the
; filename given second. It first tests whether the 'new' name isn't used
; already. If not, a check is made whether the file to be renamed exists.

RENAME
  RST  NEXT_C              ;2561; Get next character.
  CALL SEPARATOR           ;2562; Check if there is a separator.
  JP   NZ,REP_0            ;2565; Give an error if none found.
  CALL EXPT_2FNAM          ;2568; Evaluate 2nd filename.
  CALL ST_END_RAM          ;256B; Confirm end of statement and exit when
                                         ; syntax checking.
  LD   A,($3E04)           ;256E; Fetch device descriptor.
  AND  $DF                 ;2571; Drop lower case bit.
  CP   "D"                 ;2573;
  JR   Z,RENAME_RUN        ;2575; Jump if it was a "D".
  CP   "M"                 ;2577;
  JP   NZ,REP_10           ;2579; Give error if it wasn't a "M".
RENAME_RUN
  CALL TEST_DRV            ;257C; See if the drive is defined.
  CALL SWAP_UFIAS          ;257F; Swap UFIA 1 & 2 in the DFCA.
  CALL FIND_FILE           ;2582; Give an error if the 2nd filename
  JP   Z,REP_28            ;2585; already exists.
  CALL SWAP_UFIAS          ;2588; Swap UFIA 1 & 2 in the DFCA.
  CALL FIND_FILE           ;258B; Give an error if the 1st filename
  JP   NZ,REP_26           ;258E; doesn't exist.
  INC  HL                  ;2591;
  PUSH DE                  ;2592;
  LD   DE,$3E1F            ;2593; Rename the file by copying the 2nd to
  EX   DE,HL               ;2596; the 1st name.
  LD   BC,10               ;2597;
  LDIR                     ;259A;
  POP  DE                  ;259C;
  CALL WSAD                ;259D; Write the CATalogue sector.
  JR   ERASE_EXIT          ;25A0; Exit via 'ERASE_EXIT'.


; ===============================================================
; The syntax checking routines

; ----------------------------------------------
; THE 'SEPARATOR' SUBROUTINE

; This small subroutine tests whether the current character is a separator or
; a quote. It returns with Zero flag set if it was a ";", "," or a """, with
; the first two A holds the next character.

SEPARATOR
  CP   ","                 ;25A2;
  JR   Z,SEPAR_1           ;25A4; Jump if current character is a comma.
  CP   ";"                 ;25A6;
  JR   Z,SEPAR_1           ;25A8; Jump if it is a semicolon.
  CP   '"'                 ;25AA;
  RET                      ;25AC; Return with Zero set if it's a quote.
SEPAR_1
  RST  NEXT_C              ;25AD; Get next character.
  LD   ($3DEA),A           ;25AE;
  XOR  A                   ;25B1; Set Zero flag.
  LD   A,($3DEA)           ;25B2;
  RET                      ;25B5;

; ----------------------------------------------
; THE 'EVALUATE STRING EXPR.' SUBROUTINE

; A call is made to the 'main' ROM 'EXPT_EXP' (class-0A) subroutine, to
; evaluate a string expression. During runtime, the parameters of the string
; (start and length) are returned in the DE and BC register pairs.

EXPT_STR
  RST  CALBAS              ;25B6; Evaluate the string expression.
  DEFW EXPT_EXP            ;25B7;
  RST  SYNTAX_Z            ;25B9;
  RET  Z                   ;25BA; Return if syntax is being checked.
  PUSH AF                  ;25BB; Save the character following the string
  RST  CALBAS              ;25BC; and the zero flag.
  DEFW STK_FETCH           ;25BD; Fetch the string parameters.
  POP  AF                  ;25BF;
  RET                      ;25C0;

; ----------------------------------------------
; THE 'EVAL. MICRODRIVE SYNTAX' SUBROUTINE

; This subroutine is entered at 'MD_SYNTAX' or 'MD_SYNTAX1' depending upon
; whether or not the character pointer is to be updated to the next character.
; A single character string is evaluated, and its ASCII value is stored during
; runtime. If a separator isn't present after the single character string, an
; error is given.

MD_SYNTAX
  RST  NEXT_C              ;25C1; Next character.
MD_SYN1
  CALL EXPT_STR            ;25C2;
  JR   Z,MD_SYN2           ;25C5; Jump if syntax is being checked.
  PUSH AF                  ;25C7; Save the character following the
  LD   A,C                 ;25C8; string. A holds string length low byte.
  DEC  A                   ;25C9;
  OR   B                   ;25CA; Give an error if there isn't exactly
  JP   NZ,REP_10           ;25CB; one character in the string.
  LD   A,(DE)              ;25CE; Fetch the channel specifier.
  RST  CALBAS              ;25CF; Call 'ALPHA' to see if it's a valid
  DEFW ALPHA               ;25D0; letter.
  JP   NC,REP_10           ;25D2; Give error if not a valid letter.
  LD   ($3E04),A           ;25D5; Store the specifier in the UFIA.
  POP  AF                  ;25D8; Restore next character.
MD_SYN2
  CP   ";"                 ;25D9;
  RET  Z                   ;25DB; Return if it's a semicolon.
  CP   ","                 ;25DC;
  RET  Z                   ;25DE; Return if it's a comma.
  JP   REP_0               ;25DF; Otherwise give error.

; ----------------------------------------------
; THE 'EVALUATE DEVICE NUMBER' SUBROUTINE

; This subroutine is used to evaluate the device number.

EXPT_DEVN
  AND  $DF                 ;25E2; Make upper case.
  CP   "P"                 ;25E4;
  JR   NZ,EXPT_DEVN1       ;25E6; Jump if the device wasn't "P".
  RST  NEXT_C              ;25E8; Next character.
  CALL EXPT_NUM            ;25E9; Get the program number.
  RET  Z                   ;25EC; Return if syntax checking.
  PUSH AF                  ;25ED;
  LD   A,(UFIA1)           ;25EE; Store program number.
  LD   ($3E02),A           ;25F1;
  CALL LAST_DRV            ;25F4; Drive is last drive.
  POP  AF                  ;25F7;
  RET                      ;25F8;

; Now a check is made whether the last used device is wanted.

EXPT_DEVN1
  RST  NEXT_C              ;25F9; Get next character.
EXPT_DEVN2
  CP   "*"                 ;25FA;
  JR   NZ,EXPT_NUM         ;25FC; Jump if it wasn't a "*".
  RST  SYNTAX_Z            ;25FE;
  CALL NZ,LAST_DRV         ;25FF; Store last drive number during runtime.
  RST  NEXT_C              ;2602; Next character.
  RET                      ;2603;

; ----------------------------------------------
; THE 'SET LAST DRIVE' SUBROUTINE

; This subroutine is used whenever the last used drive is to be used again.

LAST_DRV
  LD   A,($3DDA)           ;2604; Fetch current control port status.
  AND  $01                 ;2607; Keep only drive select.
  ADD  A,$01               ;2609; A holds 1 for drive 2, 2 for drive 1.
  XOR  $03                 ;260B; 1 becomes 2, 2 becomes 1.
  LD   (UFIA1),A           ;260D; Store drive number.
  RET                      ;2610;

; ----------------------------------------------
; THE 'EVALUATE NUMERIC EXPR.' SUBROUTINE

; This subroutine is used to evaluate a single numeric expression. The result
; is returned during runtime into the BC register pair and into UFIA1.

EXPT_NUM
  RST  CALBAS              ;2611; Evaluate the expression by calling
  DEFW EXPT_1NUM           ;2612; 'EXPT_1NUM' in the 'main' ROM.
  RST  SYNTAX_Z            ;2614;
  RET  Z                   ;2615; Return if syntax is being checked.
  PUSH AF                  ;2616;
  RST  CALBAS              ;2617; Fetch the value from the calculator
  DEFW FIND_INT2           ;2618; stack.
  LD   A,C                 ;261A;
  LD   (UFIA1),A           ;261B; Store it in UFIA1.
  POP  AF                  ;261E;
  RET                      ;261F;

; ----------------------------------------------
; THE 'EVALUATE 2ND FILENAME' SUBROUTINE

; This routine evaluates the second filename of a BASIC command. Because
; 'EXP_F_NAME' stores the filename in UFIA1, both UFIAS are swapped first,
; then 'EXP_F_NAME' is called and an exit is made via 'SWAP_UFIAS' to get the
; UFIA's in the right place again.

EXPT_2FNAM
  CALL SWAP_UFIAS          ;2620; Swap UFIA1 and 2.
  CALL EXPT_FNAME          ;2623; Evaluate filename.
                                         ; Exit via 'SWAP_UFIAS'.
; ----------------------------------------------
; THE 'SWAP UFIAS' SUBROUTINE

; This subroutine swaps the contents of UFIA1 and UFIA2 in DFCA.

SWAP_UFIAS
  PUSH AF                  ;2626;
  PUSH BC                  ;2627;
  PUSH DE                  ;2628;
  PUSH HL                  ;2629;
  LD   B,24                ;262A; An UFIA is 24 bytes long.
  LD   DE,UFIA1            ;262C; Start of UFIA1.
  LD   HL,UFIA2            ;262F; Start of UFIA2.
SWAP_LOOP
  LD   A,(DE)              ;2632; Exchange the contents.
  LD   C,(HL)              ;2633;
  EX   DE,HL               ;2634;
  LD   (DE),A              ;2635;
  LD   (HL),C              ;2636;
  INC  DE                  ;2637;
  INC  HL                  ;2638;
  DJNZ SWAP_LOOP           ;2639; Repeat for all 24 bytes.
  POP  HL                  ;263B;
  POP  DE                  ;263C;
  POP  BC                  ;263D;
  POP  AF                  ;263E;
  RET                      ;263F;

; ----------------------------------------------
; THE 'EVALUATE A FILENAME' SUBROUTINE

; A string expression is evaluated and, provided that the length is within the
; range 1..10 characters, is stored in UFIA1.

EXPT_FNAME
  CALL EXPT_STR            ;2640; Evaluate the string.
  RET  Z                   ;2643; Return if checking syntax.
  PUSH AF                  ;2644;
  LD   A,C                 ;2645;
  OR   B                   ;2646;
  JP   Z,REP_8             ;2647; Give error with null string.
  LD   HL,10               ;264A;
  SBC  HL,BC               ;264D;
  JP   C,REP_8             ;264F; Give error with string length > 10.
  LD   HL,$3E05            ;2652; Clear the filename and the directory
  LD   A,11                ;2655; description of UFIA1.
CLR_FNAME
  LD   (HL),32             ;2657;
  INC  HL                  ;2659;
  DEC  A                   ;265A;
  JR   NZ,CLR_FNAME        ;265B; Repeat for all 11 bytes.
  LD   HL,$3E06            ;265D; Copy the filename into UFIA1.
  EX   DE,HL               ;2660;
  LDIR                     ;2661;
  POP  AF                  ;2663;
  RET                      ;2664;

; ----------------------------------------------
; THE 'EVALUATE PARAMETERS' SUBROUTINE

; This very important subroutine is called to evaluate the syntax of the +D
; 'SAVE', 'LOAD', 'MERGE' and 'VERIFY' commands. The routine is entered with
; CH_ADD pointing to the command; on exit during runtime UFIA1 is filled with
; the proper values.

EXPT_PARMS
  RST  NEXT_C              ;2665; Get next character from BASIC line.
  CP   " "                 ;2666; Give an error with character codes
  JP   C,REP_0             ;2668; below 32, i.e. colour codes, etc.
  CP   170,"SCREEN$"       ;266B;
  JP   Z,DUMP_SCR      $   ;266D; Jump with 'SCREEN$'.
  LD   ($3E04),A           ;2670; Otherwise store it in DEV_TYPE1.
  CP   "@"                 ;2673;
  JR   NZ,NOT_      @      ;2675; Jump if not a '@'.

; Now deal with @.

  CALL EXPT_DEVN           ;2677; Evaluate drive number.
  CALL SEPARATOR           ;267A;
  JP   NZ,REP_2            ;267D; Give error if no separator was found.
  RST  CALBAS              ;2680; Call 'EXPT_1NUM' to evaluate the track
  DEFW EXPT_1NUM           ;2681; number.
  CALL SEPARATOR           ;2683; Test for another separator and give an
  JP   NZ,REP_2            ;2686; error if none found.
  RST  CALBAS              ;2689; Evaluate sector number.
  DEFW EXPT_1NUM           ;268A;
  CALL SEPARATOR           ;268C; Again a separator has to be found.
  JP   NZ,REP_2            ;268F;
  RST  CALBAS              ;2692; Evaluate address.
  DEFW EXPT_1NUM           ;2693;
  CALL ST_END_RAM          ;2695; Confirm end of statement, and exit
                                         ; during syntax checking.
  RST  CALBAS              ;2698; Fetch the address from the calculator
  DEFW FIND_INT2           ;2699; stack.
  LD   ($3E15),BC          ;269B; Store it in LENGTH1_2
  RST  CALBAS              ;269F; Fetch sector.
  DEFW FIND_INT2           ;26A0;
  LD   ($3E13),BC          ;26A2; Store it in FILE_ADDR1
  RST  CALBAS              ;26A6; Fetch track.
  DEFW _FIND_INT2          ;26A7;
  LD   ($3E11),BC          ;26A9; Store it in LENGTH1_1
  RET                      ;26AD; Exit.

NOT_
  @      CP   "*"                 ;26AE; Call 'MD_SYNTAX' if it was a "*".
  CALL Z,MD_SYNTAX         ;26B0;
  CALL EXPT_DEVN           ;26B3; Fetch device or program number.
  CALL SEPARATOR           ;26B6; Test for a separator.
  PUSH AF                  ;26B9;
  RST  SYNTAX_Z            ;26BA;
  JR   Z,FILENAME          ;26BB; Jump if syntax checking.
  LD   A,($3E04)           ;26BD; Fetch device descriptor.
  AND  $DF                 ;26C0; Only capitals.
  CP   "D"                 ;26C2;
  JR   Z,NOT_      @1      ;26C4; Jump if device is disk.
  CP   "M"                 ;26C6;
  JR   Z,NOT_      @1      ;26C8; Or disk with Microdrive syntax.
  CP   "P"                 ;26CA;
  JR   Z,PARAMS            ;26CC; Jump with program.
  JP   NZ,REP_10           ;26CE; Give error with unknown device.
NOT_
  @1     POP  AF                  ;26D1; Give error if no separator or quote
  JP   NZ,REP_0            ;26D2; found with devices "D" and "M".
  PUSH AF                  ;26D5; Balance 'POP AF' below.
FILENAME
  POP  AF                  ;26D6;
  CALL Z,EXPT_FNAME        ;26D7; Evaluate filename if necessary.
  PUSH AF                  ;26DA; Balance next instruction.
PARAMS
  POP  AF                  ;26DB;
  CP   13                  ;26DC;
  JP   Z,NO_PARAMS         ;26DE; Jump with ENTER.
  CP   ":"                 ;26E1;
  JP   Z,NO_PARAMS         ;26E3; Jump with colon.
  CP   204,"TO"            ;26E6;
  JP   Z,TO                ;26E8; Jump with 'TO'.
  CP   170,"SCREEN$"       ;26EB;
  JP   Z,SCREEN      $     ;26ED; Jump with 'SCREEN$'.
  CP   175,"CODE"          ;26F0;
  JP   Z,CODE              ;26F2; Jump with 'CODE'.
  CP   228,"DATA"          ;26F5;
  JP   Z,DATA              ;26F7; Jump with 'DATA'.
  CP   202,"LINE"          ;26FA;
  JP   Z,LINE              ;26FC; Jump with 'LINE'.
  AND  $DF                 ;26FF; Only capitals.
  CP   "S"                 ;2701;
  JR   NZ,NOT_S            ;2703; Jump with other than 'S'.
  RST  NEXT_C              ;2705; Next character.
  CALL ST_END_RAM          ;2706; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   A,5                 ;2709; Signal '48K Snapshot'.
  LD   ($3E05),A           ;270B;
  RET                      ;270E; Finished.

NOT_S
  CP   "K"                 ;270F;
  JR   NZ,NOT_K            ;2711; Jump with other than 'K'.
  RST  NEXT_C              ;2713; Next character.
  CALL ST_END_RAM          ;2714; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   A,9                 ;2717; Signal '128K Snapshot'.
  LD   ($3E05),A           ;2719;
  RET                      ;271C; Finished.

NOT_K
  CP   "X"                 ;271D;
  JP   NZ,REP_0            ;271F; Give error with other than 'X'.
  RST  NEXT_C              ;2722; Next character.
  CALL SEPARATOR           ;2723; Jump if a separator found, there is
  JR   Z,XFILE_1           ;2726; more.
  CALL TEST_5              ;2728; There must follow a address if SAVEing.
  JP   NZ,REP_2            ;272B; Give error if SAVEing.
  CALL ST_END_RAM          ;272E; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   BC,$3BD6            ;2731; Load address of execute file.
  JR   XFILE_2             ;2734; Jump forward.

; A separator has been found, so there should follow an address.

XFILE_1
  RST  CALBAS              ;2736; Evaluate address.
  DEFW EXPT_1NUM           ;2737;
  CALL ST_END_RAM          ;2739; Confirm end of statement and exit
                                         ; during syntax checking.
  RST  CALBAS              ;273C; Fetch the address.
  DEFW FIND_INT2           ;273D;
XFILE_2
  LD   ($3E13),BC          ;273F; Store it in FILE_ADDR1
  LD   BC,510              ;2743; Length of execute file on double
  LD   A,($3DDA)           ;2746; density disks.
  AND  $04                 ;2749;
  JR   Z,XFILE_3           ;274B; Jump if double density selected.
  LD   BC,254              ;274D; Otherwise this is the length of the
                                         ; execute file.
XFILE_3
  LD   ($3E11),BC          ;2750; Store length in LENGTH1_1.
  LD   A,3                 ;2754; File type is 'CODE'.
  LD   ($3E10),A           ;2756; Store it in FILE_TYPE1.
  LD   A,11                ;2759; Signal 'Execute file'.
  LD   ($3E05),A           ;275B; Store in DIR_DESCR1
  RET                      ;275E; Finished.

; Now deal with LINE. The +D allows LOAD, VERIFY and MERGE .. LINE to be
; entered as a command but the LINE is completely ignored.

LINE
  RST  NEXT_C              ;275F; Advance CH_ADD.
  RST  CALBAS              ;2760; Evaluate autostart line number by
  DEFW EXPT_1NUM           ;2761; calling 'EXPT_1NUM' in the 'main' ROM.
  CALL ST_END_RAM          ;2763; Confirm end of statement, and exit
                                         ; during syntax checking.
  RST  CALBAS              ;2766; Fetch the autostart line number.
  DEFW FIND_INT2           ;2767;
  LD   ($3E17),BC          ;2769; Store it in AUTOSTART1.
  JR   PROG                ;276D;

; If there are no parameters, as with a BASIC program, the syntax checking
; ends here.

NO_PARAMS
  CALL ST_END_RAM          ;276F; Confirm end of statement, exit when
                                         ; syntax checking.
PROG
  LD   A,($3E04)           ;2772;
  AND  $DF                 ;2775; Only capitals.
  CP   "P"                 ;2777; Jump if the device wasn't "P", i.e. no
  JR   NZ,PROG_1           ;2779; program number was specified.
  CALL TEST_5              ;277B; 'SAVE pn' is not supported, so give an
  RET  Z                   ;277E; error if saving, otherwise return.
  JP   REP_0               ;277F;

PROG_1
  XOR  A                   ;2782; File type is 'BASIC'.
  LD   ($3E10),A           ;2783;
  LD   A,1                 ;2786; Signal 'BASIC file'.
  LD   ($3E05),A           ;2788;
  LD   HL,(23641)          ;278B; Fetch (E_LINE), the first location past
                                         ; the variables area.
  LD   DE,(23635)          ;278E; Fetch (PROG), the 'start' of the BASIC
  LD   ($3E13),DE          ;2792; program and store it in FILE_ADDR1
  SCF                      ;2796; Calculate ((E_LINE)-(PROG)-1), i.e.  the
  SBC  HL,DE               ;2797; length of the program and its
  LD   ($3E11),HL          ;2799; variables. Store it in LENGTH1_1.
  LD   HL,(23627)          ;279C; Fetch (VARS) and calculate
  SBC  HL,DE               ;279F; (VARS)-(PROG), i.e. the length of the
                                         ; program without its variables.
  LD   ($3E15),HL          ;27A1; Store it into LENGTH1_2.
  RET                      ;27A4; Finished.

; If the token is SCREEN$, the parameters are entered directly into the file
; header.

SCREEN
  $    RST  NEXT_C              ;27A5; Get the next character.
  CALL ST_END_RAM          ;27A6; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   HL,6912             ;27A9; The size of the display file is stored
  LD   ($3E11),HL          ;27AC; into LENGTH1_1.
  LD   HL,16384            ;27AF; The startaddress is stored into
  LD   ($3E13),HL          ;27B2; FILE_ADDR1
  LD   A,3                 ;27B5; File type is 'CODE'.
  LD   ($3E10),A           ;27B7;
  LD   A,7                 ;27BA; Signal 'SCREEN$'.
  LD   ($3E05),A           ;27BC;
  RET                      ;27BF;

; Now deal with CODE, three parameters are needed: "start", "length" and
; "execute address". With LOAD there may be none, one, two or three
; parameters, but with SAVE at least two parameters must be present.

CODE
  RST  NEXT_C              ;27C0; Update CH_ADD.
  CP   13                  ;27C1; If there are no further parameters,
  JR   Z,CODE_1            ;27C3; jump to use '0' as default value.
  CP   ":"                 ;27C5; Jump if there are parameters to be
  JR   NZ,CODE_2           ;27C7; evaluated (i.e. the next character is
                                         ; not a colon).
CODE_1
  CALL TEST_5              ;27C9; 'SAVE .. CODE' has to be followed by at
  JP   NZ,REP_2            ;27CC; least two numbers, so give an error if
                                         ; none present.
  RST  CALBAS              ;27CF; A call to the 'main' ROM routine
  DEFW USE_ZERO            ;27D0; 'USE_ZERO' is made to use a value of
  JR   CODE_3              ;27D2; zero as default.

; It's likely that an address follows.

CODE_2
  RST  CALBAS              ;27D4; Use the 'main' ROM routine to evaluate
  DEFW EXPT_1NUM           ;27D5; the first parameter.
  CALL SEPARATOR           ;27D7;
  JR   Z,CODE_4            ;27DA; Jump if a separator is present.
CODE_3
  CALL TEST_5              ;27DC; Give an error if there isn't a second
  JP   NZ,REP_2            ;27DF; number with 'SAVE .. CODE'.
  RST  CALBAS              ;27E2; Otherwise use zero as default.
  DEFW USE_ZERO            ;27E3;
  JR   CODE_5              ;27E5;

; The length seems to be present also.

CODE_4
  RST  CALBAS              ;27E7; Evaluate the second parameter.
  DEFW EXPT_1NUM           ;27E8;
  CALL SEPARATOR           ;27EA; Jump if a second separator is found.
  JR   Z,CODE_6            ;27ED;
CODE_5
  RST  CALBAS              ;27EF; Otherwise zero is default.
  DEFW USE_ZERO            ;27F0;
  JR   CODE_7              ;27F2;

; There's even an execute address.

CODE_6
  RST  CALBAS              ;27F4; Evaluate the third parameter.
  DEFW EXPT_1NUM           ;27F5;
CODE_7
  CALL ST_END_RAM          ;27F7; Confirm end of statement and exit
                                         ; during syntax checking.
  RST  CALBAS              ;27FA; Fetch the "autoexecute" address from
  DEFW FIND_INT2           ;27FB; the calculator stack and store it into
  LD   ($3E17),BC          ;27FD; AUTOSTART1
  RST  CALBAS              ;2801; Fetch the "length".
  DEFW FIND_INT2           ;2802;
  LD   ($3E11),BC          ;2804; Store it into LENGTH1_1
  RST  CALBAS              ;2808; Fetch the "start".
  DEFW FIND_INT2           ;2809;
  LD   ($3E13),BC          ;280B; Store it into FILE_ADDR1
  LD   A,3                 ;280E; File type is 'CODE'.
  LD   ($3E10),A           ;2811;
  LD   A,4                 ;2814; Signal 'CODE file'.
  LD   ($3E05),A           ;2816;
  RET                      ;2819; Finished.

; Finally the routine to evaluate DATA parameters.

DATA
  CALL TEST_6              ;281A; Give an error if attempting to MERGE an
  JP   NZ,REP_14           ;281D; array.
  RST  NEXT_C              ;2820; Next character.
  RST  CALBAS              ;2821; Call LOOK_VARS to look for the array
  DEFW LOOK_VARS           ;2822; name.
  SET  7,C                 ;2824;
  JR   NC,DATA_1           ;2826; Jump if handling an existing array or
                                         ; if syntax checking.
  LD   HL,$0000            ;2828; Signal 'using a new array'.
  CALL TEST_4              ;282B;
  JR   NZ,DATA_3           ;282E; Jump if LOADing the array.
  JP   REP_11              ;2830; Otherwise give error 'Variable not
                                         ; found'.
DATA_1
  JP   NZ,REP_0            ;2833; Give error if not an array variable.

; NOTE: This test fails to exclude simple strings, but the 'bug' (present in
; the 'main' ROM) is corrected at $283E.

  RST  SYNTAX_Z            ;2836;
  JR   Z,DATA_5            ;2837; Jump if syntax is being checked.
  CALL TEST_5              ;2839;
  JR   Z,DATA_2            ;283C; Jump if LOADing.
  BIT  7,(HL)              ;283E; Give an error if trying to SAVE a
  JP   Z,REP_0             ;2840; simple string.
DATA_2
  INC  HL                  ;2843; Point to the 'length' of the array.
  LD   A,(HL)              ;2844; Store the length into LENGTH1_1.
  LD   ($3E11),A           ;2845;
  INC  HL                  ;2848;
  LD   A,(HL)              ;2849;
  LD   ($3E12),A           ;284A;
  INC  HL                  ;284D; Advance to the start of the array.
DATA_3
  LD   A,C                 ;284E; Store array name into LSB of LENGTH1_2.
  LD   ($3E15),A           ;284F;
  LD   A,1                 ;2852; File type is 'NUM ARRAY'.
  BIT  6,C                 ;2854;
  JR   Z,DATA_4            ;2856; Jump if really a numeric array.
  INC  A                   ;2858; File type is 'STR ARRAY'.
DATA_4
  LD   ($3E10),A           ;2859; Store file type into FILE_TYPE1.
  INC  A                   ;285C; Signal: (A=2) 'Numeric array',
  LD   ($3E05),A           ;285D; (A=3) 'String array'.
DATA_5
  EX   DE,HL               ;2860; DE holds 'start' of the array (or $0000
                                         ; with a 'new' array to be LOADed).
  RST  NEXT_C              ;2861; Next character.
  CP   ")"                 ;2862; Check that the ')' does exist.
  JP   NZ,REP_2            ;2864; Report an error if not.
  RST  NEXT_C              ;2867; Next character.
  CALL ST_END_RAM          ;2868; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   ($3E13),DE          ;286B; Store "start" of the array into
  RET                      ;286F; FILE_ADDR1 and exit.


; ===============================================================
; The BASIC command execution routines II

; ----------------------------------------------
; THE 'GET TRACK AND SECTOR' SUBROUTINE

; This routine loads DE with track and sector number from the file header,
; where they were stored by the 'EXPT_PARMS' subroutine. Used with LOAD/SAVE
; @.

GET_TR
  &SE  LD   A,($3E11)           ;2870; Get track from LSB of LENGTH1_1.
  LD   D,A                 ;2873;
  LD   A,($3E13)           ;2874; Get sector from LSB of FILE_ADDR1.
  LD   E,A                 ;2877;
  RET                      ;2878;

; ----------------------------------------------
; THE 'SAVE HEADER 1' SUBROUTINE

; This subroutine SAVEs the 9 bytes header from UFIA 1 to the file and to the
; catalogue entry which is build up in the DFCA.

SAVE_HEAD1
  LD   HL,$3E10            ;2879; Start of header 1.
  LD   DE,$3BA9            ;287C; Address of header area of a catalogue
                                         ; entry
  LD   B,9                 ;287F; The headers length.
SAVE_H11
  LD   A,(HL)              ;2881;
  LD   (DE),A              ;2882;
  CALL SBYT                ;2883; Save the byte to the file.
  INC  HL                  ;2886;
  INC  DE                  ;2887;
  DJNZ SAVE_H11            ;2888; Repeat for all nine bytes.
  RET                      ;288A; Finished.

; ----------------------------------------------
; THE 'SAVE' COMMAND SYNTAX ROUTINE

; This routine checks that the SAVE command has the appropriate syntax.

SAVE
  LD   IX,DFCA             ;288B;
  CALL SIGN_5              ;288F; Signal 'SAVEing'.
  CALL EXPT_PARMS          ;2892; Evaluate & store all parameters.
  CALL TEST_DRV            ;2895; See if the drive is defined.
  LD   A,($3E04)           ;2898;
  CP   "@"                 ;289B;
  JR   NZ,SAVE_RUN         ;289D; Jump if the command wasn't 'SAVE @'.
  LD   IX,($3E15)          ;289F; Get address where sector is to be saved
  CALL GET_TR      &SE     ;28A3; from. Get track and sector number.
  LD   A,(UFIA1)           ;28A6; Get drive number.
  CALL HWSAD               ;28A9; Write the sector.
  JP   END                 ;28AC; Finished.

; ----------------------------------------------
; THE 'SAVE A FILE' ROUTINE

; This routine SAVEs the specified file on the specified drive.

SAVE_RUN
  CALL OFSM_2              ;28AF; Open the file for 'SAVE'.
  JP   NZ,ERASE_EXIT       ;28B2; Exit if the file isn't to be
                                         ; overwritten.
  LD   A,($3E05)           ;28B5;
  CP   11                  ;28B8; Pass the header to the file unless it's
  CALL NZ,SAVE_HEAD1       ;28BA; an 'execute' file.
  LD   HL,($3E13)          ;28BD; Fetch the start address.
  LD   DE,($3E11)          ;28C0; Fetch the length.
  CALL HSVBK_2             ;28C4; Save the block.
  CALL CFSM                ;28C7; Close the file.
  JP   ERASE_EXIT          ;28CA; Exit via 'ERASE_EXIT'.

; ----------------------------------------------
; THE 'LOAD HEADER INTO UFIA 2' SUBROUTINE

; This subroutine LOADs a 9 bytes header into UFIA 2.

LOAD_HEAD2
  LD   HL,$3E29            ;28CD; Start of HEADER 2.
  LD   B,9                 ;28D0; Length of a header.
LOAD_H21
  CALL LBYT                ;28D2; Load a byte.
  LD   (HL),A              ;28D5; Store it into UFIA 2.
  INC  HL                  ;28D6;
  DJNZ LOAD_H21            ;28D7; Repeat for all header bytes.
  RET                      ;28D9;

; ----------------------------------------------
; THE 'LOAD' COMMAND SYNTAX ROUTINE

; The 'LOAD' flag is set and the routine continues into the
; 'LOAD_VERIFY_MERGE' routine below.

LOAD
  CALL SIGN_4              ;28DA; Signal 'LOADing'.
  JR   LD_VF_MR            ;28DD;

; ----------------------------------------------
; THE 'VERIFY' COMMAND SYNTAX ROUTINE

; The 'VERIFY' flag is set and again the 'LOAD_VERIFY_MERGE' routine handles
; the rest.

VERIFY
  CALL SIGN_7              ;28DF; Signal 'VERIFYing'.
  JR   LD_VF_MR            ;28E2;

; ----------------------------------------------
; THE 'MERGE' COMMAND SYNTAX ROUTINE

; The 'MERGE' flag is set and 'LOAD_VERIFY_MERGE' continues the syntax
; checking.

MERGE
  CALL SIGN_6              ;28E4; Signal 'MERGEing'.

; ----------------------------------------------
; THE 'LOAD_VERIFY_MERGE' COMMAND ROUTINE

; This routine checks the syntax of the LOAD, VERIFY and MERGE commands and
; executes it.

LD_VF_MR
  LD   IX,DFCA             ;28E7;
  CALL EXPT_PARMS          ;28EB; Evaluate & store all parameters.
LD_VF_MR1
  CALL TEST_DRV            ;28EE; See if the drive is defined.
  LD   A,($3E04)           ;28F1;
  CP   "@"                 ;28F4;
  JR   NZ,LD_ETC_RUN       ;28F6; Jump if it wasn't a '@' command.
  LD   IX,($3E15)          ;28F8; Get address where sector is to be
  CALL GET_TR      &SE     ;28FC; loaded. Get track and sector number.
  LD   A,(UFIA1)           ;28FF; Get drive number.
  CALL HRSAD               ;2902; Load the sector.
  JP   END                 ;2905; Finished.

; The routine continues here when a file is to be LOADed from disk.

LD_ETC_RUN
  CALL HGFLE_2             ;2908; Open the file for loading.
  LD   A,($3E05)           ;290B;
  CP   5                   ;290E;
  JR   NZ,LD_ETC_R1        ;2910; Jump if it isn't a 'Snapshot 48K'.
  LD   SP,$3FEA            ;2912; Use internal stack.
  LD   HL,16384            ;2915; Start address and length of a 48K Snap.
  LD   DE,49152            ;2918;
  CALL LOAD_FILE           ;291B; Load the file.
  JP   SNAP_EXIT           ;291E; Exit via 'SNAP_EXIT'.

LD_ETC_R1
  CP   9                   ;2921;
  JR   NZ,LD_ETC_R3        ;2923; Jump if it isn't a 'Snapshot 128K'.
  LD   SP,$3FEA            ;2925; Use internal stack.
  CALL LBYT                ;2928; Get the page configuration byte.
  PUSH AF                  ;292B;
  AND  $F8                 ;292C; Keep the RAM page bits only.
  LD   B,$08               ;292E; LOAD the eight RAM-pages.
LD_ETC_R2
  PUSH AF                  ;2930;
  PUSH BC                  ;2931;
  CALL RAMPAGE_A           ;2932; Page in RAM bank.
  LD   HL,49152            ;2935; Start address and length of each RAM
  LD   DE,16384            ;2938; bank.
  CALL LOAD_FILE           ;293B; 'LOAD DE bytes to HL'.
  POP  BC                  ;293E;
  POP  AF                  ;293F;
  INC  A                   ;2940; Next RAM bank.
  DJNZ LD_ETC_R2           ;2941; Repeat for each RAM bank.
  POP  AF                  ;2943; Retrieve page configuration.
  CALL RAMPAGE_A           ;2944; Page in the right RAM, ROM and SCR$
  JP   SNAP_EXIT           ;2947; bank, exit via 'SNAP_EXIT'.

LD_ETC_R3
  CP   11                  ;294A;
  JR   NZ,LD_ETC_R4        ;294C; Jump if it isn't a 'Execute' file.
  CALL $3BD6               ;294E; Execute (this is the address of the
  JP   END                 ;2951; disk buffer). Finished.

LD_ETC_R4
  CALL LOAD_HEAD2          ;2954; Load the header into UFIA2.
  LD   A,($3E10)           ;2957; Fetch type of program to be LOADed.
  LD   B,A                 ;295A;
  LD   A,($3E29)           ;295B; Fetch type of program found.
  CP   B                   ;295E;
  JP   NZ,REP_8            ;295F; Give an error if they aren't equal.

; NOTE: The error 'Invalid FILE NAME' is given, maybe MGT have made a typing
; error. 'Wrong FILE type' is the right message.

  CP   3                   ;2962;
  JR   Z,LD_ETC_R5         ;2964; Jump if it's a 'CODE' file.
  JP   NC,REP_8            ;2966; Give error if file type >= 4.
  CALL TEST_6              ;2969;
  JR   NZ,MERGE_CTRL       ;296C; Jump if 'MERGEing'.
  CALL TEST_7              ;296E; Jump if not 'VERIFYing' (i.e. doing a
  JP   Z,LOAD_CTRL         ;2971; LOAD).

; Now deal with loading of all files with type 3, like 'CODE' and 'SCREEN$',
; or verifying of all file types.

LD_ETC_R5
  CALL TEST_6              ;2974;
  JP   NZ,REP_14           ;2977; Give error if 'MERGE .. CODE' was used.
  LD   HL,($3E11)          ;297A; Fetch length of requested file.
  LD   DE,($3E2A)          ;297D; Fetch length of file found.
  LD   A,H                 ;2981;
  OR   L                   ;2982;
  JR   Z,LD_ETC_R6         ;2983; Jump if length unspecified.
  SBC  HL,DE               ;2985; Jump if file to be LOADed is shorter
  JR   NC,LD_ETC_R6        ;2987; than or of equal length as the
                                         ; requested file.
  CALL TEST_4              ;2989;
  JP   Z,REP_12            ;298C; 'VERIFY failed' if not LOADing.
  JP   REP_15              ;298F; 'CODE error' otherwise.

LD_ETC_R6
  LD   HL,($3E13)          ;2992; Fetch start address from FILE_ADDR1
  LD   A,H                 ;2995;
  OR   L                   ;2996;
  JR   NZ,LD_ETC_R7        ;2997; Jump if a start address was specified.
  LD   HL,($3E2C)          ;2999; Otherwise use the start address of the
                                         ; found file.
LD_ETC_R7
  LD   A,($3E29)           ;299C; But if the file is a BASIC program the
  AND  A                   ;299F; start address is held in (PROG).
  JR   NZ,LD_ETC_R8        ;29A0;
  LD   HL,(23635)          ;29A2; Fetch 'start' from (PROG).
LD_ETC_R8
  CALL LV_ANY              ;29A5; Load the file.
  CALL TEST_7              ;29A8;
  JP   NZ,END              ;29AB; Exit when 'VERIFYing'.
  LD   HL,($3E17)          ;29AE; Fetch execute address.
  CALL EXEC_CODE           ;29B1; Use it if it was specified.
  LD   HL,($3E30)          ;29B4; Otherwise use the files execute
  CALL EXEC_CODE           ;29B7; address.
  JP   END                 ;29BA; But if it hasn't one either, exit here.

; ----------------------------------------------
; THE 'EXECUTE CODE FILE' SUBROUTINE

; This routine jumps to the address in the HL register pair (if it is valid)
; after pushing the addresses of 'STMT_R_1' and 'STACK_BC'.

EXEC_CODE
  LD   A,H                 ;29BD;
  OR   L                   ;29BE;
  RET  Z                   ;29BF; Return if the execute address is zero.
  LD   A,H                 ;29C0;
  CP   $FF                 ;29C1;
  JR   NZ,EXEC_C1          ;29C3;
  LD   A,L                 ;29C5; Also return when the execute address is
  CP   $FF                 ;29C6; $FFFF.
  RET  Z                   ;29C8;
EXEC_C1
  LD   SP,(23613)          ;29C9; Clear the stack. (ERR_SP)
  LD   (IY+0),$FF          ;29CD; Clear the error.
  CALL BORD_REST           ;29D1; Restore the border colour.
  LD   BC,STMT_R_1         ;29D4; Return to 'STMT_R_1' in the 'main' ROM
  PUSH BC                  ;29D7; when finished.
  LD   BC,STACK_BC         ;29D8; Return to 'STMT_R_1' via 'STACK_BC'
  PUSH BC                  ;29DB; also in the 'main' ROM.
  JP   UNPAGE_HL           ;29DC; Jump to the execute address while
                                         ; unpaging the +D.

; ----------------------------------------------
; THE 'MERGE CONTROL' ROUTINE

; This routine handles the MERGEing of a (BASIC) file. No test is made if the
; file is an array when using the MERGE 'p'n syntax (see NOTE at 'LOAD
; CONTROL').

MERGE_CTRL
  LD   BC,($3E2A)          ;29DF; Fetch the length of the program to be
  PUSH BC                  ;29E3; MERGEd.
  INC  BC                  ;29E4; Extra location for the 'end marker'.
  RST  CALBAS              ;29E5; Call 'BC_SPACES' in the 'main' ROM to
  DEFW BC_SPACES           ;29E6; make the required room in workspace.
  LD   (HL),128            ;29E8; Mark the end.
  EX   DE,HL               ;29EA; Move start pointer to HL.
  POP  DE                  ;29EB; Length to DE.
  PUSH HL                  ;29EC;
  CALL LV_ANY              ;29ED; Load the file.
  POP  HL                  ;29F0; Fetch 'start' of new program.
  LD   DE,(23635)          ;29F1; Fetch 'start' of old program (PROG).
  RST  CALBAS              ;29F5; Do the MERGEing by calling the 'main'
  DEFW ME_NEW_LP           ;29F6; ROM 'MERGE' routine.
  JP   END                 ;29F8; Finished.

; ----------------------------------------------
; THE 'LOAD CONTROL' ROUTINE

; This routine handles the LOADing of a BASIC program or an array.  NOTE: The
; Spectrum will crash when trying to LOAD or MERGE 'p' an array. The problem
; starts in the 'HGFLE_2' ('OPEN A FILE FOR LOAD') subroutine in ROM ($0BCF)
; which is called from the 'LD_ETC_RUN' routine at $2908. Normally UFIA1 holds
; the parameters of the existing array (if present), and UFIA2 holds the
; parameters of the array to be loaded. But when the 'p' syntax is used, the
; 'HGFLE_2' routine makes the contents of UFIA1 equal to UFIA2. The reclaiming
; at address $2A32 then fails, trying to reclaim something which isn't there.

LOAD_CTRL
  LD   DE,($3E2A)          ;29FB; Fetch 'new' length.
  LD   HL,($3E13)          ;29FF; Fetch 'old' start (=0 when loading a
  PUSH HL                  ;2A02; 'new' array').
  LD   A,H                 ;2A03;
  OR   L                   ;2A04;
  JR   NZ,LOAD_C1          ;2A05; Jump if not a 'new' array.
  INC  DE                  ;2A07; Increment 'length' by 3, i.e. allows
  INC  DE                  ;2A08; for the insertion of array name and
  INC  DE                  ;2A09; two-byte length.
  EX   DE,HL               ;2A0A; Move 'length' to HL.
  JR   LOAD_C2             ;2A0B; Jump forward.

; The array to be loaded replaces an existing array.

LOAD_C1
  LD   HL,($3E11)          ;2A0D; Fetch 'old' length (i.e. length of
                                         ; existing program or array) from UFIA1.
  EX   DE,HL               ;2A10; Move 'new' length to HL.
  SCF                      ;2A11; Jump if the program or array to be
  SBC  HL,DE               ;2A12; loaded isn't longer than the existing
  JR   C,LOAD_C3           ;2A14; one.
LOAD_C2
  LD   DE,5                ;2A16; Otherwise a check must be made to
  ADD  HL,DE               ;2A19; ensure that there is sufficient space
  LD   B,H                 ;2A1A; in memory for the program (or array) to
  LD   C,L                 ;2A1B; be loaded.
  RST  CALBAS              ;2A1C; Make the check by calling the 'main'
  DEFW TEST_ROOM           ;2A1D; ROM 'TEST_ROOM' subroutine.
LOAD_C3
  POP  HL                  ;2A1F; Restore 'old' start (=0 when handling
  LD   A,($3E29)           ;2A20; a 'new' array).
  AND  A                   ;2A23;
  JR   Z,LD_PROG           ;2A24; Jump if it's a BASIC program.
  LD   A,H                 ;2A26;
  OR   L                   ;2A27; Jump unless an 'old' array is to be
  JR   Z,LOAD_C4           ;2A28; erased before loading the 'new' one.
  DEC  HL                  ;2A2A; Points to high byte of 'array length'.
  LD   B,(HL)              ;2A2B; Fetch the 'length'.
  DEC  HL                  ;2A2C;
  LD   C,(HL)              ;2A2D;
  DEC  HL                  ;2A2E; Now points to the 'array name'.
  INC  BC                  ;2A2F; Include 'length' and 'name' in the
  INC  BC                  ;2A30; array length.
  INC  BC                  ;2A31;
  RST  CALBAS              ;2A32; Call 'RECLAIM_2' in the 'main' ROM to
  DEFW RECLAIM_2           ;2A33; delete the array.
LOAD_C4
  LD   HL,(23641)          ;2A35; (E_LINE) points to the end of variables
  DEC  HL                  ;2A38; area+1.
  LD   BC,($3E2A)          ;2A39; Fetch length of array to be loaded.
  PUSH BC                  ;2A3D;
  INC  BC                  ;2A3E; Include in the length one byte for the
  INC  BC                  ;2A3F; 'array name' and two bytes for the
  INC  BC                  ;2A40; 'array length'.
  LD   A,($3E15)           ;2A41; Fetch the array name from 'LENGTH1_2'.
  PUSH AF                  ;2A44;
  RST  CALBAS              ;2A45; Call 'MAKE_ROOM' to create the space
  DEFW MAKE_ROOM           ;2A46; for the array.
  INC  HL                  ;2A48; Point to first 'new' location inserted.
  POP  AF                  ;2A49;
  LD   (HL),A              ;2A4A; Store array name into first location.
  POP  DE                  ;2A4B;
  INC  HL                  ;2A4C; Store array length into the following
  LD   (HL),E              ;2A4D; two locations.
  INC  HL                  ;2A4E;
  LD   (HL),D              ;2A4F;
  INC  HL                  ;2A50;
  CALL LV_ANY              ;2A51; Load the file.
  JP   END                 ;2A54; Finished.

; Now deal with the LOADing of a BASIC program and its variables.

LD_PROG
  LD   DE,(23635)          ;2A57; Fetch start of existing program.
(PROG
  )
  LD   HL,(23641)          ;2A5B; Fetch end of existing program. I.e.
  DEC  HL                  ;2A5E; (E_LINE)-1.
  RST  CALBAS              ;2A5F; Delete the program by calling
  DEFW RECLAIM_1           ;2A60; 'RECLAIM_1' in the 'main' ROM.
  LD   BC,($3E2A)          ;2A62; Fetch length of program and variables.
  LD   HL,(23635)          ;2A66; Fetch (PROG), start of a BASIC program.
  RST  CALBAS              ;2A69; Create the required space by calling
  DEFW MAKE_ROOM           ;2A6A; 'MAKE_ROOM'.
  INC  HL                  ;2A6C; Point to the first location.
  LD   BC,($3E2E)          ;2A6D; Fetch length without variables.
  ADD  HL,BC               ;2A71; Calculate and store the start of the
  LD   (23627),HL          ;2A72; variables area.
  LD   A,($3E31)           ;2A75; When no autostart is known this
  LD   H,A                 ;2A78; ('AUTOSTART2-hi') holds $FF.
  AND  $C0                 ;2A79;
  JR   NZ,LD_PROG1         ;2A7B; Jump with no autostart.
  LD   A,($3E30)           ;2A7D; Otherwise store the autostart line
  LD   L,A                 ;2A80; number into 'NEWPPC' and clear 'NSPPC'.
  LD   (23618),HL          ;2A81; These hold the line and the statement
  LD   (IY+10),$00         ;2A84; to be executed respectively.
LD_PROG1
  LD   HL,(23635)          ;2A88; Fetch the start of the BASIC program.
  LD   DE,($3E2A)          ;2A8B; Fetch the length + variables.
  DEC  HL                  ;2A8F; Reset the DATA pointer 'DATADD' to the
  LD   (23639),HL          ;2A90; beginning of the program.
  INC  HL                  ;2A93; Balance the 'DEC HL'.
  CALL LV_ANY              ;2A94; Load the file.
  JP   END                 ;2A97; Finished.

; ----------------------------------------------
; THE 'LOAD OR VERIFY' SUBROUTINE

; This subroutine is used to LOAD or VERIFY (signalled by FLAGS3) a block of
; bytes. It must be entered with HL and DE holding 'start' and 'length'.

LV_ANY
  LD   A,D                 ;2A9A;
  OR   E                   ;2A9B;
  RET  Z                   ;2A9C; Return if 'length' is zero.
  CALL TEST_7              ;2A9D;
  JR   NZ,LV_ANY3          ;2AA0; Jump if 'VERIFYing'.
  JP   LOAD_FILE           ;2AA2; Otherwise load the file.

LV_ANY1
  CP   (HL)                ;2AA5; The actual VERIFY, i.e. compare the
                                         ; fetched byte with that held in memory.
  JP   NZ,REP_12           ;2AA6; Give an error if they don't match.
LV_ANY2
  INC  HL                  ;2AA9; Next memory address.
  DEC  DE                  ;2AAA; One byte less to go.
  LD   A,D                 ;2AAB;
  OR   E                   ;2AAC;
  RET  Z                   ;2AAD; Exit if no more bytes left.
LV_ANY3
  CALL LBYT                ;2AAE; Load one byte.
  CALL TEST_7              ;2AB1;
  JR   NZ,LV_ANY1          ;2AB4; Jump if VERIFYing.
  LD   (HL),A              ;2AB6; Otherwise store the byte.
  JR   LV_ANY2             ;2AB7; Repeat for all bytes.

; ----------------------------------------------
; THE 'FORMAT' COMMAND SYNTAX ROUTINE

; This routine tests if the command has the appropriate syntax.

FORMAT
  RST  NEXT_C              ;2AB9; Advance CH_ADD to next character.
  AND  $DF                 ;2ABA; Only capitals.
  CP   "D"                 ;2ABC;
  JP   NZ,REP_0            ;2ABE; Give an error if not a "D".
  RST  NEXT_C              ;2AC1; Next character.
  CALL EXPT_DEVN2          ;2AC2; Evaluate the drive number.
  CP   204,"TO"            ;2AC5; Jump if the current character isn't
  JR   NZ,FORMAT_1         ;2AC7; 'TO'.
  CALL SWAP_UFIAS          ;2AC9; Exchange UFIA1 and UFIA2.
  RST  NEXT_C              ;2ACC; Update CH_ADD.
  CALL EXPT_DEVN2          ;2ACD; Evaluate 2nd drive number.
  CALL SWAP_UFIAS          ;2AD0; Exchange UFIA's again.
FORMAT_1
  CALL ST_END_RAM          ;2AD3; Confirm end of statement and exit when
                                         ; syntax checking.
  CALL TEST_DRV            ;2AD6; Check if the drive is defined.
  RST  CALBAS              ;2AD9;
  DEFW CLS_LOWER           ;2ADA; Clear lower screen area.
  SET  5,(IY+2)            ;2ADC; Signal 'lower screen has to be
                                         ; cleared'.
  CALL MESG_2              ;2AE0; Print 'Are you SURE ? (y/n)' message.
  CALL TEST_Y              ;2AE3; Wait for a key, Zero set means 'Y'
  JP   NZ,END              ;2AE6; pressed. Finished when not sure.
  CALL FORMAT_RUN          ;2AE9; Otherwise FORMAT the disk.
  JP   END                 ;2AEC; Finished.


; ===============================================================
; The stream handling routines

; ----------------------------------------------
; THE 'EVALUATE STREAM NUMBER' SUBROUTINE

; A single numeric expression is evaluated and the result, in the range 0..15
; is stored into 'STRM_NUM1'.

EXPT_
  #NR   RST  NEXT_C              ;2AEF; Advance CH_ADD.
EXPT_
  #NR1  RST  CALBAS              ;2AF0; Evaluate stream number.
  DEFW EXPT_1NUM           ;2AF1;
  RST  SYNTAX_Z            ;2AF3; Return if syntax is being checked.
  RET  Z                   ;2AF4;
  PUSH AF                  ;2AF5;
  RST  CALBAS              ;2AF6; Fetch the number.
  DEFW FIND_INT1           ;2AF7;
  CP   16                  ;2AF9; Give an error if it isn't in the range
  JP   NC,REP_9            ;2AFB; 0..15. ('Invalid station' ?)
  LD   ($3E03),A           ;2AFE; Store stream number into 'STRM_NUM1'.
  POP  AF                  ;2B01;
  RET                      ;2B02;

; ----------------------------------------------
; THE 'MOVE' COMMAND SYNTAX ROUTINE

; A 'MOVE' command requires two sets of parameters, for the 'input' channel,
; and for the 'output' channel. These parameters are stored into the UFIA's.

MOVE
  CALL EXPT_EXP1           ;2B03; Evaluate stream or channel expression.
  CP   204,"TO"            ;2B06; The keyword 'TO' must be present,
  JP   NZ,REP_0            ;2B08; give an error if 'TO' is missing.
  CALL SWAP_UFIAS          ;2B0B; Exchange the UFIA's.
  CALL EXPT_EXP1           ;2B0E; Evaluate second stream or channel
                                         ; expression.
  CALL SWAP_UFIAS          ;2B11; Exchange the UFIA's again.
  CALL ST_END_RAM          ;2B14; Confirm end of statement and exit
                                         ; during syntax check.

; The actual 'MOVE' command reads a byte from the source channel or stream,
; and then writes it to the destination channel or stream. This is repeated
; until the first channel or stream reports 'End Of File'. 'SIGN_2' is called
; to signal to the 'D_INPUT' routine at $2EDC that the 'END of file' error
; isn't to be generated.

  CALL SIGN_2              ;2B17; See above.
  LD   A,191,"IN"          ;2B1A; This is the keyword 'IN', it is used to
  LD   ($3E02),A           ;2B1C; signal 'READ channel'.
  CALL OP_MOVE             ;2B1F; Open the source channel/stream.
  LD   HL,(23631)          ;2B22; Save (CHANS).
  PUSH HL                  ;2B25;
  LD   A,($3E02)           ;2B26; Save 'DIR_DESCR1' into 'DIR_DESCR2'.
  LD   ($3E1E),A           ;2B29;
  CALL SWAP_UFIAS          ;2B2C; Exchange the UFIA's.
  LD   A,223,"OUT"         ;2B2F; This is the keyword 'OUT'.
  LD   ($3E02),A           ;2B31; Signal 'WRITE channel'.
  LD   IX,DFCA             ;2B34;
  CALL OP_MOVE             ;2B38; Open the destination channel/stream.
  JR   NC,MOVE_RUN1        ;2B3B; Jump if opening was successfull. I.e.
                                         ; file was 'new' or 'old' file was
                                         ; overwritten.
  LD   IX,($3E1E)          ;2B3D; Otherwise reclaim first channel
(S
  econd
  CALL RECL_CHAN           ;2B41; wasn't opened so nothing to reclaim).
  POP  HL                  ;2B44; Drop (CHANS) address.
  POP  HL                  ;2B45; ?? Drop what?
  JP   END                 ;2B46; Finished.

MOVE_RUN1
  CALL SWAP_UFIAS          ;2B49; Exchange UFIA's again.

; To my knowledge the instructions at $2B22, $2B25, $2B44 and from $2B4C to
; $2B58 aren't needed with the +D. With IF1 the Microdrive maps are situated
; between 23734 (end of Spectrum system variables) and (CHANS). The
; consequence of opening a new channel could be the creating of a new map.
; I.e. the channel information could move up and then the source channels
; address is to be recalculated. With the +D, however, nothing is situated
; between 23734 and (CHANS).

  POP  DE                  ;2B4C; Retrieve 'old' (CHANS).
  LD   HL,(23631)          ;2B4D; Fetch 'new' (CHANS).
  OR   A                   ;2B50; Calculate the space which was inserted
  SBC  HL,DE               ;2B51; under (CHANS).
  LD   DE,($3E05)          ;2B53; Adjust first channels address.
  ADD  HL,DE               ;2B57;
  LD   ($3E05),HL          ;2B58;
MOVE_RUN2
  LD   HL,($3E05)          ;2B5B; Make 'current' the first channel.
  LD   (23633),HL          ;2B5E; (CURCHL)
MOVE_RUN3
  RST  CALBAS              ;2B61; Call 'INPUT_A' in the 'main' ROM to
  DEFW INPUT_A             ;2B62; read a byte.
  JR   C,MOVE_RUN4         ;2B64; Jump with acceptable codes.
  JR   Z,MOVE_RUN3         ;2B66; Repeat if no byte read.
  JR   MOVE_RUN5           ;2B68; Jump if EOF has been reached.

; An acceptable code has been found.

MOVE_RUN4
  LD   HL,($3E1E)          ;2B6A; Make 'current' the 2nd channel.
  LD   (23633),HL          ;2B6D; (CURCHL)
  RST  CALBAS              ;2B70; Use 'main' ROM 'PRINT_A_2' to send the
  DEFW PRINT_A_2           ;2B71; byte to the 2nd channel.
  JR   MOVE_RUN2           ;2B73; Repeat until EOF.

; EOF has been reached.

MOVE_RUN5
  XOR  A                   ;2B75; Clear FLAGS3.
  LD   ($3ACF),A           ;2B76;
  LD   HL,(23631)          ;2B79; Store current (CHANS).
  PUSH HL                  ;2B7C;
  CALL SWAP_UFIAS          ;2B7D; Exchange the UFIA's.
  CALL CL_MOVE             ;2B80; Close the destination channel.
  CALL SWAP_UFIAS          ;2B83; Exchange the UFIA's again.

; Again the instructions at address $2B79, $2B7C and from $2B86 to $2B92
; aren't needed with the +D.

  POP  DE                  ;2B86; Restore initial address of CHANS.
  LD   HL,(23631)          ;2B87; Fetch current (CHANS).
  OR   A                   ;2B8A; Calculate the amount of bytes reclaimed
  SBC  HL,DE               ;2B8B; after the deletion of the second
  channel.
  LD   DE,($3E05)          ;2B8D; Calculate the new start address of the
  ADD  HL,DE               ;2B91; first channel.
  LD   ($3E05),HL          ;2B92; And store it.
  CALL CL_MOVE             ;2B95; Close the source channel.
  CALL RECL_TEMP           ;2B98; Reclaim temporary channels.
  JP   END                 ;2B9B; Finished.

; ----------------------------------------------
; THE 'RECLAIM CHANNEL' SUBROUTINE

; This subroutine is used to reclaim the channel pointed to by IX.

RECL_CHAN
  LD   C,(IX+9)            ;2B9E; Fetch channel length.
  LD   B,(IX+10)           ;2BA1;
  PUSH BC                  ;2BA4;
  PUSH IX                  ;2BA5; Channel start to HL.
  POP  HL                  ;2BA7;
  RST  CALBAS              ;2BA8; Call 'RECLAIM_2' in the 'main' ROM to
  DEFW RECLAIM_2           ;2BA9; reclaim the channel.
  POP  BC                  ;2BAB;
  RET                      ;2BAC;

; ----------------------------------------------
; THE 'EVALUATE STRM. OR EXPR.' SUBROUTINE

; This subroutine is used to check the syntax of the 'MOVE' command. If the
; 'current' character is a hash sign (#), then a stream number is evaluated.
; Otherwise a device expression is evaluated.

EXPT_EXP1
  RST  NEXT_C              ;2BAD; Advance CH_ADD.
  CP   "#"                 ;2BAE; Jump to 'EXPT_#_NR' to evaluate stream
  JP   Z,EXPT_      #NR    ;2BB0; number if character is a '#'.
EXPT_EXP2
  LD   ($3E04),A           ;2BB3; Otherwise store device letter.
  AND  $DF                 ;2BB6; Only capitals.
  CP   "D"                 ;2BB8; If device letter isn't "D" then
  CALL NZ,MD_SYN1          ;2BBA; evaluate microdrive syntax.
  CALL EXPT_DEVN           ;2BBD; Evaluate device number.
  CALL SEPARATOR           ;2BC0; If there is a separator exit via
  JP   Z,EXPT_FNAME        ;2BC3; 'EXP_F_NAME' to evaluate a filename.
  RST  SYNTAX_Z            ;2BC6;
  RET  Z                   ;2BC7; Return if checking syntax.
  PUSH AF                  ;2BC8;
  LD   A,($3E04)           ;2BC9; Fetch device letter.
  AND  $DF                 ;2BCC; Only capitals.
  CP   "D"                 ;2BCE; If the device is "D" or "M" then there
  JP   Z,REP_2             ;2BD0; must be a name present. Give an error
  CP   "M"                 ;2BD3; if no name specified.
  JP   Z,REP_2             ;2BD5;
  POP  AF                  ;2BD8;
  RET                      ;2BD9;

; ----------------------------------------------
; THE 'USE STREAM OR CHANNEL' SUBROUTINE

; This subroutine is used from the 'MOVE' command routine above to fetch the
; start address of the channel attached to a stream, or to open a channel and
; fetch its start address.

OP_MOVE
  LD   A,($3E03)           ;2BDA; Fetch stream number.
  INC  A                   ;2BDD; Jump to open a temporary channel, i.e.
  JR   Z,OP_MOVE1          ;2BDE; if the stream was nonexistent.
  DEC  A                   ;2BE0;
  RST  CALBAS              ;2BE1; Open the channel attached to stream A.
  DEFW CHAN_OPEN           ;2BE2;
  LD   HL,(23633)          ;2BE4; Store the channels address (CURCHL)
  LD   ($3E05),HL          ;2BE7; into UFIA1.
  RET                      ;2BEA; Return.

OP_MOVE1
  LD   A,($3E04)           ;2BEB; Fetch device letter.
  AND  $DF                 ;2BEE; Capitals only.
  CP   "M"                 ;2BF0;
  JR   Z,OP_MOVE2          ;2BF2; Jump if it's a "M".
  CP   "D"                 ;2BF4;
  JR   NZ,OP_MOVE3         ;2BF6; Jump if it isn't a "D".
OP_MOVE2
  CALL TEST_DRV            ;2BF8; Check if the drive is defined.
  CALL OP_TEMP_D           ;2BFB; Open a temporary "D" channel.
  LD   A,($3E05)           ;2BFE; Save 'DIR_DESCR1' into 'PROG_NUM1'.
  LD   ($3E02),A           ;2C01;
  LD   ($3E05),IX          ;2C04; Store channels address.
  RET                      ;2C08;

OP_MOVE3
  CP   "N"                 ;2C09;
  JP   NZ,REP_0            ;2C0B; Give an error if device isn't "N".
  CALL SIGN_3              ;2C0E; Otherwise signal 'using network'.
  RET                      ;2C11;

; ----------------------------------------------
; THE 'CLOSE "MOVE" CHANNEL' SUBROUTINE

; This is the opposite subroutine of the preceeding one, and is used to CLOSE
; the channel used by the 'MOVE' command routine. If 'STRM_NUM1' denotes that
; a stream was used, nothing is done.

CL_MOVE
  LD   A,($3E03)           ;2C12; Fetch stream number.
  INC  A                   ;2C15;
  RET  NZ                  ;2C16; Return if a stream has been used.
  LD   A,($3E04)           ;2C17; Otherwise fetch device letter.
  AND  $DF                 ;2C1A; Only capitals.
  CP   "N"                 ;2C1C;
  JR   Z,CL_MOVE1          ;2C1E; Jump if it was "N".
  LD   IX,($3E05)          ;2C20; Fetch channel address.
  JP   CLOSE_CHAN          ;2C24; Close the channel and exit.
CL_MOVE1
  RET                      ;2C27;

; ----------------------------------------------
; THE 'RECLAIM TEMP. CHANNELS' SUBROUTINE

; This subroutine is called to reclaim from the CHANS all 'temporary' channels
; (i.e. with bit 7 of the channel specifier set).

RECL_TEMP
  LD   IX,(23631)          ;2C28; Point to the start of the channel area.
  LD   DE,20               ;2C2C; IX now points to the first
  ADD  IX,DE               ;2C2F; 'non-standard' channel.
RECL_T1
  LD   A,(IX+0)            ;2C31;
  CP   128                 ;2C34; Return if the end marker was found,
  RET  Z                   ;2C36; i.e. there are no more channels.
  LD   A,(IX+4)            ;2C37; Fetch channel specifier.
  CP   196,"D"+128         ;2C3A;
  JR   NZ,RECL_T2          ;2C3C; Jump if not a temporary "D" channel.
  CALL CLOSE_CHAN          ;2C3E;
  JR   RECL_TEMP           ;2C41;

; Permanent "D" channels mustn't be closed, except when 'CLEAR #' was given.

RECL_T2
  CALL TEST_1              ;2C43;
  JR   Z,RECL_T3           ;2C46; Jump if not 'CLEAR # executing'.
  CALL RECL_CHAN           ;2C48; Otherwise reclaim the channel.
  JR   RECL_TEMP           ;2C4B;

; Skip this channel.

RECL_T3
  LD   E,(IX+9)            ;2C4D; Fetch channel length.
  LD   D,(IX+10)           ;2C50;
  ADD  IX,DE               ;2C53; Point to the next channel.
  JR   RECL_T1             ;2C55; Repeat for all channels.

; ----------------------------------------------
; THE 'CLOSE CHANNEL' SUBROUTINE

; This subroutine closes the channel pointed to by IX.

CLOSE_CHAN
  PUSH IX                  ;2C57;
  POP  HL                  ;2C59;
  LD   DE,(23631)          ;2C5A; (CHANS).
  OR   A                   ;2C5E;
  SBC  HL,DE               ;2C5F; Calculate channel offset.
  INC  HL                  ;2C61;
  LD   ($3DED),HL          ;2C62; The channel is CLOSEd by jumping into
  JP   CLOSE_0             ;2C65; the 'CLOSE' routine

; ----------------------------------------------
; THE 'OPEN' COMMAND SYNTAX ROUTINE

; This routine deals with the 'OPEN #' command concerning +D channels,
; Spectrum channels are handled by the 'main' ROM.

OPEN
  CALL EXPT_      #NR      ;2C68; Evaluate stream number.
  CALL SEPARATOR           ;2C6B;
  JP   NZ,REP_0            ;2C6E; Give an error if no separator found.
  CALL EXPT_EXP2           ;2C71; Evaluate channel specifier.
  CP   13                  ;2C74;
  JR   Z,OPEN_2            ;2C76; Jump if no more parameters.
  CP   191,"IN"            ;2C78;
  JR   Z,OPEN_1            ;2C7A; Jump if 'IN' specified.
  CP   223,"OUT"           ;2C7C;
  JP   NZ,REP_2            ;2C7E; Give error if no 'OUT' specified.
OPEN_1
  LD   ($3E02),A           ;2C81; Store the channel type (IN or OUT) in
                                         ; 'PROG_NUM1'.
  RST  NEXT_C              ;2C84; Advance CH_ADD.
OPEN_2
  CALL ST_END_RAM          ;2C85; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   A,($3E03)           ;2C88; Fetch stream number.
  RST  CALBAS              ;2C8B; Call 'main' ROM 'STR_DATA1' routine; on
  DEFW STR_DATA1           ;2C8C; exit, BC holds 'stream data'.
  LD   HL,17               ;2C8E;
  AND  A                   ;2C91;
  SBC  HL,BC               ;2C92; Give an error if the current stream was
  JP   C,REP_30            ;2C94; already used by the +D.
  LD   A,($3E04)           ;2C97; Fetch channel specifier.
  AND  $DF                 ;2C9A; Only capitals.
  CP   "D"                 ;2C9C;
  JR   Z,OPEN_3            ;2C9E; Jump if opening a "D" channel.
  CP   "M"                 ;2CA0; Give an error if not opening a "M"
  JP   NZ,REP_0            ;2CA2; channel.
OPEN_3
  CALL TEST_DRV            ;2CA5; See if the drive is defined.
  LD   A,$0A               ;2CA8; Signal 'OPENTYPE file'.
  LD   ($3E05),A           ;2CAA;
  CALL OPEN_CHAN           ;2CAD; Open the channel.
  JP   END                 ;2CB0; Finished.

; ----------------------------------------------
; THE 'OPEN "D" CHANNEL' SUBROUTINE

; This is the actual OPEN routine referred to the "D" channel.

OPEN_CHAN
  LD   A,($3E03)           ;2CB3; Fetch stream number.
  ADD  A,A                 ;2CB6; The streams area entries are two bytes
                                         ; each.
  LD   HL,23574            ;2CB7; Address of data for stream 0.
  LD   E,A                 ;2CBA;
  LD   D,0                 ;2CBB;
  ADD  HL,DE               ;2CBD; Index into STRMS area.
  PUSH HL                  ;2CBE;
  CALL OP_TEMP_D           ;2CBF; Open a temporary "D" channel. On return
  POP  DE                  ;2CC2; HL holds new channel offset.
  RET  C                   ;2CC3; Return when an error occurred.
  BIT  0,(IX+12)           ;2CC4;
  JR   Z,MAKE_PERM         ;2CC8; Jump if this is a 'read' file.
  IN   A,(227)             ;2CCA; Read Floppy Disk Controller status.
  BIT  6,A                 ;2CCC; Test the 'write protect' bit.
  JR   Z,MAKE_PERM         ;2CCE; Jump if disk isn't write protected.

; NOTE: This doesn't work, the write protect bit of the FDC's status register
; is not adjusted with read commands. So the jump is always made.

  CALL RECL_CHAN           ;2CD0; Otherwise reclaim the channel.
  JP   REP_23              ;2CD3; And give an error.
MAKE_PERM
  RES  7,(IX+4)            ;2CD6; Make the channel permanent by resetting
                                         ; bit 7 of the channel specifier.
  EX   DE,HL               ;2CDA; DE holds new channel offset.
  LD   (HL),E              ;2CDB; Store it into the STRMS area.
  INC  HL                  ;2CDC;
  LD   (HL),D              ;2CDD;
  RET                      ;2CDE; Finished.

; ----------------------------------------------
; THE 'OPEN TEMP. "D" CHANNEL' SUBROUTINE

; This subroutine is used to open a temporary "D" channel in the CHANS area.

OP_TEMP_D
  LD   IX,(23631)          ;2CDF; Start of channel area (CHANS).
  LD   DE,20               ;2CE3; Point to the first 'non-standard'
  ADD  IX,DE               ;2CE6; channel.
OP_TEMP1
  LD   A,(IX+0)            ;2CE8;
  CP   128                 ;2CEB;
  JR   Z,OP_TEMP4          ;2CED; Jump if end of CHANS area is reached.
  LD   A,(IX+4)            ;2CEF; Otherwise fetch channel specifier.
  AND  $5F                 ;2CF2; Clear bit 7 and make capital.
  CP   "D"                 ;2CF4;
  JR   NZ,OP_TEMP3         ;2CF6; Jump if this isn't a "D" channel.
  LD   A,(UFIA1)           ;2CF8; Fetch drive number.
  CP   (IX+11)             ;2CFB; Jump if this channel uses a different
  JR   NZ,OP_TEMP3         ;2CFE; drive.
  PUSH IX                  ;2D00;
  POP  HL                  ;2D02; Start of channel to HL.
  LD   DE,20               ;2D03; Filename offset.
  ADD  HL,DE               ;2D06;
  EX   DE,HL               ;2D07; DE points to the name of this channel.
  LD   HL,$3E06            ;2D08; HL points to the name of the channel to
  LD   B,10                ;2D0B; be opened.
OP_TEMP2
  LD   A,(DE)              ;2D0D;
  XOR  (HL)                ;2D0E;
  AND  $DF                 ;2D0F; Capitalize.
  JR   NZ,OP_TEMP3         ;2D11; Jump if not the same file.
  INC  HL                  ;2D13;
  INC  DE                  ;2D14;
  DJNZ OP_TEMP2            ;2D15; Repeat for all 10 characters.
  JP   REP_31              ;2D17; Give an error if the channel already
                                         ; exists.
OP_TEMP3
  LD   E,(IX+9)            ;2D1A; Fetch the length of the channel.
  LD   D,(IX+10)           ;2D1D;
  ADD  IX,DE               ;2D20; Point to the next channel.
  JR   OP_TEMP1            ;2D22; Repeat for all channels.

; The channel wasn't already present in memory so it can be opened.

OP_TEMP4
  PUSH IX                  ;2D24;
  LD   A,%0001000          ;2D26; Scan the CATalogue for a matching
  CALL SCAN_CAT            ;2D28; filename.
  LD   A,($3E02)           ;2D2B; Get channel type (read/write).
  JP   NZ,OP_TEMP5         ;2D2E; Jump if file not found.
  CP   223,"OUT"           ;2D31;
  JP   Z,OP_T_PATCH        ;2D33; Jump if OUTput channel.
  LD   BC,551              ;2D36; Length of INput channel.
  CALL CHAN_SPC            ;2D39; Create the room for the channel.
  CALL RPT_HL              ;2D3C; Make HL point to the CAT entry.
  POP  IX                  ;2D3F;
  CALL TEST_DRV            ;2D41; See if the drive is defined.
  NOP                      ;2D44;
  NOP                      ;2D45;
  NOP                      ;2D46;
  LD   A,0                 ;2D47; Signal 'READing'.
  LD   (IX+12),A           ;2D49;
  LD   BC,39               ;2D4C; Offset of buffer from start of channel.
  LD   (IX+15),C           ;2D4F;
  LD   (IX+16),B           ;2D52;
  PUSH HL                  ;2D55; HL points to the CATalogue entry.
  PUSH IX                  ;2D56; IX points to the start of the channel.
  POP  HL                  ;2D58;
  LD   DE,19               ;2D59; Offset of directory description.
  ADD  HL,DE               ;2D5C;
  EX   DE,HL               ;2D5D;
  POP  HL                  ;2D5E; Pointer to CAT entry.
  LD   BC,11               ;2D5F; Move the directory description and the
  LD   A,(HL)              ;2D62; filename to the channel.
  LD   ($3E05),A           ;2D63; Store dir. descr. in UFIA1.
  LDIR                     ;2D66;
  INC  HL                  ;2D68; Skip length in sectors, i.e. point to
  INC  HL                  ;2D69; track and sector bytes.
  LD   B,(HL)              ;2D6A; Fetch first track and sector.
  INC  HL                  ;2D6B;
  LD   C,(HL)              ;2D6C;
  PUSH BC                  ;2D6D;
  LD   BC,196              ;2D6E;
  ADD  HL,BC               ;2D71; HL points to file header - 1 in CAT
  LD   A,(HL)              ;2D72; entry. That is the MSB of the file
  LD   (IX+18),A           ;2D73; length (number of 64K blocks).
  INC  HL                  ;2D76;
  LD   BC,9                ;2D77;
  LDIR                     ;2D7A; Copy the file header to the channel.
  LD   DE,$3FEA            ;2D7C;
  LD   BC,22               ;2D7F; Copy the SNAP registers (?).
  LDIR                     ;2D82;
  POP  DE                  ;2D84; Get track and sector in DE.
  CALL RSAD                ;2D85; Load the sector at DE.
  JR   OP_TEMP8            ;2D88;

; The file was not found, so if the channel isn't for OUTput give an error.

OP_TEMP5
  CP   191,"IN"            ;2D8A;
  JP   Z,REP_26            ;2D8C; Give error if it is an INput channel.
OP_TEMP6
  LD   BC,787              ;2D8F; Length of OUTput channel.
  CALL CHAN_SPC            ;2D92; Create the room for the channel.
  POP  IX                  ;2D95;
  CALL TEST_DRV            ;2D97; See if the drive is defined.
  NOP                      ;2D9A;
  NOP                      ;2D9B;
  NOP                      ;2D9C;
  LD   A,1                 ;2D9D; Signal 'WRITEing'.
  LD   (IX+12),A           ;2D9F;
  LD   BC,275              ;2DA2; Offset of databuffer from the start of
  LD   (IX+15),C           ;2DA5; the channel.
  LD   (IX+16),B           ;2DA8;
  CALL OFSM_2              ;2DAB; Open the file.
  JR   Z,OP_TEMP7          ;2DAE; Jump if file doesn't exist (anymore).
  LD   BC,787              ;2DB0; Length of an OUTput channel.
  PUSH IX                  ;2DB3; Start of the channel to HL.
  POP  HL                  ;2DB5;
  RST  CALBAS              ;2DB6; Reclaim the channel.
  DEFW RECLAIM_2           ;2DB7;
  SCF                      ;2DB9; Signal 'error'.
  RET                      ;2DBA; Finished.

OP_TEMP7
  JP   OP_TEMP8            ;2DBB; Jump forward.

; Before the routine continues there are first some 'leftovers' from a earlier
; system version.

  JR   Z,OP_TEMP8          ;2DBE;
  PUSH IX                  ;2DC0;
  POP  HL                  ;2DC2;
  LD   DE,230              ;2DC3;
  ADD  HL,DE               ;2DC6;
  EX   DE,HL               ;2DC7;
  LD   HL,($3E1E)          ;2DC8;
  LD   BC,30               ;2DCB;
  ADD  HL,BC               ;2DCE;
  LD   BC,9                ;2DCF;
  LDIR                     ;2DD2;
  LD   HL,$3FEA            ;2DD4;
  LD   BC,20               ;2DD7;
  LDIR                     ;2DDA;

; Now continue with the 'OPEN a temporary "D" channel' routine.

OP_TEMP8
  PUSH IX                  ;2DDC;
  POP  DE                  ;2DDE; Start of channel to DE.
  LD   HL,D_CH_DATA        ;2DDF; Start of the "D" channel data.
  LD   BC,11               ;2DE2; Copy the 11 bytes channel data to the
  LDIR                     ;2DE5; channel area.
  PUSH IX                  ;2DE7; Start of channel to HL.
  POP  HL                  ;2DE9;
  LD   DE,(23631)          ;2DEA; HL-(CHANS)+1 gives the required 'stream
  OR   A                   ;2DEE; offset'.
  SBC  HL,DE               ;2DEF;
  INC  HL                  ;2DF1;
  RET                      ;2DF2; Finished.

; ----------------------------------------------
; THE 'MAKE ROOM FOR CHANNEL' SUBROUTINE

; This small subroutine creates room for a channel at the end of the CHANS
; area (i.e. just before the BASIC program).

CHAN_SPC
  LD   ($2E14),BC          ;2DF3; Store the length of the channel into
                                         ; the "D" channel data table.
  LD   HL,(23635)          ;2DF7; Fetch the start address of the channel
  DEC  HL                  ;2DFA; ((PROG)-1).
  PUSH HL                  ;2DFB;
  PUSH BC                  ;2DFC;
  RST  CALBAS              ;2DFD; Create the required space by calling
  DEFW MAKE_ROOM           ;2DFE; 'main' ROM 'MAKE_ROOM'.
  POP  BC                  ;2E00;
  POP  HL                  ;2E01; Clear the created space.
CHAN_SPC1
  LD   (HL),0              ;2E02;
  INC  HL                  ;2E04;
  DEC  BC                  ;2E05;
  LD   A,B                 ;2E06;
  OR   C                   ;2E07;
  JR   NZ,CHAN_SPC1        ;2E08;
  RET                      ;2E0A;

; ----------------------------------------------
; THE '"D" CHANNEL DATA' TABLE

; The '11' bytes that compose the initial part of a "D" channel are as
; follows:

D_CH_DATA
  DEFW $0008               ;2E0B; Main ROM 'output' routine.
  DEFW $0008               ;2E0D; Main ROM 'input' routine.
  DEFB "D"+128             ;2E0F; Channel specifier.
  DEFW DCHAN_OUT           ;2E10; +D system 'output' routine.
  DEFW D_INPUT             ;2E12; +D system 'input' routine.
  DEFW $0000               ;2E14; Length of a channel.

; ----------------------------------------------
; THE 'CLOSE #' COMMAND SYNTAX ROUTINE

; Unlike the Interface 1 and the Opus Discovery, the +D doesn't page-in in the
; middle of the 'main' ROM 'CLOSE' routine. But because the 'main' ROM routine
; can't cope with +D channels a 'CLOSE' for those channels has to be
; available. In order to fail the normal syntax, 'CLOSE #*s' has to be used.
; The 'CLOSE #*' command closes all streams.

CLOSE
  RST  NEXT_C              ;2E16; Next character.
  CP   "*"                 ;2E17;
  JP   NZ,REP_0            ;2E19; Give an error if it isn't a '*'.
  RST  NEXT_C              ;2E1C; Next character.
  CP   13                  ;2E1D;
  JR   Z,CLOSE_ALL         ;2E1F; Jump if statement ended with ENTER.
  CP   ":"                 ;2E21;
  JR   Z,CLOSE_ALL         ;2E23; Also if statement ended with a ':'.
  CALL EXPT_      #NR1     ;2E25; Evaluate stream number.
  CALL ST_END_RAM          ;2E28; Confirm end of statement and exit when
                                         ; syntax checking.
  LD   A,($3E03)           ;2E2B; Fetch stream number.
  CALL CLOSE_STRM          ;2E2E; Close the stream.
  JP   END                 ;2E31; Finished.

CLOSE_ALL
  CALL ST_END_RAM          ;2E34; Confirm end of statement and exit if
  JR   CLEAR_1             ;2E37; syntax checking. Jump into the CLEAR#
                                         ; routine.

; ----------------------------------------------
; THE 'CLEAR #' COMMAND ROUTINE

; All streams are closed in turn, with bit 1 of FLAGS3 set to signal that the
; remaining buffer contents are to be erased (with the 'CLOSE #*' command all
; buffers are emptied, i.e. their contents are sent to the corresponding
; device).

CLEAR
  RST  NEXT_C              ;2E39; Advance CH_ADD.
  CP   "#"                 ;2E3A;
  JP   NZ,REP_0            ;2E3C; Give an error if it isn't a '#'.
  RST  NEXT_C              ;2E3F;
  CALL ST_END_RAM          ;2E40; Confirm end of statement and exit
                                         ; during syntax checking.
  CALL SIGN_1              ;2E43; Signal 'CLEAR #'.
CLEAR_1
  XOR  A                   ;2E46; Start with stream 0.
CLEAR_2
  PUSH AF                  ;2E47;
  CALL CLOSE_STRM          ;2E48; Close this stream.
  POP  AF                  ;2E4B;
  INC  A                   ;2E4C; Next stream.
  CP   16                  ;2E4D; Repeat until all streams 0..15 have
  JR   C,CLEAR_2           ;2E4F; been CLOSEd.
  CALL RECL_TEMP           ;2E51; Reclaim temporary channels.
  XOR  A                   ;2E54;
  LD   ($3DEF),A           ;2E55; Clear 'MAP_USED' (=POKE @7663,0).
  LD   ($3ACF),A           ;2E58; Clear FLAGS3.
  JP   END                 ;2E5B; Finished.

; ----------------------------------------------
; THE 'CLOSE A STREAM' SUBROUTINE

; Any stream 0 to 15 may be CLOSEd by loading the stream number into A and
; then calling this subroutine. The unsent bytes in 'OUTput' files are sent or
; lost depending upon whether bit 1 of FLAGS3 is reset or set. First a call to
; 'STR_DATA1' in the 'main' ROM is made to fetch into BC the 'stream data' for
; the given stream, and to make HL point to the first of the two data bytes.

CLOSE_STRM
  RST  CALBAS              ;2E5E; Call 'STR_DATA1'.
  DEFW STR_DATA1           ;2E5F;
  LD   A,C                 ;2E61;
  OR   B                   ;2E62; Return if the stream is already CLOSEd
  RET  Z                   ;2E63; (i.e. stream data = 0).
  LD   ($3DED),BC          ;2E64; Store stream data.
  PUSH HL                  ;2E68;
  LD   HL,(23631)          ;2E69; Make HL point to the start of the
  DEC  HL                  ;2E6C; channel attached to the stream to be
  ADD  HL,BC               ;2E6D; CLOSEd ((CHANS)+'stream data').
  EX   (SP),HL             ;2E6E; HL now holds the address of the stream
                                         ; data.
  RST  CALBAS              ;2E6F; A call in the middle of the 'main' ROM
  DEFW CLOSE_0             ;2E70; 'CLOSE' routine is made to update STRMS
                                         ; contents.
  POP  IX                  ;2E72; IX points to the start of the channel
  LD   A,B                 ;2E74; to be removed.
  OR   C                   ;2E75;
  RET  NZ                  ;2E76; Exit if the stream is one of 0 to 3.

; NOTE: Because this test tests for streams a disk channel attached to one of
; the streams 0..3 can never be CLOSEd. If the test was made for 'standard'
; channels it had been possible to use streams 0..3 with "D" channels.

  LD   A,(IX+4)            ;2E77; Fetch channel specifier.
  AND  $5F                 ;2E7A; Clear bit 7 (temporary) and make
                                         ; capital.
  CP   "D"                 ;2E7C;
  JR   NZ,CLOSE_1          ;2E7E; Jump if it isn't a "D" channel.
CLOSE_0
  BIT  0,(IX+12)           ;2E80;
  JR   Z,CLOSE_1           ;2E84; Jump if it is an 'INput' channel.
  CALL TEST_1              ;2E86; Jump if doing a 'CLEAR #', i.e. just
  JR   NZ,CLOSE_1          ;2E89; remove the channel.
  CALL CL_PATCH            ;2E8B; Empty the buffer.
CLOSE_1
  CALL RECL_CHAN           ;2E8E; Reclaim the channel.

; Now all data refering to the stream attached to the channels moved down are
; updated.

  XOR  A                   ;2E91; Start with stream 0.
  LD   HL,23574            ;2E92; Address of data for stream 0.
CLOSE_2
  LD   ($3AC8),HL          ;2E95; Use 'FILE_ADDR' as a temporary storage.
  LD   E,(HL)              ;2E98; Fetch stream data.
  INC  HL                  ;2E99;
  LD   D,(HL)              ;2E9A;
  LD   HL,($3DED)          ;2E9B; Fetch stream data for CLOSEd stream.
  AND  A                   ;2E9E; Jump if the stream data found is lower
  SBC  HL,DE               ;2E9F; than that of the CLOSEd stream (i.e.
  JR   NC,CLOSE_3          ;2EA1; channel has not been moved).
  EX   DE,HL               ;2EA3; Fetched stream data to HL.
  AND  A                   ;2EA4;
  SBC  HL,BC               ;2EA5; Calculate the new stream data.
  EX   DE,HL               ;2EA7; New stream data to DE.
  LD   HL,($3AC8)          ;2EA8; Restore stream data address.
  LD   (HL),E              ;2EAB; Store new stream data.
  INC  HL                  ;2EAC;
  LD   (HL),D              ;2EAD;
CLOSE_3
  LD   HL,($3AC8)          ;2EAE; Make HL point to next stream data.
  INC  HL                  ;2EB1;
  INC  HL                  ;2EB2;
  INC  A                   ;2EB3; Increment stream number.
  CP   16                  ;2EB4;
  JR   C,CLOSE_2           ;2EB6; Repeat for all streams 0..15.
  RET                      ;2EB8; Finished.

; ----------------------------------------------
; THE 'CLS #' COMMAND ROUTINE

; The 'CLS #' command resets during runtime the Spectrum system variables
; ATTR_P, ATTR_T, MASK_P, MASK_T, P_FLAG and BORDCR. I.e. all these variables
; are filled with their 'initial' values (paper 7, ink 0, flash 0 and bright
; 0).

CLS
  RST  NEXT_C              ;2EB9; Next character.
  CP   "#"                 ;2EBA;
  JP   NZ,REP_0            ;2EBC; Give error if it isn't a '#'.
  RST  NEXT_C              ;2EBF; Next character.
  CALL ST_END_RAM          ;2EC0; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   HL,56               ;2EC3; The 'initial' attribute value.
  LD   (23693),HL          ;2EC6; Store 56 into ATTR_P, clear MASK_P.
  LD   (23695),HL          ;2EC9; Store 56 into ATTR_T, clear MASK_T.
  LD   (IY+14),L           ;2ECC; Store 56 also for lower screen
                                         ; attribute.
  LD   (IY+87),H           ;2ECF; Clear P_FLAG.
  LD   A,7                 ;2ED2; Set white border.
  OUT  (254),A             ;2ED4;
  RST  CALBAS              ;2ED6; Call 'main' ROM 'CLS' routine.
  DEFW CLS                 ;2ED7;
  JP   END                 ;2ED9; Finished.

; ----------------------------------------------
; THE '"D" CHANNEL INPUT' ROUTINE

; This is a peculiar routine, although the +D supports only one type of
; channel (the "D" channel), this routine can handle all kinds of channels by
; loading HL with the address of the 'service' input routine and entering at
; address $2EE3. From that address on it's largely the same as the Interface 1
; 'CALL_INP' routine, which routine handles all the IF1's channels.

D_INPUT
  LD   IX,(23633)          ;2EDC; IX points to the start of the current
                                         ; channel (CURCHL).
  LD   HL,DCHAN_IN         ;2EE0; Address of "D" input service routine.
  RES  3,(IY+2)            ;2EE3; Signal 'the mode is to be considered as
                                         ; being unchanged'.
  PUSH HL                  ;2EE7; Store address of service routine.
  LD   HL,(23613)          ;2EE8; HL points to error address (ERR_SP).
  LD   E,(HL)              ;2EEB; Fetch the error address.
  INC  HL                  ;2EEC;
  LD   D,(HL)              ;2EED;
  AND  A                   ;2EEE;
  LD   HL,ED_ERROR         ;2EEF; If the error address is 'ED_ERROR'
  SBC  HL,DE               ;2EF2; ('main' ROM) then an INPUT command was
  JR   NZ,D_INKEY      $   ;2EF4; used. Jump if unequal to 'ED_ERROR'.

; Now deal with an 'INPUT #' command referred to a "D" channel.

  POP  HL                  ;2EF6; Restore address of service routine.
  LD   SP,(23613)          ;2EF7; Clear the machine stack (ERR_SP).
  POP  DE                  ;2EFB; Remove 'ED_ERROR'.
  POP  DE                  ;2EFC;
  LD   (23613),DE          ;2EFD; Restore the old value of ERR_SP.
D_INPUT1
  PUSH HL                  ;2F01; Store address of service routine.
  LD   DE,D_INP_END        ;2F02; Return address is 'D_INP_END' below.
  PUSH DE                  ;2F05;
  JP   (HL)                ;2F06; Jump to the service routine.

; When the byte has been read from the required channel, a return is made here
; to add the byte to the INPUT line, or to return if the byte is equal to CHR$
; 13, i.e.  ENTER.

D_INP_END
  JR   C,D_INP_ACC         ;2F07; Jump with acceptable codes.
  JP   NZ,REP_27           ;2F09; Give the 'END of file' error when the
                                         ; Zero flag is reset.
  POP  HL                  ;2F0C; Otherwise restore address of service
  JR   D_INPUT1            ;2F0D; routine and try again.

D_INP_ACC
  CP   13                  ;2F0F;
  JR   Z,D_INPUT2          ;2F11; Jump if the code is ENTER.
  RST  CALBAS              ;2F13; Otherwise the byte is to be added to
  DEFW ADD_CHAR0           ;2F14; the INPUT line. This is done by calling
                                         ; into the 'ADD_CHAR' subroutine.
  POP  HL                  ;2F16; Restore address of service routine and
  JR   D_INPUT1            ;2F17; read the next byte.

D_INPUT2
  POP  HL                  ;2F19; Drop the address of the service routine
  JP   UNPAGE_1            ;2F1A; and page-out the +D system.

; Now deal with the reading of a single byte.

D_INKEY
  $   POP  HL                  ;2F1D; Restore address of the servce routine.
  LD   DE,D_INK      $_END ;2F1E; Return address is 'D_INK$_END' below.
  PUSH DE                  ;2F21;
  JP   (HL)                ;2F22; Jump to the service routine.

D_INK
  $_END RET  C                   ;2F23; Return with acceptable codes or
  RET  Z                   ;2F24; with no byte read.
  CALL TEST_2              ;2F25; Give the 'END of file' error if not
  JP   Z,REP_27            ;2F28; executing a 'MOVE' command.
  OR   1                   ;2F2B; Otherwise return with Zero and Carry
  RET                      ;2F2D; flags both reset.

; ----------------------------------------------
; THE '"D" CHANNEL INPUT' SERVICE ROUTINE

; This is the actual input a byte from disk routine. The byte is read from the
; data buffer in the channel, when it is empty the next sector is read from
; disk (provided that the 'current' data block is not the EOF one) before
; reading the byte.

DCHAN_IN
  BIT  0,(IX+12)           ;2F2E; Give 'Reading a WRITE file' error if
  JP   NZ,REP_18           ;2F32; it's an OUTput channel.
  LD   A,(IX+31)           ;2F35; Decrease LSB of file length.
  SUB  1                   ;2F38;
  LD   (IX+31),A           ;2F3A;
  JR   NC,DCHAN_IN1        ;2F3D; Jump if more bytes left.
  LD   A,(IX+32)           ;2F3F; Decrease MID byte of file length.
  SUB  1                   ;2F42;
  LD   (IX+32),A           ;2F44;
  JR   NC,DCHAN_IN1        ;2F47; Jump if more bytes left.
  LD   A,(IX+18)           ;2F49; Decrease MSB of file length.
  SUB  1                   ;2F4C;
  LD   (IX+18),A           ;2F4E;
  JR   NC,DCHAN_IN1        ;2F51; Jump if more bytes left.
  XOR  A                   ;2F53; Otherwise EOF has been reached, so
                                         ; reset Zero and Carry flag to signal
                                         ; 'End Of File'.
  ADD  A,13                ;2F54; The return byte is 13.
  RET                      ;2F56; Finished.

; NOTE: This 'end of file' test works only once, if an attempt is made to read
; more bytes after the 'End of FILE' message has been given a crash will
; almost certainly follow.

D_CHANIN1
  CALL LBYT                ;2F57; Load one byte, read a new sector from
                                         ; disk when the buffer is empty.
  CALL BORD_REST           ;2F5A; Restore border colour.
  SCF                      ;2F5D; Signal 'acceptable code'.
  RET                      ;2F5E;

; ----------------------------------------------
; THE '"D" CHANNEL OUTPUT' ROUTINE

; The routine which handles "D" channel output is quite short. It SAVEs the
; byte in the A register to disk by calling the ROM 'SBYT' routine, which
; handles the saving of the byte.  The only thing done here is incrementing
; the file length bytes.

DCHAN_OUT
  LD   IX,(23633)          ;2F5F; IX point to current channel (CURCHL).
  BIT  0,(IX+12)           ;2F63; Give 'Writing a READ file' error if
  JP   Z,REP_19            ;2F67; it's an INput channel.
  CALL SBYT                ;2F6A; Save the byte in the A register.
  CALL BORD_REST           ;2F6D; Restore the border colour.
  NOP                      ;2F70;
  NOP                      ;2F71;
  NOP                      ;2F72;
  NOP                      ;2F73;
  PUSH IX                  ;2F74;
  LD   BC,229              ;2F76;
  ADD  IX,BC               ;2F79; IX now points to the file header.
  INC  (IX+2)              ;2F7B; Update file length, skip higher bytes
  JR   NZ,DCHAN_OUT1       ;2F7E; if it isn't necessary to update them.
  INC  (IX+3)              ;2F80;
  JR   NZ,DCHAN_OUT1       ;2F83;
  INC  (IX+0)              ;2F85;
DCHAN_OUT1
  POP  IX                  ;2F88;
  RET                      ;2F8A; Finished.


; ===============================================================
; The Command code routines

; ----------------------------------------------
; THE 'TRANSFER UFIA TO DFCA' SUBROUTINE

; This subroutine is called by using command code 51 ($33), it transfers the
; file description and header (UFIA) to the Disk File Channel Area (DFCA). On
; entry IX must point to the start of the User's File Information Area (UFIA).

HXFER
  PUSH IX                  ;2F8B;
  POP  HL                  ;2F8D;
  LD   DE,UFIA1            ;2F8E; Start of 'UFIA1'.
  LD   BC,24               ;2F91;
  LDIR                     ;2F94; Transfer the UFIA to 'UFIA1'.
  LD   IX,DFCA             ;2F96;
  CALL TEST_DRV            ;2F9A; Check if the specified drive is
  RET                      ;2F9D; defined.

; ----------------------------------------------
; THE 'OPEN FILE SECTOR MAP' SUBROUTINE

; This subroutine is called by using command code 52 ($34), it Opens a File
; Sector Map with the information contained in the DFCA. On entry IX must
; point to the UFIA, a call to 'HXFER' above transfers the UFIA to the DFCA. A
; return is made with the disk buffer pointer (RPT) set to the start of the
; disk buffer in the +D RAM. 'OFSM' should be used for files which don't
; contain a 9 byte header at the start of the file.

OFSM
  CALL HXFER               ;2F9E; Transfer UFIA to DFCA.
  JP   OFSM_2              ;2FA1; Open the file sector map.

; ----------------------------------------------
; THE 'OPEN A FILE' SUBROUTINE

; This subroutine is called by using command code 53 ($35), it opens a file
; for SAVEing.  As with the preceeding subroutines IX must point to the UFIA.
; By calling 'OFSM' above the UFIA is transferred to the DFCA and the file
; sector map is opened. Finally 'SAVE_HEAD1' is called to transfer the 9 bytes
; file header to the file. 'HOFLE' can be used for files which contain the 9
; byte header.

HOFLE
  CALL OFSM                ;2FA4; Transfer UFIA to DFCA and open the file
                                         ; sector map.
  CALL SAVE_HEAD1          ;2FA7; Transfer the 9 byte file header to the
  RET                      ;2FAA; file and exit.

; ----------------------------------------------
; THE 'SAVE BLOCK TO DISK' SUBROUTINE

; This is called by using command code 55 ($37). The data block starting at
; address DE with length BC is SAVEd to disk.  NOTE: A file has to be opened
; for SAVEing before writing bytes. Use 'HOFLE' or 'OFSM' to do this.

HSVBK
  CALL BCDE_DEHL           ;2FAB; Transfer BC to DE and DE to HL.
  JP   HSVBK_2             ;2FAE; Save the block.

; ----------------------------------------------
; THE 'GET A FILE FROM DISK' SUBROUTINE

; This is called by using command code 59 ($3B), it opens a file for LOADing.
; The IX register must point to the start of the UFIA. The return is made with
; the first sector of the file loaded into the disk buffer and RPT pointing to
; the first byte (usually the start of the 9 byte file header).

HGFLE
  CALL HXFER               ;2FB1; Transfer the UFIA to the DFCA.
  JP   HGFLE_2             ;2FB4; Open the file and load the first sector
                                         ; in the disk buffer.

; ----------------------------------------------
; THE 'LOAD BLOCK FROM DISK' SUBROUTINE

; This subroutine is called by using command code 61 ($3D), it does the
; opposite of 'HSVBK' above. The data block starting at address DE with length
; BC is LOADed from disk.  NOTE: The file has to be opened by using 'HGFLE'
; before an attempt can be made to LOAD bytes. Don't try to LOAD more bytes
; than available.

HLDBK
  CALL BCDE_DEHL           ;2FB7; Transfer BC to DE and DE to HL.
  JP   LOAD_FILE           ;2FBA; Load the block.

; ----------------------------------------------
; THE 'ERASE A FILE' SUBROUTINE

; This is called by using command code 65 ($41). It ERASEs one file on the
; disk (even when wildcards were used), using the information contained in the
; UFIA, so make sure that IX points to the start of it.

HERAZ
  CALL HXFER               ;2FBD; Transfer the UFIA to the DFCA.
  CALL FIND_FILE           ;2FC0; Find the file, HL points to the
                                         ; directory entry of the file (contained
                                         ; in the disk buffer).
  JP   NZ,REP_26           ;2FC3; Give error if file not found.
  LD   (HL),0              ;2FC6; Directory description 0 means ERASEd.
  JP   WSAD                ;2FC8; Write sector DE.

; ----------------------------------------------
; THE 'BC TO DE AND DE TO HL' SUBROUTINE

; This routine transfers the contents of BC to DE and that of DE to HL, it
; also sets IX to the start of the DFCA.

BCDE_DEHL
  PUSH DE                  ;2FCB;
  PUSH BC                  ;2FCC;
  POP  DE                  ;2FCD;
  POP  HL                  ;2FCE;
  LD   IX,DFCA             ;2FCF;
  RET                      ;2FD3;

; ----------------------------------------------
; THE 'READ SECTOR TO ADDRESS' SUBROUTINE

; This routine is called by using command code 68 ($44). It reads sector DE
; from drive A to the address held in the IX register.

HRSAD
  PUSH BC                  ;2FD4;
  PUSH IX                  ;2FD5;
  LD   IX,DFCA             ;2FD7;
  CALL TEST_DRV            ;2FDB; See if the drive held in the A register
                                         ; is defined.
  CALL RSAD                ;2FDE; Load the sector into the disk buffer.
  POP  HL                  ;2FE1;
  PUSH DE                  ;2FE2;
  LD   DE,$3BD6            ;2FE3; Start of disk buffer.
  EX   DE,HL               ;2FE6;
  LD   BC,512              ;2FE7; Sector length.
  LDIR                     ;2FEA; Move sector to specified address.
  PUSH DE                  ;2FEC;
  POP  IX                  ;2FED; Update IX.
  POP  DE                  ;2FEF; Restore DE and BC.
  POP  BC                  ;2FF0;
  RET                      ;2FF1;

; ----------------------------------------------
; THE 'WRITE SECTOR FROM ADDR.' SUBROUTINE

; This is called using command code 69 ($45), it writes sector DE to drive A
; starting from address IX.

HWSAD
  PUSH BC                  ;2FF2;
  PUSH IX                  ;2FF3;
  POP  HL                  ;2FF5;
  LD   IX,DFCA             ;2FF6;
  CALL TEST_DRV            ;2FFA; See if the drive held in the A register
  PUSH DE                  ;2FFD; is defined.
  LD   DE,$3BD6            ;2FFE;
  LD   BC,512              ;3001; Sector length.
  LDIR                     ;3004; Move BC bytes to the disk buffer.
  POP  DE                  ;3006;
  PUSH HL                  ;3007;
  CALL WSAD                ;3008; Write sector DE to disk.
  POP  IX                  ;300B;
  POP  BC                  ;300D;
  RET                      ;300E; Finished.

; ----------------------------------------------
; THE 'READ SECTOR DE' SUBROUTINE

; This routine is called using command code 63 ($3F), it loads sector DE from
; the current drive into the disk buffer.

JRSAD
  LD   IX,DFCA             ;300F;
  JP   RSAD                ;3013; Load the sector.

; ----------------------------------------------
; THE 'WRITE SECTOR DE' SUBROUTINE

; This is called using command code 62 ($3E), it saves the contents of the
; disk buffer into sector DE on the current drive.

JWSAD
  LD   IX,DFCA             ;3016;
  JP   WSAD                ;301A; Save the sector.


; ===============================================================
; Miscalleneous routines III

; ----------------------------------------------
; THE 'COPY SCREEN' ROUTINE

; This routine has two entry points. The first one, $301D, is used with the
; BASIC commands 'SAVE/LOAD/VERIFY/MERGE SCREEN$'. The second entry point
; ($3020) is used for the 'COPY' command itself. Depending on the parameter
; following the 'SCREEN$', the normal or the grey scale screen dump is used.

DUMP_SCR
  $  POP  HL                  ;301D; Drop the return address (within the
                                         ; routine which called 'EXPT_PARMS').
  JR   COPY_1              ;301E; Jump forward.

COPY
  RST  NEXT_C              ;3020; Advance CH_ADD.
  CP   170,"SCREEN$"       ;3021; Give 'Nonsense in G+DOS' error if
  JP   NZ,REP_0            ;3023; command isn't followed by 'SCREEN$'.
COPY_1
  LD   A,49,"1"            ;3026; Default is '1' for 'normal' dump.
  LD   ($3E00),A           ;3028;
  RST  NEXT_C              ;302B; Advance CH_ADD
  CP   13                  ;302C;
  JR   Z,COPY_2            ;302E; Jump with ENTER.
  CP   ":"                 ;3030;
  JR   Z,COPY_2            ;3032; Also jump with ':'.
  LD   ($3E00),A           ;3034; Otherwise store character.
  RST  NEXT_C              ;3037; Update CH_ADD again.
COPY_2
  CALL ST_END_RAM          ;3038; Confirm end of statement and exit
                                         ; during syntax checking.
  LD   A,($3E00)           ;303B;
  CP   "1"                 ;303E; Normal screendump if '1' followed the
  CALL Z,COPS              ;3040; 'SCREEN$'.
  CP   "2"                 ;3043; Grey scale in case of a '2'.
  CALL Z,COPS2             ;3045; Ignore other values.
  JP   END                 ;3048; Finished.


; ===============================================================
; The system message routines

; Finally there follow some messages. A message follows directly after the
; CALL to the ROM print routine.

MSG_0
  CALL PO_MSG1             ;304B;
  DEFM "* MGT PLUS D DISC" ;304E;
  DEFB " "+128             ;3060;
MSG_1
  CALL PO_MSG1             ;3061;
  DEFM " CATALOGUE *"      ;3064;
  DEFB 13,13+128           ;3070;
MSG_2
  CALL PO_MSG1             ;3072;
  DEFB 13,13               ;3075;
  DEFB "Number of Free K-Bytes =";3077;
  DEFB " "+128             ;308F;
MSG_3
  CALL PO_MSG              ;3090;
  DEFM "©Miles Gordon Technology G+DOS2a";3093;
  DEFB 13,13+128           ;30B3;

; This routine makes sure the 'SOURCE' and 'TARGET' messages are printed in
; turn.

TO_MSG1
  LD   A,($3107)           ;30B5;
  XOR  $01                 ;30B8;
  LD   ($3107),A           ;30BA;
  JR   NZ,MSG_5            ;30BD;
MSG_4
  CALL PO_MSG1             ;30BF;
  DEFB 13                  ;30C2;
  DEFM "Insert SOURCE disc - press SPAC"
  DEFB "E"+128             ;30E2;
MSG_5
  CALL PO_MSG1             ;30E3;
  DEFB 13                  ;30E6;
  DEFM "Insert TARGET disc - press SPAC"
  DEFB "E"+128             ;3106;

  DEFB $00                 ;3107;

; ----------------------------------------------
; THE 'CLEAR MESSAGE FLAG' SUBROUTINE


TEST_SAVE
  XOR  A                   ;3108; Clear the flag used in printing
  LD   ($3107),A           ;3109; 'SOURCE' and 'TARGET' message.
  CALL TEST_5              ;310C;
  RET                      ;310F;


; ===============================================================
; The patches

; ----------------------------------------------
; THE 'OPENTYPE FILE OPEN/CLOSE' ROUTINE

; This routine opens or closes an opentype file according to the contents of
; the A register. When it holds 0 a "D" channel is attached to the stream
; given in the DFCA. A non zero value closes the corresponding stream.

OTFOC
  AND  A                   ;3110;
  JP   Z,OPEN_CHAN         ;3111; Open a channel if A holds zero.
  JP   CLOSE_STRM          ;3114; Otherwise close the stream.

; ----------------------------------------------
; THE 'CLOSE #' PATCH

; This patch cures the bug related to CLOSEing 'OPENTYPE' files. Before the
; file is CLOSEd first the correct drive settings are send to the FDC.

CL_PATCH
  LD   E,(IX+17)           ;3117; Fetch sector and track.
  LD   D,(IX+18)           ;311A;
  LD   A,(IX+11)           ;311D; Fetch drive number.
  LD   ($3ACE),A           ;3120;
  CALL SET_DRVSD           ;3123; Select track, sector, side and drive.
  CALL CFSM                ;3126; Close the file sector map.
  RET                      ;3129; Finished.

; ----------------------------------------------
; THE 'OPEN TEMPORARY OUTPUT' PATCH

; This patch gives an error report when an attempt is made to open an existing
; OUTput file using a command code. A jump back to the 'open a temporary
; channel' routine is made if not using a command code.

OP_T_PATCH
  PUSH HL                  ;312A;
  LD   HL,($2066)          ;312B;
  LD   A,H                 ;312E;
  OR   L                   ;312F; Jump back to the 'OP_TEMP' routine if
  POP  HL                  ;3130; 'D_ERR_SP' is zero (this isn't the case
  JP   Z,OP_TEMP6          ;3131; during command code execution).
  JP   REP_28              ;3134; Otherwise give 'File NAME used' error.

; ----------------------------------------------
; THE 'NEW' PATCH

; When the file copy command is finished the +D jumps to the 'NEW' routine.
; With System 2a a selection is made for 48K or 128K 'NEW'

TO_NEW
  BIT  4,(IY+1)            ;3137; Jump if not in 128K mode HL contains
  JP   Z,UNPAGE_HL         ;313B; $11B7, the address of 48K 'NEW'.
  CALL SWAP                ;313E; Call the paging subroutine of the 128.
  DI                       ;3141;
  LD   BC,$00C7            ;3142; Address of 128 'NEW' routine.
  JP   UNPAGE_BC           ;3145;

; ----------------------------------------------
; THE 'END OF STATEMENT' ROUTINE

; It isn't clear why IX should point to $000C during syntax checking.

ST_END_RAM
  LD   IX,$000C            ;3148;
  CALL ST_END              ;314C;
  LD   IX,DFCA             ;314F;
  RET                      ;3153;

; ----------------------------------------------
; THE 'PCAT' ROUTINE

; This routine is called by using command code 67, in System 2a the command
; code works.

PCAT
  CALL TEST_DRV            ;3154; Drive defined?
  LD   A,($3E10)           ;3157; Get 'CAT' type.
  JP   CAT_RUN             ;315A; Do the CAT.

; $315D..$39FF Unused locations (all set to $00).


; ----------------------------------------------
; Disk File Channel Area (DFCA)

  ORG $3AC3

  DFCA
  DEFW 0  ; length of file in sectors
  DEFW 0  ; bytes left to load or save
  DEFB 0  ; some flags
  DEFW 0  ; load/save address
  DEFB 0  ; drive
  DEFB 0  ; operation flag
                        ; bit 7 : verify
                        ; bit 6 : merge
                        ; bit 5 : save
                        ; bit 4 : load
                        ; bit 0 : other
  DEFW 0
  DEFW 0
  DEFB 0  ; current track
  DEFB 0  ; current sector


  ORG $3DD8

  SECTORS_USED ; XXX TODO --

; ----------------------------------------------
; UFIA1

  ORG $3E01

  UFIA1   ; XXX TODO --

; ----------------------------------------------
; UFIA2

  ORG $3E1A

  UFIA2   ; XXX TODO --

; vim: filetype=z80
