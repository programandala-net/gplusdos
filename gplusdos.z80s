; G+DOS Disassambled

; Disassembly of G+DOS version 2a (including +D ROM version 1.A)

; G+DOS was written by Bruce Gordon, from Miles Gordon Technology, 1987, 1988.
;
; The original disassembly was done by Rudy Biesma (JRB), 2005-11:
; http://www.biehold.nl/rudy/plusd/plusd.htm
;
; This edited version in source form was prepared by Marcos Cruz
; (programandala.net) in 2016-2018, from the disassembly done by Rudy Biesma.

; Credit:
;
; The following document was very useful: "DISCiPLE/+D Technical Guide"
; Revision 8c (30 Jan 2004) by Luca Bisti et al. (Ramsoft).

; Last modified: 201803041141

; ===============================================================
; ZX Spectrum symbols 

include inc/zx_spectrum_char_codes.z80s
include inc/zx_spectrum_rom_routines.z80s

; ===============================================================
; The restart routines

; ----------------------------------------------
; THE 'POWER UP RESET' RESTART

; When the Spectrum is turned on or the reset button is pressed, the +D ROM is
; paged in at address 0, i.e. the routine listed here is executed.

  org $0000

power_up:
  nop                      ;0000;
  ld   bc,$0101            ;0001;
  nop                      ;0004;
  jp   power_up2           ;0005; Jump to main routine.

; ----------------------------------------------
; THE 'USE G+DOS' RESTART

; This is the main entry point to the +D system; it is paged in when the Z80
; reaches address $0008, that is, the address of the 'main' ROM 'ERROR'
; routine.

start:
  ld   hl,(23645)          ;0008; The address reached by the interpreter
  ld   (23647),hl          ;000B; (CH_ADD) is copied to the error pointer
  jr   start2              ;000E; (X_PTR) before proceeding.

; ----------------------------------------------
; THE 'CALL A MAIN ROM ROUTINE' RESTART

; This routine allows for a subroutine in the 'main' ROM to be called from the
; +D system. It can be called by using a RST $10 instruction, followed by the
; address of the 'main' ROM subroutine.

calbas:
  jp   calbas_2            ;0010; Jump forward.

; ----------------------------------------------
; THE 'START_2' ROUTINE


start2:
  jp   start_3             ;0013; Continue with the +D systems main
                                ; entry routine.
  defb $00,$00             ;0016; Unused locations.

; ----------------------------------------------
; THE 'FLAGS ADDRESS' RESTART

; This routine is used by the -BIT- routines at address $15F4, the original HL
; is saved and the flags address is loaded into HL.

f_addr:
  ex   (sp),hl             ;0018; Exchange RETurn address and HL.
  push hl                  ;0019; Re-stack RETurn address.
  ld   hl,flags3           ;001A; Address of FLAGS3.
  ret                      ;001D;
  defb $00,$00             ;001E; Unused locations.

; ----------------------------------------------
; THE '+D ERROR' RESTART

; A RST $20 followed by a one-byte error code will print the appropriate
; message, when the error occurred during the execution of a command code
; however, the error code will be returned in the A register with the Carry
; flag set.

disc_err:
  ld   hl,(23645)          ;0020; The address reached by the interpreter
  ld   (23647),hl          ;0023; is copied to the error pointer before
  jr   disc_err2           ;0026; proceeding.

; ----------------------------------------------
; THE 'NEXT CHAR' RESTART

; This routine gets the next character from a BASIC line, it does this by
; calling the RST $20 routine in the 'main' ROM.

next_c:
  rst  calbas              ;0028; Call 'main' ROM 'NEXT_CHAR'.
  defw rom_next_char       ;0029;
  ret                      ;002B;

; ----------------------------------------------
; THE 'GET CHAR' ROUTINE

; Get character by calling the 'main' ROM restart.

get_c:
  rst  calbas              ;002C; Call 'main' ROM 'GET_CHAR'.
  defw rom_get_char        ;002D;
  ret                      ;002F;

; ----------------------------------------------
; THE 'SYNTAX-Z' RESTART

; This corresponds to the 'main' ROM 'SYNTAX-Z' subroutine. A test of bit 7 of
; FLAGS will give the Zero flag set during syntax checking, and reset during
; execution.

syntax_z:
  bit  7,(iy+1)            ;0030; Test the runtime flag.
  ret                      ;0034;

; ----------------------------------------------
; THE 'DISC_ERR2' ROUTINE


disc_err2:
  jp   d_error             ;0035; Continue with the +D error routine.

; ----------------------------------------------
; THE 'MASKABLE INTERRUPT' RESTART

; While the +D system is paged in, 'nothing' is done during an interrupt.

int:
  ei                       ;0038; Enable interrupts before RETurning.
  ret                      ;0039;

; ----------------------------------------------
; AN 'UNUSED' SUBROUTINE

; This is probably a piece of an older ROM version, it loads HL with (FRAMES)
; and CALLs another unused routine at $02E3.

  ld   hl,(23672)          ;003A; Get the two LSBs of FRAMES.
  call $02E3               ;003D;
  out  (231),a             ;0040; Page-out.
  defb $B5                 ;0042;
  defb $00,$00,$00         ;0043;

; ----------------------------------------------
; THE 'UNPAGE 128 ROM' SUBROUTINE

; This routine pages out the +D system and returns to the 128K ROM at address
; $0049. That address contains a RET instruction so the effect is a jump to BC
; with the 128K ROM paged in.

  org $0046                ; Make the `ret` be at $0049.

unpage_bc:
  push bc                  ;0046; Stack return address.
unpage_0:
  out  (231),a             ;0047; Page out +D system.
  ret                      ;0049; This statement is not reached from above.

  defb $00,$00,$00,$00,$00 ;004A; Unused locations.

; ----------------------------------------------
; THE 'UNPAGE' SUBROUTINE

; This routine pages out the +D system and returns to the 'main' ROM at
; address $0052.  That address contains a RET instruction so the effect is a
; jump to HL with the 'main' ROM paged in.

  org $004F                ; Make the `ret` be at $0052.

unpage_hl:
  push hl                  ;004F; Stack return address.
unpage_1:
  out  (231),a             ;0050; Page out +D system.
  ret                      ;0052; This statement is not reached from above.

; ===============================================================
; The Snapshot routines

; ----------------------------------------------
; THE 'NON-MASKABLE INTERRUPT' CONTINUED

; This piece of code determines whether the NMI button was pressed or a return
; from a CALBAS was made.

nmi_1:
  ld   a,(calbas_flag)     ;0053;
  cp   $47                 ;0056; Check if returning from a CALBAS.
  jr   nz,nmi_2            ;0058; Jump if not returning from a CALBAS.
  xor  a                   ;005A;
  ld   (calbas_flag),a     ;005B; Clear CALBAS executing.
  pop  af                  ;005E; Restore A register and return to the
  ret                      ;005F; calling routine.
nmi_2:
  ld   a,r                 ;0060;
  push af                  ;0062; Save R register and interrupt status.
  jr   snapshot            ;0063;
  defb $00                 ;0065;

; ----------------------------------------------
; THE 'NON-MASKABLE INTERRUPT' ROUTINE

; This is the third point, from address $0000, at which the +D system is paged
; in. It is reached  either by pressing the 'snapshot' button or when
; returning from a CALBAS.

nmi:
  push af                  ;0066; Save A register.
  jr   nmi_1               ;0067;

; ----------------------------------------------
; THE 'SNAPSHOT' ROUTINE

; When the 'snapshot' button is pressed this routine is executed. By pressing
; the keys 1 or 2 a choice can be made to dump the screen to the printer in
; small or grey- scale format. As soon as the system file is loaded it is
; possible to make snapshots to disk (See $20A1 and further).

snapshot:
  ld   (sp_backup),sp      ;0069; Use 'internal' stack.
  ld   sp,internal_stack   ;006D;
  ld   a,i                 ;0070;
  push af                  ;0072; Save all registers, starting with I.
  push hl                  ;0073;
  push bc                  ;0074;
  push de                  ;0075;
  ex   af,af'              ;0076; Save alternative registerset.
  exx                      ;0077;
  push af                  ;0078;
  push hl                  ;0079;
  push bc                  ;007A;
  push de                  ;007B;
  push ix                  ;007C; Save the index registers.
  push iy                  ;007E;
  di                       ;0080; Disable interrupts in case $0066 was
                                ; called normally. When a NMI occurs the
                                ; Z80 disables interrupts.
  ld   hl,snap_exit        ;0081;
  push hl                  ;0084; RETurn address from snapshot.
  ld   (d_err_sp),sp       ;0085; Store current stackpointer at D_ERR_SP
                                ; so an error will activate SNAP_EXIT.
snap_keys:
  ld   bc,$F7FE            ;0089; Keyboard port and key 1-5 I/O address.
  in   e,(c)               ;008C;
  bit  0,e                 ;008E; CASE key OF
  jp   z,cops              ;0090; 1: jump to the smallcopy routine.
  bit  1,e                 ;0093;
  jp   z,cops2             ;0095; 2: jump to the greyscale routine.
  call system_z            ;0098; System loaded?
  call z,jsnap             ;009B; Yes, then call system snap routine.
  inc  a                   ;009E; END CASE.
  and  $07                 ;009F;
  out  (c),a               ;00A1; Nice stripes in border.
  ld   b,$FE               ;00A3; CAPS-V I/O address.
  in   e,(c)               ;00A5;
  bit  2,e                 ;00A7;
  jr   nz,snap_keys        ;00A9; Test for X, loop if not pressed.
snap_key1:
  in   e,(c)               ;00AB;
  bit  2,e                 ;00AD;
  jr   z,snap_key1         ;00AF; Wait until X is released again.

; ----------------------------------------------
; THE 'SNAP_EXIT' ROUTINE

; This routine is used to return to the snapshotted program.

snap_exit:
  di                       ;00B1;
  ld   hl,$0000            ;00B2; Clear D_ERR_SP.
  ld   (d_err_sp),hl       ;00B5;
  call bord_rest           ;00B8;
  ld   sp,$3FEA            ;00BB;
  pop  iy                  ;00BE; Restore the index registers.
  pop  ix                  ;00C0;
  pop  de                  ;00C2; Restore the alternate registerset.
  pop  bc                  ;00C3;
  pop  hl                  ;00C4;
  pop  af                  ;00C5;
  ex   af,af'              ;00C6;
  exx                      ;00C7;
  call d_rombank           ;00C8; Determine current 'main' ROM bank.
  jr   nz,snap_ex3         ;00CB; Jump if 128K ROM bank.
  call rest_pbuf           ;00CD;
  pop  de                  ;00D0; Restore the registerset.
  pop  bc                  ;00D1;
  pop  hl                  ;00D2;
  pop  af                  ;00D3;
  ld   i,a                 ;00D4;
  cp   $00                 ;00D6;
  jr   z,snap_ex1          ;00D8;
  cp   $3F                 ;00DA; When the I register doesn't contain $00
  jr   z,snap_ex1          ;00DC; or $3F, it is most likely that the
  im   2                   ;00DE; interrupt mode is 2.
snap_ex1:
  ld   sp,(sp_backup)      ;00E0; Restore stack pointer.
  pop  af                  ;00E4;
  ld   r,a                 ;00E5; Jump if the interupts were disabled
  jp   po,snap_ex2         ;00E7; when 'SNAPSHOT' was entered.
  push hl                  ;00EA;
  ld   hl,$004F            ;00EB; Otherwise return to snapshotted program
  jp   unpage_hl           ;00EE; via 'main' ROM "POP  HL", "POP  AF" and "EI".
snap_ex2:
  pop  af                  ;00F1; Return to the instruction before which
  jp   unpage_1            ;00F2; the snapshot occurred.

; This piece of code does almost the same as the above. The only difference is
; that it returns to the 128 'main' ROM at a somewhat different address.

snap_ex3:
  call rest_pbuf           ;00F5;
  pop  de                  ;00F8;
  pop  bc                  ;00F9;
  pop  hl                  ;00FA;
  pop  af                  ;00FB;
  ld   i,a                 ;00FC;
  cp   $00                 ;00FE;
  jr   z,snap_ex4          ;0100;
  cp   $3F                 ;0102;
  jr   z,snap_ex4          ;0104;
  im   2                   ;0106;
snap_ex4:
  ld   sp,(sp_backup)      ;0108;
  pop  af                  ;010C;
  ld   r,a                 ;010D;
  jp   po,snap_ex5         ;010F;
  push bc                  ;0112;
  ld   bc,$007B            ;0113;
  jp   unpage_bc           ;0116;

snap_ex5:
  pop  af                  ;0119;
  jp   unpage_0            ;011A;

; ----------------------------------------------
; THE 'DETERMINE 128K ROM BANK' SUBROUTINE

; This routine determines, by examining the byte at address $0001, which bank
; of the 128K ROM is selected. Because the +D system is currently paged in the
; 'main' ROM can't be accessed directly. So a routine, which pages out the +D,
; is copied to the printer buffer.  But first the first 10 bytes of the
; printer buffer are saved.

d_rombank:
  ld   hl,23296            ;011D; Save the 10 bytes needed by the
  ld   de,$3BE6            ;0120; subroutine in +D RAM.
  ld   bc,10               ;0123;
  ldir                     ;0126;
  ld   hl,det_rom          ;0128; Copy the subroutine to the freed bytes.
  ld   de,det_rom_copy     ;012B;
  ld   bc,10               ;012E;
  ldir                     ;0131;
  ld   a,$47               ;0133; Signal 'CALBAS executing' (the NMI
  ld   (calbas_flag),a     ;0135; routine returns immediately).
  jp   det_rom_copy        ;0138; Exit via DET_ROM.


; ===============================================================
; The control routine

; This routine is called from 'START' at $0008, when the +D system is paged
; in.  It has three main tasks:
;
; - If a disc channel has been requested, it jumps to the required 'input' or
; 'output' routine.
;
; - If a hook/command code is used, it jumps to the required routine.
;
; - If an error occurred in the 'main' ROM, it checks whether a +D command was
; used. If so the corresponding routine is called, otherwise a return is made
; to the 'main' ROM, except when the +D variable ONERR holds a non zero
; address.  In that case a CALBAS to that address is made.

start_3:
  ld   (d_ch_add),hl       ;013B; +D's CH_ADD (D_CH_ADD).
  ld   ($3E4F),a           ;013E;
  pop  hl                  ;0141; Get RETurn address (usually points to
  push hl                  ;0142; the error code).
  push de                  ;0143;

; Now see if a +D channel has been requested.

  and  a                   ;0144;
  ld   de,$15FE            ;0145; If a channel has been requested, this
                                ; is the RETurn address stored by the
                                ; CALL $162C in the 'CALL-SUB' subroutine
                                ; in the Spectrum ROM.
  sbc  hl,de               ;0148;
  pop  de                  ;014A;
  jr   nz,start_4          ;014B; Jump if no channels have been requested
  ld   hl,unpage_1         ;014D; Make UNPAGE_1 RETurn address
  push hl                  ;0150;

; Now see if the channel requested is the "P" channel. The +D "P" channel
; differs only from the Spectrum's in the 'input' and 'output' addresses. For
; the +D they both are $0008. There is no information in the channel on what
; the +D system's in/output addresses are (as with "D" channels). So it has to
; be handled separately.

  push bc                  ;0151;
  ld   hl,(23631)          ;0152; Fetch CHANS.
  ld   bc,16               ;0155; Point to "P" channel.
  add  hl,bc               ;0158;
  sbc  hl,de               ;0159; DE holds address of requested channel.
  pop  bc                  ;015B;
  jp   z,pchan_out         ;015C; Jump if +D "P" channel was used.
  ld   hl,4                ;015F; DE holds address of routine pointer-4.
                                ; See $15EF in 'main' ROM.
  add  hl,de               ;0162; HL now holds address of routine pointer
  ld   e,(hl)              ;0163;
  inc  hl                  ;0164; Fetch routine address.
  ld   d,(hl)              ;0165;
  ex   de,hl               ;0166; HL now points to the routine.
  jp   (hl)                ;0167; Jump to the appropriate 'input' or
                                ; 'output' routine.

; At this point, the +D has been paged-in by an error in the 'main' ROM or by
; a hook/command code. When an error occurred during a CALBAS and D_ERR_SP
; isn't zero, the error has to be handled by the 'main' ROM. If D_ERR_SP is
; zero, the error is reported to the routine which executed a CALBAS.

start_4:
  ld   a,(calbas_flag)     ;0168; Check if the +D CALLed a Spectrum
  cp   $47                 ;016B; ROM routine.
  jr   nz,start_5          ;016D; Jump if it didn't.
  xor  a                   ;016F;
  ld   (flags3),a          ;0170; Clear CALBAS executing.
  pop  hl                  ;0173; Fetch RETurn address.
  rst  calbas              ;0174; This CALL's a LD A,(HL) in the Spectrum
  defw $007B               ;0175; ROM, so the error code is fetched.
  ld   (23610),a           ;0177; Store the error code in ERR_NR.
  ld   hl,(d_err_sp)       ;017A; Fetch D_ERR_SP.
  ld   a,h                 ;017D;
  or   l                   ;017E; Jump if D_ERR_SP was zero, that is when
  jp   z,spec_err1         ;017F; the 'main' ROM has to handle the error.
  set  7,(iy+0)            ;0182; Signal 'Spectrum error'.
  ld   a,(23610)           ;0186; Copy error code in A register.
  ld   sp,hl               ;0189; Clear stack.
  scf                      ;018A; Signal 'error and exit', someone else
  ret                      ;018B; has to handle the error.

; Now it is most likely that the +D has to handle the problem which the 'main'
; ROM couldn't.

start_5:
  pop  hl                  ;018C; Fetch address of error or hook/command
                                ; code (the byte after RST $08).
  rst  calbas              ;018D; Fetch the byte.
  defw $007B               ;018E;
  ld   (23610),a           ;0190; Store it in ERR_NR.
  cp   255                 ;0193;
  jr   nz,start_7          ;0195; Jump if the error isn't 'OK'.
  call system_z            ;0197; System loaded?
  call z,system_ok         ;019A; Yes, then check if it's OK.
  jr   z,start_6           ;019D; Give 'OK G+DOS' message if so.
  bit  7,(iy+12)           ;019F; Give the message also if PPC-hi
  jr   z,start_6           ;01A3; indicates line is not in editing area.
  ld   hl,(23641)          ;01A5; Fetch the command from the editing area
  ld   a,(hl)              ;01A8;
  cp   token.run           ;01A9; 'RUN' command?
  jp   z,run               ;01AB; Load the system file if the command is 'RUN'.
start_6:
  jp   rep_20              ;01AE;

; The error code in the A register determines the task to be executed.

start_7:
  sub  27                  ;01B1; Adjust range, hookcodes start at 0 now.
  jr   c,start_8           ;01B3; Jump if it isn't a hook or command code
  call system_z            ;01B5; Jump to the system routine if the
  jp   z,jhook             ;01B8; system is loaded.
  cp   44                  ;01BB; Give the error 'No G+DOS loaded' except
  jp   nz,rep_29           ;01BD; with command code 71.
  ld   (iy+0),$FF          ;01C0; Clear the error.
  set  2,(iy+1)            ;01C4;
  inc  hl                  ;01C8; Advance return address past the code.
  push hl                  ;01C9;
  ret                      ;01CA;

start_8:
  cp   240                 ;01CB; Jump if the error is
  jr   z,test_input        ;01CD; 'Nonsense in BASIC'.
  cp   243                 ;01CF;
  jr   z,test_input        ;01D1; Also if it is 'Invalid filename'.
  cp   252                 ;01D3;
  jr   z,test_input        ;01D5; Or 'Invalid stream'.
  cp   230                 ;01D7; Jump to the 'main' ROM error handler if
  jp   nz,spec_err1        ;01D9; it isn't 'Variable not found'.
test_input:
  bit  5,(iy+55)           ;01DC; Use 'main' ROM error handler also if in
  jp   nz,spec_err1        ;01E0; INPUT mode.
  rst  syntax_z            ;01E3;
  jr   nz,runtime          ;01E4; Jump during RUNtime.
  ld   (iy+12),$FF         ;01E6; Signal 'syntax time' (PPC-hi).

; Now a loop is entered to find the line that has produced the error. The
; routine used here is copied from the IF1 and is way ahead of the DISCiPLE's
; backstepping routine.

runtime:
  ld   b,(iy+13)           ;01EA; Statement counter.
  ld   c,0                 ;01ED; Counter of ' " ' characters.
  bit  7,(iy+12)           ;01EF; Jump forward if the line is in the
  jr   z,prog_line         ;01F3; program area.
  push bc                  ;01F5; Save counters.
  rst  calbas              ;01F6; Call main ROM 'E-LINE-NO' (it fetches
  defw rom_e_line_no       ;01F7; the number of the line in the editing
                                ; area, but is actually used to update
                                ; CH-ADD to the 1st char.in the line).
  pop  bc                  ;01F9; Restore counters.
  rst  calbas              ;01FA; Update HL to the first character in
  defw rom_get_char        ;01FB; the line.
  jr   s_stat              ;01FD;

prog_line:
  ld   hl,(23635)          ;01FF; (PROG), start of the program area.
sc_l_loop:
  ld   a,(iy+12)           ;0202; Give error if the current line number
  cp   (hl)                ;0205; is greater than that of the line to be
  jp   c,rep_0             ;0206; searched for.
  inc  hl                  ;0209; Point to low byte of line number.
  jr   nz,line_len         ;020A; Jump if not at expected line.
  ld   a,(23621)           ;020C; Compare also the low byte of the line
  cp   (hl)                ;020F; numbers (PPC-lo).
  jp   c,rep_0             ;0210; Give error if the line doesn't exist.
line_len:
  inc  hl                  ;0213; Fetch line length.
  ld   e,(hl)              ;0214;
  inc  hl                  ;0215;
  ld   d,(hl)              ;0216;
  inc  hl                  ;0217;
  jr   z,s_stat            ;0218; Jump forward if the line is found.
  add  hl,de               ;021A;
  jr   sc_l_loop           ;021B; Next line.

skip_num:
  ld   de,6                ;021D; Length of a floating point number
  add  hl,de               ;0220; and marker.

; This loop advances HL until it points to the start of the statement that has
; produced the error.

each_st:
  ld   a,(hl)              ;0221; Get a character from the line.
  cp   $0E                 ;0222;
  jr   z,skip_num          ;0224; Skip over floating point numbers.
  inc  hl                  ;0226;
  cp   '"'                 ;0227;
  jr   nz,chkend           ;0229;
  dec  c                   ;022B; Decrement counter for each ' " '.
chkend:
  cp   ":"                 ;022C;
  jr   z,chkeven           ;022E; A colon or the 'THEN' keyword
  cp   token.then          ;0230; mark the beginning of a new statement, but
  jr   nz,chkend_l         ;0232; only if they occur out of a string.
chkeven:
  bit  0,c                 ;0234; I.e. the number of quotes found must
  jr   z,s_stat            ;0236; be even.
chkend_l:
  cp   13                  ;0238;
  jr   nz,each_st          ;023A; Repeat until 'end of line'.
  jp   rep_0               ;023C; An uneven number of quotes is
                                ; unacceptable.
s_stat:
  djnz each_st             ;023F; Loop for every statement in the line.
  dec  hl                  ;0241; Update CH_ADD to the address of
  ld   (23645),hl          ;0242; the statement found.
  rst  syntax_z            ;0245;
  jr   nz,cl_work          ;0246; Jump forward during runtime.
  bit  7,(iy+12)           ;0248; Give an error if the line is not in the
  jp   z,spec_err          ;024C; editing area.

; The final loop is made during syntax checking, for removing all 6-byte
; floating point numbers inserted in the line by the 'main' ROM interpreter.

  dec  hl                  ;024F; Balance the "INC HL" below.
  ld   c,0                 ;0250; ???? C isn't used anymore.
rclm_num:
  inc  hl                  ;0252; Point to next character.
  ld   a,(hl)              ;0253;
  cp   $0E                 ;0254; Is it a 'number' marker ?
  jr   nz,next_num         ;0256; Jump if not.
  push bc                  ;0258; ???? again.
  ld   bc,6                ;0259;
  rst  calbas              ;025C; Reclaim the 6 bytes forming a number
  defw rom_reclaim_2       ;025D; and the 'number marker'.
  push hl                  ;025F;
  ld   de,(d_ch_add)       ;0260; Fetch D_CH_ADD.
  and  a                   ;0264; Jump if the number bytes reclaimed were
  sbc  hl,de               ;0265; after the character pointed to by
  jr   nc,nxt_1            ;0267; D_CH_ADD.
  ex   de,hl               ;0269; Otherwise D_CH_ADD has to be updated.
  ld   bc,6                ;026A;
  and  a                   ;026D; The character pointed by D_CH_ADD has
  sbc  hl,bc               ;026E; been moved '6' bytes down.
  ld   (d_ch_add),hl       ;0270; Update D_CH_ADD.
nxt_1:
  pop  hl                  ;0273;
  pop  bc                  ;0274;
next_num:
  ld   a,(hl)              ;0275;
  cp   13                  ;0276;
  jr   nz,rclm_num         ;0278; Again repeat until 'end of line'.

; Now the working area is cleared. The two commands 'RUN' and 'POKE' are
; handled by the +D ROM, the G+DOS system should handle all other commands.

cl_work:
  rst  calbas              ;027A; Clear Spectrum work areas by calling
  defw rom_set_work        ;027B; 'SET_WORK' in 'main' ROM.
  rst  next_c              ;027D;
  cp   token.poke          ;027E; 'POKE' keyword?
  jp   z,poke_fetch        ;0280; Jump with 'POKE' command.
  call system_z            ;0283; The system routine is called when
  call z,jctrl             ;0286; present.
  jp   spec_err            ;0289; Otherwise give an error.

; XXX FIXME -- The original disassembly has two problems here: a number used
; as label and an unknown label used as destination:

;2843
;  jr   z,l82d1        ;028C;

; XXX TMP -- Since the line seems unused, a rest of an old version of the
; code, this can be used instead:

   dw 0                    ;028C; Unused

; ===============================================================
; The periodic routines & The +D default variables and tables

; ----------------------------------------------
; THE 'KEY-SCAN' ROUTINE

; This is another entry point to the +D system; it is paged in when the Z80
; reaches address $028E, that is, the Spectrum 'KEY-SCAN' routine. So whenever
; the Spectrum tries to scan the keyboard by calling this routine the +D is
; paged in first.

keyscan:
  ld   l,$2F               ;028E; Same instruction as in 'main' ROM.
  call keysc_1             ;0290;
  nop                      ;0293; Page-out into the 'main' ROM
  out  (231),a             ;0294; 'KEY_SCAN'.

keysc_1:
  call keysc_2             ;0296;
  ld   l,$2F               ;0299; Restore registers for 'main' ROM
  ld   de,$FFFF            ;029B; 'KEY-SCAN'
  ld   bc,$FEFE            ;029E;
  ret                      ;02A1;

keysc_2:
  ld   a,(calbas_flag)     ;02A2;
  cp   $47                 ;02A5; If a CALBAS was under execution return
  ret  z                   ;02A7; immediately to 'main' ROM 'KEY-SCAN'.
  ld   a,(system_status)   ;02A8;
  cp   system_status.minimal ;02AB;
  jp   z,take_prtr         ;02AD; Jump if this is a minimal system.
  cp   $44                 ;02B0; Initialize the minimal system if there
  jr   nz,nosys            ;02B2; is no system file loaded.
  call jkscan              ;02B4; Otherwise call the appropriate system
  jp   take_prtr           ;02B7; routine and exit refreshing the 'P'
                                ; channel.

nosys:
  ld   hl,plus_d_ram       ;02BA;
  ld   bc,plus_d_ram_size  ;02BD; Clear the 8K RAM.
clr_ram:
  ld   (hl),0              ;02C0;
  inc  hl                  ;02C2;
  dec  bc                  ;02C3;
  ld   a,b                 ;02C4;
  or   c                   ;02C5;
  jr   nz,clr_ram          ;02C6;
  out  (239),a             ;02C8; Clear control port.
  out  (247),a             ;02CA; Clear printer port.
  ld   hl,default_system_variables ;02CC; Copy the default system variables and
  ld   de,system_variables ;02CF; settings to RAM.
  ld   bc,104              ;02D2;
  ldir                     ;02D5;
  ld   a,system_status.minimal ;02D7; Signal 'minimal' system
  ld   (system_status),a   ;02D9;
  ld   hl,275              ;02DC; Disk buffer offset.
  ld   ($3AD2),hl          ;02DF;
  ret                      ;02E2;

  push bc                  ;02E3; Leftover routine?
  push de                  ;02E4;
  push hl                  ;02E5;
  call keysc_2             ;02E6;
  pop  hl                  ;02E9;
  inc  hl                  ;02EA;
  ld   (23672),hl          ;02EB;
  pop  de                  ;02EE;
  pop  bc                  ;02EF;
  ld   a,h                 ;02F0;
  ret                      ;02F1;

; ----------------------------------------------
; THE DEFAULT 'SYSTEM VARIABLES'

; These variables hold various default settings for drives etc. They can be
; accessed from BASIC with POKE @p,n. Where p is 0 for RBCC at $2000. The
; default variables and system tables, addresses $02F2-$0359, are copied to
; $2000 if there is no system file loaded.

default_system_variables:

default_rbcc:
  defb $00       ;02F2; @0        No flashing borders.
default_traks1:
  defb 80+128    ;02F3; @1        Drive 1 80 tracks double sided.
default_traks2:
  defb 80+128    ;02F4; @2        Drive 2 80 tracks double sided.
default_stprat:
  defb 12        ;02F5; @3        "Steprate" 0 ms.
default_nstat:
  defb 1         ;02F6; @4        Network off.
default_width:
  defb 80        ;02F7; @5        Printer right margin.
default_pcode:
  defb 0         ;02F8; @6        Expand tokens, etc. before printing.
default_lspce:
  defb 12        ;02F9; @7        Line spacing 12/72 inch.
default_lfeed:
  defb 0         ;02FA; @8        Number of line feeds after CR 1.
default_lmarg:
  defb 0         ;02FB; @9        Left margin at 0.
default_graph:
  defb 1         ;02FC; @10       Print graphic images of some chars.
default_zxpnt:
  defb 1         ;02FD; @11       +D printer port not used.
default_reserved
  defw $0000     ;02FE; @12
default_onerr
  defw $0000     ;0301; @14       Address of routine called after an
                               ;           error has occurred.
default_every_int
  defw $0000     ;0303; @16       Address of routine called at every
                               ;           interrupt.

; ----------------------------------------------
; THE 'PRINTER CODES' TABLE

; Here the default printer control codes are stored.

default_init_prt
  defb 13,$80,$80,$80      ;0304;
  defb $80,$80,$80,$80     ;0308;
default_char_pitch
  defb 27,"M",$80,$80      ;030C;
  defb $80,$80,$80,$80     ;0310;
default_n_per_72_lspc
  defb 27,"A",$80,$80      ;0314;
  defb $80,$80,$80,$80     ;0318;
default_graph_dpi
  defb 27,"*",5,$80        ;031C;
  defb $80,$80,$80,$80     ;0320;
default_init_prt2
  defb $80,$80,$80,$80     ;0324;
  defb $80,$80,$80,$80     ;0328;

; ----------------------------------------------
; THE 'GRAPHIC REPRESENTATION' TABLE

; This table consists of the graphic representations of the £, # and (c)
; signs.  The 'GRAPH' system variable (@10) determines whether the normal code
; or the graphic representation is outputted to the printer.

; XXX TODO -- check why these data seems unused; there's an identical table at
; $203A

default_pound_sign
  defb %00011000           ;032C;
  defb %00100000           ;032D;
  defb %00100000           ;032E;
  defb %01111000           ;032F;
  defb %00100000           ;0330;
  defb %00100000           ;0331;
  defb %01111100           ;0332;
  defb %00000000           ;0333;

default_hash_sign
  defb %00000000           ;0334;
  defb %00100100           ;0335;
  defb %01111110           ;0336;
  defb %00100100           ;0337;
  defb %00100100           ;0338;
  defb %01111110           ;0339;
  defb %00100100           ;033A;
  defb %00000000           ;033B;

default_copyright_sign
  defb %01111110           ;033C;
  defb %10000001           ;033D;
  defb %10111101           ;033E;
  defb %10100001           ;033F;
  defb %10100001           ;0340;
  defb %10111101           ;0341;
  defb %10000001           ;0342;
  defb %01111110           ;0343;

; ----------------------------------------------
; THE 'GREYSCALE' PRINTER CONTROL CODE

; This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

default_grey_bitim
  defb 27,"*",5,64         ;0344;
  defb 2,$80,$80,$80       ;0348;

; ----------------------------------------------
; THE 'GREYSCALE' TABLE

; This table consists of three times three bytes of greyscale info. Each
; screen pixel is converted into 3x3 printer dots during greyscale printing.
; The printer dots are ordered as follows: The first dot row is produced from
; the first three bytes by taking the bit, which number is corresponding with
; the colour number, from each of the three bytes. E.g.  for colour 2 (=red)
; bit 2 is used. In the same way the second and third dot rows are produced
; from the second and third three bytes respectively.  The following eight 3x3
; matrices are produced:

 ; White  Yellow  Cyan  Green Magenta  Red    Blue  Black
 ;  000    000    100    000    100    010    110    111
 ;  000    010    010    101    111    111    111    111
 ;  000    000    001    000    001    010    011    111

; Note that some greytones aren't right. E.g. cyan is darker than green, which
; isn't so on the screen.

;                      colour
;                     76543210

default_greyscale
  defb %00101011           ;034C;
  defb %00011111           ;034D; first row
  defb %00000001           ;034E;

  defb %00000111           ;034F;
  defb %01101111           ;0350; second row
  defb %00000111           ;0351;

  defb %00000001           ;0352;
  defb %00011111           ;0353; third
  defb %00101011           ;0354;

default_output_p_routine:
  defw p_all               ;0355; Address of 'output' routine for "P".
default_enter_flag:
  defb $00                 ;0357; The 'ENTER' flag.
default_d_err_sp:
  defw $0000               ;0358; D_ERR_SP

; ===============================================================
; The initialise system routine

; ----------------------------------------------
; THE 'SYSTEM-FILE' NAME

; The following 11 bytes form the file description (directory description and
; filename) of a System-file.

sys_descr:
  defb 4                   ;035A;
  defm "+SYS*     "        ;035B;

; ----------------------------------------------
; THE '"AUTO*" FILE' UFIA

; The following 22 bytes form the UFIA of the autoload file, which is loaded
; right after the system file.

auto_ufia:
  defb $01                 ;0365; Drive 1
  defb $00                 ;0366;
  defb $00                 ;0367;
  defb "D"                 ;0368; Device "D"
  defb $01                 ;0369; Dir. entry for BASIC file.
  defm "AUTO*     "        ;036A; Name of autoload file.
  defb $00                 ;0374; File type is BASIC.
  defw $FFFF               ;0375; Max. length.
  defw $FFFF               ;0377;
  defw $FFFF               ;0379;

; ----------------------------------------------
; THE 'RUN' COMMAND ROUTINE

; The RUN command loads the system file.

run:
  set  7,(iy+10)           ;037B; Clear the 'jump' signal set by using
                                ; the 'RUN' command.
  ld   ix,dfca             ;037F;
  ld   a,1                 ;0383; Signal 'drive 1 is being used'.
  ld   (ix+11),a           ;0385;
  ld   a,1                 ;0388; Set drive 1.
  ld   (control_port_status),a ;038A; Store it in the control port state.
  out  (239),a             ;038D; Activate.
  call rest                ;038F; Move drive head to track 0.
  ld   hl,sys_descr        ;0392; Copy the file description to UFIA1.
  ld   de,ufia1.nstr1      ;0395;
  ld   bc,11               ;0398;
  ldir                     ;039B;
  ld   a,%00001000         ;039D; Signal 'matching name and directory
                                ; description have to be found'.
  call scan_cat            ;039F; Search for the file.
  jp   nz,rep_7            ;03A2; Give 'No "SYSTEM" file' error when file
                                ; not found.
  rst  calbas              ;03A5; Clear the whole screen.
  defw rom_cl_all          ;03A6;
  call mesg_0              ;03A8; Print the 'SYSTEM LOADING' message.
  call load_1st            ;03AB; Copy the file description (directory
                                ; description and filename) to UFIA2 and
                                ; load the first sector of the file into
                                ; the disk buffer.
  ld   hl,$3BD6            ;03AE; Copy the file header (the 9 bytes
  ld   de,ufia2.hd00       ;03B1; consisting of filetype, length, etc.)
  ld   bc,9                ;03B4; to UFIA2.
  ldir                     ;03B7;
  ld   (ix+13),9           ;03B9; Update the buffer pointer.
  ld   de,(ufia2.hd0b)     ;03BD; Fetch the systemfile's length.
  ld   hl,plus_d_ram       ;03C1; Loadaddress is $2000.
  call load_file           ;03C4; Load the system.
  ld   a,system_status.loaded ;03C7; Load the system.
  ld   (system_status),a   ;03C9; Signal 'System loaded'.
  xor  a                   ;03CC;
  push af                  ;03CD;
  ld   hl,$2080            ;03CE;
  ld   bc,$197F            ;03D1; Calculate checksum.
run_chksum:
  pop  af                  ;03D4;
  add  a,(hl)              ;03D5;
  push af                  ;03D6;
  inc  hl                  ;03D7;
  dec  bc                  ;03D8;
  ld   a,b                 ;03D9;
  or   c                   ;03DA;
  jr   nz,run_chksum       ;03DB;
  pop  af                  ;03DD;
  ld   (hl),a              ;03DE;
  xor  a                   ;03DF;
  ld   (flags3),a          ;03E0; Clear FLAGS3.
  ld   (d_err_sp),a        ;03E3;
  rst  calbas              ;03E6; Clear the whole display.
  defw rom_cl_all          ;03E7;
  call take_prtr           ;03E9; If necessary takeover the "P" channel.
  call jmsg3               ;03EC; Print DOS copyright message.
  call init_prtr           ;03EF; If necessary initialize printer.
  ld   ix,auto_ufia        ;03F2; Point to autoload file ufia.
  call jhxfer              ;03F6; Transfer UFIA to DFCA.
  ld   a,%00001000         ;03F9; Search for a file with specified name
  call scan_cat            ;03FB; and type.
  jp   nz,rep_20           ;03FE; "O.K. G+DOS" if no autoload file found
  call sign_4              ;0401; Signal 'loading'.
  jp   jload               ;0404; Load the file.


; ===============================================================
; Miscalleneous routines I

; ----------------------------------------------
; THE '"P" CHANNEL DATA' TABLE

; Here follow the '5' bytes that compose the +D "P" channel.

p_channel:
  defw $0008               ;0407;
  defw $0008               ;0409;
  defb "P"                 ;040B;

; ----------------------------------------------
; THE 'TAKEOVER PRINTER' SUBROUTINE

; If the printer is to be controlled by the +D system, the following
; subroutine copies the "P" channel data into the channel.

take_prtr:
  call system_z            ;040C;
  call z,jprtr             ;040F;
  ld   a,(zxpnt)           ;0412; (ZXPNT)
  bit  0,a                 ;0415;
  ret  nz                  ;0417; Return if the printer isn't to be
  and  a                   ;0418; handled by the +D.
  call nz,init_prt1        ;0419; If necessary initialize printer.
  ld   hl,(23631)          ;041C; Get address of channel data. (CHANS)
  ld   bc,15               ;041F; Offset for channel "P".
  add  hl,bc               ;0422;
  ex   de,hl               ;0423;
  ld   hl,p_channel        ;0424;
  ld   bc,5                ;0427;
  ldir                     ;042A; Copy the "P" channel data.
  ret                      ;042C;

; ----------------------------------------------
; THE 'INIT PRINTER' SUBROUTINE

; This subroutine initialises the printer, if it's to be handled by the +D and
; if it's attached, by sending the initialisation codes and the permanent
; setting codes as mentioned in the 'Setup' program.

init_prtr:
  ld   a,(zxpnt)           ;042D;
  bit  0,a                 ;0430; Exit if printer not to be handled
  ret  nz                  ;0432; by +D.
init_prt1:
  xor  a                   ;0433;
  ld   (zxpnt),a           ;0434;
  in   a,(247)             ;0437;
  bit  7,a                 ;0439;
  ret  nz                  ;043B; Exit if the printer is busy.
  ld   de,init_prt         ;043C; Send initialisation codes to printer.
  call po_esc_seq          ;043F;
  ld   de,char_pitch       ;0442; Set character pitch.
  call po_esc_seq          ;0445;
  ld   de,n_per_72_lspc    ;0448; Set line spacing to (lspce)/72 inch.
  call po_esc_seq          ;044B;
  ld   a,(lspce)           ;044E;
  call pntp                ;0451;
  ld   de,init_prt2        ;0454; Set other permanent printer settings.
  jp   po_esc_seq          ;0457;

; ----------------------------------------------
; THE 'CHECK SYSTEM CHECKSUM' ROUTINE

; This subroutine calculates the checksum of the system file in RAM. It is
; used to check if the system isn't corrupted.

system_ok:
  xor  a                   ;045A;
  push af                  ;045B; Calculate checksum.
  ld   hl,$2080            ;045C;
  ld   bc,$197F            ;045F;
sys_ok1:
  pop  af                  ;0462;
  add  a,(hl)              ;0463;
  push af                  ;0464;
  inc  hl                  ;0465;
  dec  bc                  ;0466;
  ld   a,b                 ;0467;
  or   c                   ;0468;
  jr   nz,sys_ok1          ;0469;
  pop  af                  ;046B;
  cp   (hl)                ;046C; Exit with Zero set if checksums
  ret                      ;046D; match.

; ----------------------------------------------
; THE 'END OF STATEMENT' ROUTINE

; After the syntax of the 'new' commands has been checked, a jump is made here
; to confirm that the statement is finished. An error report is given if it
; isn't finished.  A return to the calling routine is made only during
; runtime, otherwise the control returns to the 'main' ROM interpreter.

st_end:
  call get_c               ;046E; Get current character.
  cp   13                  ;0471;
  jr   z,st_end1           ;0473; Jump if the statement ends with ENTER.
  cp   ":"                 ;0475; Give an error if statement doesn't end
  jp   nz,rep_2            ;0477; with a colon.
st_end1:
  rst  syntax_z            ;047A;
  ret  nz                  ;047B; Return during runtime.

; ----------------------------------------------
; THE 'RETURN TO THE INTERPRETER' ROUTINE

; The control is returned to the BASIC interpreter for interpretation of the
; next statement.

the_end:
  ld   sp,(23613)          ;047C; Clear machine stack. (ERR_SP)
  ld   (iy+0),$FF          ;0480; Clear error code. (ERR_NR)
  ld   hl,rom_stmt_next    ;0484; Return address to 'main' ROM is
  rst  syntax_z            ;0487; 'STMT_NEXT' if syntax is being checked.
  jp   z,unpage_hl         ;0488;
  call bord_rest           ;048B; Restore border colour.
  call tst_break           ;048E; Test for BREAK.
  ld   hl,rom_stmt_r_1     ;0491; Return address during runtime is
  jp   unpage_hl           ;0494; 'STMT_R_1'.

; ----------------------------------------------
; THE 'TEST_BREAK' SUBROUTINE

; The BREAK key is checked and the appropriate error is given if it is
; pressed.

tst_break:
  ld   a,$7F               ;0497;
  in   a,(254)             ;0499;
  rra                      ;049B;
  ret  c                   ;049C; Return if SPACE wasn't pressed.
  ld   a,$FE               ;049D;
  in   a,(254)             ;049F;
  rra                      ;04A1;
  ret  c                   ;04A2; Return if CAPS wasn't pressed.
  jp   rep_3               ;04A3;

; ----------------------------------------------
; THE 'CALBAS_2' ROUTINE

; This routine calls the required 'main' ROM routine.

calbas_2:
  ld   (dfca.left),de      ;04A6; Free DE and HL.
  ld   (dfca.addr),hl      ;04AA;
  pop  hl                  ;04AD; Get return address, points to address
  ld   e,(hl)              ;04AE; of 'main' ROM routine to be called.
  inc  hl                  ;04AF; Fetch address of routine to be called.
  ld   d,(hl)              ;04B0;
  inc  hl                  ;04B1;
  push hl                  ;04B2; Restack return address.
  ld   hl,calbas_flag      ;04B3;
  ld   (hl),$47            ;04B6; Signal 'CALBAS executing'.
  ld   hl,$0066            ;04B8; Return address to +D system is
  push hl                  ;04BB; 'NMI_RAM'.
  push de                  ;04BC; Push address of routine to be called.
  ld   hl,(dfca.addr)      ;04BD; Restore HL and DE.
  ld   de,(dfca.left)      ;04C0;
  jp   unpage_1            ;04C4; Do the CALBAS.

; ----------------------------------------------
; THE 'POKE @' COMMAND ROUTINE

; The POKE @ command allows a value between 0 and 255 to be stored in the +D
; system variables. But if the value is between 256 and 65535 the POKE @
; behaves as a DPOKE.  Because the +D system vars have an offset of $2000 (or
; 8192) this value has to be subtracted if the POKE @ is to be made directly
; to the given address. So POKE @60000-8192,1000 to DPOKE 60000,1000.

poke_fetch
  call system_z            ;04C7; Maybe there is an alternative routine
  call z,jpoke             ;04CA; in the system file.
  rst  next_c              ;04CD; Get next character.
  cp   "@"                 ;04CE;
  jp   nz,rep_0            ;04D0; If it isn't "@" give error.
  rst  calbas              ;04D3; Evaluate the two following numeric
  defw rom_next_2num       ;04D4; expressions.
  call st_end              ;04D6; Confirm end of statement and exit
  rst  calbas              ;04D9; during syntax checking.
  defw rom_find_int2       ;04DA; Fetch value to be POKEd in BC.
  push bc                  ;04DC;
  rst  calbas              ;04DD;
  defw rom_find_int2       ;04DE; Fetch POKE address.
  ld   hl,system_variables ;04E0; Offset for +D system variables.
  add  hl,bc               ;04E3;
  pop  bc                  ;04E4;
  ld   (hl),c              ;04E5; POKE address,low byte.
  ld   a,b                 ;04E6;
  and  a                   ;04E7;
  jp   z,the_end           ;04E8; Exit if 8 bit value.
  inc  hl                  ;04EB; Otherwise POKE address+1,high byte
  ld   (hl),b              ;04EC; before exiting.
  jp   the_end             ;04ED;

; ----------------------------------------------
; THE 'SPECTRUM ERROR' ROUTINE

; This routine must be entered with the error code in (ERR_NR), and does the
; same as the 'main' ROM  'ERROR' restart, except when error messages are to
; be supressed.  This is indicated by a non zero value in 23728.

spec_err:
  ld   hl,(d_ch_add)       ;04F0; Fetch D_CH_ADD.
  ld   (23645),hl          ;04F3; Restore CH_ADD.
  ld   (23647),hl          ;04F6; Restore X_PTR.
spec_err1:
  ld   hl,$0058            ;04F9;
  rst  syntax_z            ;04FC; RETurn to $58, which is in ERROR_2, in
  jp   z,unpage_hl         ;04FD; the Spectrum ROM when checking syntax.
  ld   a,(23728)           ;0500;
  and  a                   ;0503; Also RETurn to $58 in 'main' ROM when
  jp   z,unpage_hl         ;0504; error messages aren't to be supressed.
  set  7,(iy+0)            ;0507; Otherwise signal 'Spectrum error'.
  ld   hl,rom_stmt_r_1     ;050B; And RETurn to STMT_R_1 in the Spectrum
  jp   unpage_hl           ;050E; ROM.

; ----------------------------------------------
; THE 'RESTORE PRINTER BUFFER' SUBROUTINE

; This subroutine restores the printer buffers 10 bytes which were destroyed
; by the 'D_ROMBANK' subroutine.

rest_pbuf:
  ld   hl,$3BE6            ;0511;
  ld   de,23296            ;0514;
  ld   bc,10               ;0517;
  ldir                     ;051A;
  ret                      ;051C;

; ----------------------------------------------
; THE 'DETERMINE 48K OR 128K ROM' ROUTINE

; This small routine is copied to 23296, it returns with the Zero flag set if
; address $0001 in the 'main' ROM contains 175, that is when the 48K ROM bank
; is paged in.

det_rom_copy: equ 23296

det_rom:
  out  (231),a             ;051D; Page +D out.
  ld   a,($0001)           ;051F;
  cp   175                 ;0522;
  jp   nmi                 ;0524; Page +D in.

; ----------------------------------------------
; THE 'SYSTEM_Z' SUBROUTINE

; This subroutine returns with the Zero flag set when the system file is
; present in RAM.

system_z:
  ld   ($3DEA),a           ;0527;
  ld   a,(system_status)   ;052A;
  cp   system_status.loaded ;052D;
  ld   a,($3DEA)           ;052F;
  ret                      ;0532;

; ----------------------------------------------
; THE 'POWER_UP2' ROUTINE

; The routine continues, with the proper register contents, in the 'main' ROM
; 'START/NEW' routine.

power_up2:
  ld   a,$02               ;0533; Red instead of black border.
  out  (254),a             ;0535;
  ld   a,$3F               ;0537; Set interrupt vector.
  ld   i,a                 ;0539;
  nop                      ;053B;
  nop                      ;053C;
  nop                      ;053D;
  nop                      ;053E;
  nop                      ;053F;
  nop                      ;0540;
  nop                      ;0541;
  nop                      ;0542;
  ld   hl,$7FFF            ;0543; The stackpointer has to point into RAM,
  ld   sp,hl               ;0546; otherwise: trouble (for the
                                ; UNPAGE_HL routine).
  im   1                   ;0547; Set interrupt mode 1.
  xor  a                   ;0549; Restore registers for 'main' ROM
  ld   de,$FFFF            ;054A; 'START/NEW'.
  ld   hl,$11CB            ;054D;
  jp   unpage_hl           ;0550; Jump to 'START/NEW' in the 'main' ROM.


; ===============================================================
; The disk routines

; ----------------------------------------------
; THE 'STORE INTERRUPT STATE' SUBROUTINE

; This subroutine stores the Interrupt Flip Flop of the Z80 and returns with
; interrupts disabled. Whenever the +D needs the interrupts to be disabled
; with disk operations the status of the IFF (DI or EI) is stored. When the
; disk operation is finished the IFF is restored to the state it was in before
; the interrupts were disabled.  NOTE: As a result of a bug in the Z80 itself
; the stored state of the IFF can be wrong if interrupts are enabled. The
; problem occurs when an interrupt is accepted (implying: interrupts enabled)
; during the execution of the 'LD A,R' or 'LD A,I' instruction. A solution to
; this problem is a second test if the IFF indicates interrupts disabled. With
; a Spectrum it is unlikely that two interrupts follow each other within a
; very short time, so a second test should cure the problem. A better method
; can be found in the 'Zilog Z80 Family Data Book'. The best method is
; replacing the Z80 with a CMOS version, the bug has been fixed in that Z80
; type.

store_iff:
  push af                  ;0553;
  ld   a,i                 ;0554; Set the P/V flag according to the state
  push af                  ;0556; of the IFF2.
  di                       ;0557;
  ex   (sp),hl             ;0558; Get the Flag register in L while saving
                                ; HL.
  ld   ($3E50),hl          ;0559; Store it. (IFF)
  pop  hl                  ;055C; Restore HL and AF.
  pop  af                  ;055D;
  ret                      ;055E; Finished.

; ----------------------------------------------
; THE 'RESTORE INTERRUPT STATE' SUBROUTINE

; This subroutine restores the interrupt state to the original state (DI or
; EI) (see NOTE above).

rest_iff:
  push af                  ;055F; Save the contents of the needed
  push hl                  ;0560; registers.
  ld   hl,($3E50)          ;0561; Fetch the previous IFF state.
  ex   (sp),hl             ;0564; Restore HL and store IFF state.
  pop  af                  ;0565; The IFF state is now contained in the
                                ; P/V flag.
  jp   po,rest_iff1        ;0566; Jump if interrupts were disabled.
  ei                       ;0569; Otherwise enable interrupts.
rest_iff1:
  pop  af                  ;056A;
  ret                      ;056B; Finished.

; ----------------------------------------------
; THE 'WRITE PRECOMPENSATION' SUBROUTINE

; This subroutine is called before a write command is send to the Floppy Disk
; Controller (FDC). Its task is to enable write precompensation on the inner
; tracks to get a more reliable working of the data transfers. On entry C
; holds the FDC command.

precomp:
  ld   c,%10100010         ;056C; Write a single sector, enable spin-up
                                ; sequence, no settling delay, disable
                                ; precompensation, normal data mark.
precomp1:
  ld   b,64                ;056E; Start write precomp. at track 64.
  call drv_cap             ;0570; Get drive capacity in A.
  and  $7F                 ;0573; Keep only the number of tracks.
  cp   80                  ;0575;
  jr   z,prec_1            ;0577; Jump if drive has 80 tracks.
  srl  b                   ;0579; Otherwise precomp. starts at track 32.
prec_1:
  ld   a,d                 ;057B; Fetch current track.
  and  b                   ;057C;
  jr   z,prec_2            ;057D; Jump if not at tracks above 63 or 31.
  res  1,c                 ;057F; Otherwise enable write precompensation
                                ; (reset bit 1 of the command).
prec_2:
  jp   ld_com_reg          ;0581; Give the command to the FDC.

; ----------------------------------------------
; THE 'WRITE SECTOR' SUBROUTINE

; This subroutine writes the contents of the data buffer to sector E on track
; D.

wsad:
  xor  a                   ;0584; Reset retry counter.
  ld   ($3DDB),a           ;0585;
wsad_1:
  call set_trksec          ;0588; Select drive, side, density and sector
                                ; and position the head above the correct
                                ; track.
  call precomp             ;058B; Enable precompensation when neccesary
                                ; and give the command to the FDC.
  call hl_buffer           ;058E; Make HL point to the data buffer.
  call wr_op               ;0591; Write the sector.
  call sector_err          ;0594; Check if there was an error, report it
                                ; if retried often enough. Otherwise exit
  jr   wsad_1              ;0597; Try again if no succes.

; ----------------------------------------------
; THE 'SEND DATA TO FDC' SUBROUTINE

; This subroutine handles the actual saving of a sector. It keeps sending a
; byte at a time to the FDC as long as it asks for one (sector length doesn't
; matter).

wr_op:
  call store_iff           ;0599; Store maskable interrupt state and
                                ; disable maskable interrupts.
  ld   bc,251              ;059C; BC holds the I/O port address of the
                                ; data register of the FDC.
  jr   wr_tst_drq          ;059F; Jump into the save loop.

wr_loop:
  outi                     ;05A1; Send a byte to the FDC (port BC) then
                                ; increment HL (and decrement B).
  nop                      ;05A3; Waste some time.
wr_tst_drq:
  in   a,(227)             ;05A4; Fetch FDC status.
  bit  1,a                 ;05A6; Test Data ReQuest bit.
  jr   nz,wr_loop          ;05A8; Jump if FDC requests a byte.
  in   a,(227)             ;05AA; Otherwise fetch FDC status again.
  bit  1,a                 ;05AC;
  jr   nz,wr_loop          ;05AE; Jump if FDC requests a byte.
  in   a,(227)             ;05B0;
  bit  1,a                 ;05B2;
  jr   nz,wr_loop          ;05B4;
  in   a,(227)             ;05B6;
  bit  1,a                 ;05B8;
  jr   nz,wr_loop          ;05BA;
  bit  0,a                 ;05BC; Test Busy bit.
  jr   nz,wr_tst_drq       ;05BE; Repeat until FDC is ready.
  call rest_iff            ;05C0; Restore the interrupt state.
  bit  6,a                 ;05C3; Test Write Protected bit.
  ret  z                   ;05C5; Return if not write protected.
  call dec_mapuse          ;05C6; Decrease (MAPUSED), the number of files
                                ; using the disk bitmap.
  jp   rep_23              ;05C9; Otherwise give 'Disc WRITE protected'
                                ; error.

; ----------------------------------------------
; THE 'READ SECTOR' SUBROUTINE

; This subroutine loads the contents of the data buffer from sector E on track
; D.

rsad:
  xor  a                   ;05CC; Clear retry counter.
  ld   ($3DDB),a           ;05CD;
rsad_1:
  call set_trksec          ;05D0; Set drive, side, density, sector and
                                ; position the head above the correct
                                ; track.
  ld   c,%10000000         ;05D3; Read a single sector, enable spin-up
                                ; sequence, no settling delay.
  call ld_com_reg          ;05D5; Give the command to the FDC.
  call hl_buffer           ;05D8; Make HL point to the data buffer.
  call rd_op               ;05DB; Read the sector.
  call sector_err          ;05DE; Check if there was an error, report it
                                ; if retried often enough. Otherwise exit
  jr   rsad_1              ;05E1; Try again if no succes.

; ----------------------------------------------
; THE 'GET DATA FROM FDC' SUBROUTINE

; This subroutine handles the actual loading of a sector. It keeps fetching a
; byte at a time from the FDC as long as it asks to get one (sector length
; doesn't matter).

rd_op:
  call store_iff           ;05E3; Store the maskable interrupt state and
                                ; disable interrupts.
  ld   bc,251              ;05E6; I/O address of the FDCs data register.
  jr   rd_tst_drq          ;05E9; Jump into the load loop.

  ; XXX FIXME -- The name of the label at $05E9 is wrong in the original HTML.

rd_loop:
  ini                      ;05EB; Get a byte from the FDC and increment
                                ; HL (and decrement B).
  nop                      ;05ED; Wait for a moment.
rd_tst_drq:
  in   a,(227)             ;05EE; Fetch FDC status.
  bit  1,a                 ;05F0; Test Data ReQuest bit.
  jr   nz,rd_loop          ;05F2; Jump if FDC has read a byte.
  in   a,(227)             ;05F4; Otherwise fetch FDC status again.
  bit  1,a                 ;05F6;
  jr   nz,rd_loop          ;05F8; Jump if FDC has read a byte.
  in   a,(227)             ;05FA;
  bit  1,a                 ;05FC;
  jr   nz,rd_loop          ;05FE;
  in   a,(227)             ;0600;
  bit  1,a                 ;0602;
  jr   nz,rd_loop          ;0604;
  bit  0,a                 ;0606; Test Busy bit.
  jr   nz,rd_tst_drq       ;0608; Repeat until FDC is ready.
  jp   rest_iff            ;060A; Restore interrupt state and exit.

; ----------------------------------------------
; THE 'CHECK SECTOR ERROR' SUBROUTINE

; This subroutine checks if the FDC reported an error, on entry A holds the
; FDC status byte. If there wasn't one HL points to the start of the data
; buffer and the RPT is reset.  If there was an positioning error the routine
; moves the head to the correct track. With other errors the head is
; repositioned above the current track, unless ten retries have been made,
; then an error is reported.

sector_err:
  and  %00011100           ;060D; Mask the non error bits.
  jr   nz,sec_err1         ;060F; Jump with an error.
  call res_rpt             ;0611; Otherwise reset the data buffer pointer
                                ; (RPT).
  pop  hl                  ;0614; Drop return address and exit with
  jp   hl_buffer           ;0615; HL pointing to the data buffer.

sec_err1:
  push af                  ;0618; Save error.
  ld   a,($3DDB)           ;0619; Increment the retry counter.
  inc  a                   ;061C;
  ld   ($3DDB),a           ;061D;
  cp   10                  ;0620; If 10 retries have been made 'SECTOR
  jp   nc,rep_4            ;0622; error' is given.
  pop  af                  ;0625;
  bit  4,a                 ;0626;
  jr   nz,sec_err2         ;0628; Jump with positioning error.
  call step_in             ;062A; Otherwise shake the the dust out of
  call step_out            ;062D; the drive.
  call step_out            ;0630;
  jp   step_in             ;0633;

; The routine now checks whether the head is above the right track. The
; current tracknumber is found by reading the ID Field of the first
; encountered sector on this track. The track number is then stored into the
; track register of the FDC. When no ID Field can be found the retry counter
; is incremented, when this reaches 16 the 'FORMAT data lost' error is given.

sec_err2:
  ld   c,%11000000         ;0636; Read Address, disable spinup, no delay.
  call ld_com_reg          ;0638; Execute the command.
  ld   hl,$3DDC            ;063B; Address where the ID Field is loaded.
  call rd_op               ;063E; Get the six byte ID Field of the first
                                ; sector encountered.
  and  %00011100           ;0641;
  jr   nz,sec_err3         ;0643; Jump if there was an error.
  ld   a,($3DDC)           ;0645; Otherwise store the current track
  out  (235),a             ;0648; number into the FDC's track register.
  ret                      ;064A;
sec_err3:
  ld   a,($3DDB)           ;064B;
  inc  a                   ;064E; Increment retry counter.
  ld   ($3DDB),a           ;064F;
  cp   16                  ;0652; Give up if tried 16 times, 'FORMAT
  jp   z,rep_5             ;0654; data lost'.
  cp   10                  ;0657;
  jr   nz,sec_err4         ;0659; After 10 times try something different.
  push de                  ;065B;
  call track_0             ;065C; Start from the beginning of the disk.
  pop  de                  ;065F;
  jr   sec_err2            ;0660;
sec_err4:
  call step_in             ;0662; Take one small step.
  jr   sec_err2            ;0665; And retry again.

; ----------------------------------------------
; THE 'SET TRACK AND SECTOR' SUBROUTINE

; This subroutine is used to select the required drive, side, density, sector
; to be handled and to position the drive head above the required track.
; NOTE: The head is moved relative to the current position (fetched from the
; FDCs track register), when the drive selected is not the same as the
; previous one the +D can get confused.

set_trksec:
  ld   a,d                 ;0667;
  or   e                   ;0668;
  jr   nz,set_trk1         ;0669; Jump if DE<>0.
  call test_2              ;066B; Test the .. flag.
  jp   z,rep_27            ;066E; Give 'END of file' error when reset.
  ld   sp,(d_err_sp)       ;0671; Otherwise clear the machine stack.
  ret                      ;0675;
set_trk1:
  call set_drvsd           ;0676; Select drive, side and density.
  ld   a,e                 ;0679; Store the required sector number into
  out  (243),a             ;067A; the FDC's sector register.
  call flash_bord          ;067C; Change the border colour when wanted.
  ; XXX FIXME -- the original HTML uses `flash_rest` above, instead of `flash_bord`
set_trk2:
  ld   a,d                 ;067F; Track to A.
  and  $7F                 ;0680; Mask highest bit which indicates side.
  ld   b,a                 ;0682;
  call fdc_ready           ;0683; Wait until FDC is ready, test BREAK.
  in   a,(235)             ;0686; Fetch contents of FDC's track register.
  cp   b                   ;0688; Compare against required track.
  ret  z                   ;0689; Exit if already on right track.
  call nc,step_out         ;068A; Step out if required track lies
                                ; outwards (more towards track 0).
  call c,step_in           ;068D; Otherwise step in.
  jr   set_trk2            ;0690; Continue until on the right track.

; ----------------------------------------------
; THE 'STEP DELAY' SUBROUTINE

; This subroutine does the waiting between the executing of two step commands.
; By altering the value of the (STPRAT) system variabele (POKE @3,n) the time
; being waited can be altered.

step_delay:
  ld   a,(stprat)          ;0692; Fetch milliseconds.
  and  a                   ;0695;
step_delay_exit:
  ret  z                   ;0696; Exit if counter reaches zero.

wait_1_ms:
  push af                  ;0697;
  ld   bc,135              ;0698; With this value the following loop
                                ; takes 3505 T states (about 1 ms) to
                                ; complete.
wait_1_ms_loop:
  dec  bc                  ;069B;
  ld   a,b                 ;069C;
  or   c                   ;069D;
  jr   nz,wait_1_ms_loop   ;069E; Repeat until counter reaches zero.
  pop  af                  ;06A0;
  dec  a                   ;06A1; Decrease counter.
  jr   step_delay_exit     ;06A2;

; ----------------------------------------------
; THE 'TRACK_0' SUBROUTINE

; This subroutine resets the head of the current drive to track 0. It has two
; entry points, the first is used by the ROM located routines, while the
; second (at $06B6) is used by the 'REST' command code (code 64 or $40). After
; the head has been resetted, a test is made whether there is a disk in the
; drive.

track_0:
  ld   a,(stprat)          ;06A4;
  rlca                     ;06A7; Double (STPRAT).
  ld   (stprat),a          ;06A8;
  call rest                ;06AB; Move head to track 0.
  ld   a,(stprat)          ;06AE;
  rrca                     ;06B1; Restore original (STPRAT) value.
  ld   (stprat),a          ;06B2;
  ret                      ;06B5;

rest:
  ld   de,$0001            ;06B6; Signal 'track 0, sector 1'.
  call set_drvsd           ;06B9; Set drive, side and density.

; The following code resets the drive head to track 0.

  ld   c,%11010000         ;06BC; Terminate all operations.
  call ld_com_r1           ;06BE; Execute the FDC command.
  ld   b,0                 ;06C1; Wait about 1 ms.
rest_1:
  djnz rest_1              ;06C3;

; The routine now checks whether there is a disk in the drive. The bug present
; in the DISCiPLE ROM is corrected, the +D doesn't wait forever for an INDEX
; pulse.

  ld   hl,0                ;06C5; The INDEX signal has to become low
                                ; and high again within about 1.4 sec.
rest_2:
  in   a,(227)             ;06C8; Fetch FDC status.
  bit  1,a                 ;06CA;
  call nz,rest_5           ;06CC; Call if INDEX signal is high.
  jr   nz,rest_2           ;06CF; Wait for it to become low.
rest_3:
  in   a,(227)             ;06D1; Fetch FDC status.
  cpl                      ;06D3; Invert the bits.
  bit  1,a                 ;06D4;
  call nz,rest_5           ;06D6; Call if INDEX signal is low.
  jr   nz,rest_3           ;06D9; Wait for it to become high again.
rest_4:
  in   a,(227)             ;06DB; Fetch the FDC status register.
  bit  2,a                 ;06DD;
  jr   nz,fdc_ready        ;06DF; Exit if head is above track 0.
  call step_out            ;06E1; Otherwise, step-out and continue
  jr   rest_4              ;06E4; the loop.

; ----------------------------------------------
; THE 'WAIT UNTIL FDC IS READY' SUBROUTINE

; This small subroutine waits until the FDC is ready. When the BREAK key is
; pressed during the waiting, an error is reported.

fdc_ready:
  in   a,(227)             ;06E6; Fetch the FDC status.
  bit  0,a                 ;06E8;
  ret  z                   ;06EA; Exit if it's indicating 'FDC ready'.
  call tst_break           ;06EB; Test for BREAK.
  jr   fdc_ready           ;06EE; Repeat until FDC is ready.

; ----------------------------------------------
; THE 'TRACK_0' ROUTINE CONTINUED


rest_5:
  dec  hl                  ;06F0; Decrease time limit.
  ld   a,h                 ;06F1;
  or   l                   ;06F2;
  ret  nz                  ;06F3; Return if limit isn't exceeded.
  jp   rep_6               ;06F4; Otherwise 'NO DISC in drive'.

; ----------------------------------------------
; THE 'LOAD FDC COMMAND REG.' SUBROUTINE

; This subroutine loads the FDC command register with the command held in the
; Z80's C register. The entry point 'LD_COM_R1' is used to give the 'terminate
; all operations' command to the FDC, it makes no sense to wait for the FDC to
; get ready if the current command is to be aborted.

ld_com_reg:
  call fdc_ready           ;06F7; Wait until FDC is ready, test BREAK.
ld_com_r1:
  ld   a,c                 ;06FA; Load the command in the FDC's command
  out  (227),a             ;06FB; register.
  ld   b,20                ;06FD; Wait for 73 µsec.
ld_com_r2:
  djnz ld_com_r2           ;06FF; Waste some time.
  ret                      ;0701; Finished.

; ----------------------------------------------
; THE 'TEST DRIVE' SUBROUTINE

; This subroutine checks if the specified drive is defined (only if its
; number isn't 1, then it is accepted right away). The entry point at $0702 is
; used when the drive is specified in UFIA1. The entry point at $0705 is used
; whenever the drive is specified in the A register. On exit (IX+11) holds the
; hardware representation of the drive to be used.

test_drive.ufia1:
  ld   a,(ufia1.dstr1)     ;0702; Fetch drive number from UFIA1.
test_drive.a:
  cp   1                   ;0705;
  jr   z,test_drive.end    ;0707; Jump if drive one is to be used.
  cp   2                   ;0709; Otherwise give 'Wrong DRIVE' error if
  jp   nz,rep_22           ;070B; drive isn't drive two.
  ld   a,(traks2)          ;070E; Fetch (TRAKS2) system variable.
  cp   0                   ;0711;
  jp   z,rep_22            ;0713; Give error if drive isn't defined.
  ld   a,2                 ;0716; Select drive two.
test_drive.end:
  ld   (ix+11),a           ;0718; Store hardware representation.
  ret                      ;071B;

; ----------------------------------------------
; THE 'SET DRIVE PARAMETERS' SUBROUTINE

; This subroutine selects the drive, side and density by setting the right
; bits in the control port (I/O address 239).

set_drvsd:
  ld   b,(ix+11)           ;071C; Fetch hardware drive representation.
  ld   a,(control_port_status) ;071F; Fetch current control port status.
  and  %00000011           ;0722; Keep only drive 1&2 select bits.
  cp   b                   ;0724; Set Zero flag if drive isn't changed.
  push af                  ;0725;
  ld   a,(control_port_status) ;0726; Fetch current control port status
  and  %01111100           ;0729; again. Mask drive and side select bits.
  ld   c,a                 ;072B; Store result temporary.
  ld   a,d                 ;072C; Fetch track.
  and  %10000000           ;072D; Only keep side select.
  or   b                   ;072F; Include drive select.
  or   c                   ;0730; Include all other bits.
  ld   (control_port_status),a ;0731; Set current control port status.
  out  (239),a             ;0734; Activate settings.
  pop  af                  ;0736; Get Zero flag.
  ret  z                   ;0737; Exit if drive hasn't changed.

; NOTE: This would have been a nice place to update the FDC's track register,
; it is very unlikely that both drives are on the same track all the time.

  ld   a,128               ;0738; Otherwise wait for 128 ms
  jp   wait_1_ms           ;073A; exiting via `wait_1_ms`

; ----------------------------------------------
; THE 'PROGRAM NUMBER' SUBROUTINE

; This subroutine calculates the program number from track and sector number
; and the contents of RPT-high (which holds 0 for odd program numbers and 1
; for even ones). It is used to get the program number printed in the extended
; CATalogue.

prog_num:
  push de                  ;073D; Track and sector to BC.
  pop  bc                  ;073E;
  xor  a                   ;073F; Clear A.
  dec  b                   ;0740;
  jp   m,prog_n2           ;0741; Jump with track 0, B now holds -1.
prog_n1:
  add  a,10                ;0744; Otherwise set A to 10*track number.
  dec  b                   ;0746;
  jp   p,prog_n1           ;0747; Repeat until B gets below zero.
prog_n2:
  ld   b,a                 ;074A;
  sla  b                   ;074B; Otherwise double number of tens.
  sla  c                   ;074D; Together with the next instruction the
  dec  c                   ;074F; effect is 'INC C'.
  ld   a,(ix+14)           ;0750; Fetch high byte of RPT.
  add  a,c                 ;0753; Add adjusted sector.
  add  a,b                 ;0754; Add adjusted track.
  ret                      ;0755; Exit with A holding the program number.

; ----------------------------------------------
; THE 'SECT_END_Z' SUBROUTINE

; This subroutine returns with the Zero flag set if RPT has reached the sector
; end, that is if RPT points to the next track and sector numbers present in
; each sector.

sect_end_z:
  call rpt_hl1             ;0756; Get RPT in HL and the disk buffer
  ld   a,c                 ;0759; position in BC.
  cp   254                 ;075A; Exit if disk buffer position 510 (or
  ret  nz                  ;075C; 254) hasn't been reached, Zero reset.
  ld   a,b                 ;075D; Position 510 has to be reached before
  cp   1                   ;075E; returning with Zero set.
  ret                      ;0760;

; ----------------------------------------------
; THE 'SAVE A BYTE TO DISK' SUBROUTINE

; This subroutine saves the byte in A in the data buffer at the location
; pointed to by RPT (the disk buffer pointer). If the buffer is full, an
; automatic sector save to disk will take place, RPT will be reset to the
; start of the buffer and the value will then be saved.

sbyt:
  push bc                  ;0761;
  push de                  ;0762;
  push hl                  ;0763;
  push af                  ;0764;
  call sect_end_z          ;0765; Check if the data buffer is full.
  jr   nz,sbyt_1           ;0768; Jump if data buffer not full.
  call mk_alloc            ;076A; Allocate the first free sector.
  ld   (hl),d              ;076D; Store its track and sector number into
  inc  hl                  ;076E; the last two bytes of the data buffer.
  ld   (hl),e              ;076F;
  ex   de,hl               ;0770;
  call get_sector          ;0771; Fetch track and sector number of the
                                ; current sector into DE, store the next
                                ; track and sector number.
  call wsad                ;0774; Write the sector to disk.
sbyt_1:
  pop  af                  ;0777;
  ld   (hl),a              ;0778; Store value.
  pop  hl                  ;0779;
  pop  de                  ;077A;
  pop  bc                  ;077B;
  jp   inc_rpt             ;077C; Exit while increasing RPT.

; ----------------------------------------------
; THE 'LOAD A BYTE FROM DISK' SUBROUTINE

; This subroutine loads the byte pointed to by RPT from the data buffer, and
; returns with it in A and RPT updated. If the buffer is empty, another sector
; is read from the disk.

lbyt:
  push bc                  ;077F;
  push de                  ;0780;
  push hl                  ;0781;
  call sect_end_z          ;0782; Check if the data buffer is empty.
  jr   nz,lbyt_1           ;0785; Jump if data buffer not empty.
  ld   d,(hl)              ;0787; Otherwise fetch track and sector number
  inc  hl                  ;0788; of next sector into DE.
  ld   e,(hl)              ;0789;
  call rsad                ;078A; Load the next sector.
lbyt_1:
  ld   a,(hl)              ;078D; Get a byte.
  pop  hl                  ;078E;
  pop  de                  ;078F;
  pop  bc                  ;0790;
  jp   inc_rpt             ;0791; Exit while increasing RPT.

; ----------------------------------------------
; THE 'LOAD FILE' ROUTINE

; This very important routine handles the loading of any file from disk. The
; entry point is at address $079E. On entry HL holds the load address, while
; DE holds the number of bytes to be loaded. The routine first empties the
; data buffer, which was loaded with the first sector to obtain the 9 byte
; file header. When the data buffer is empty the routine loads all sectors,
; but the last, into the memory directly. The last sector is loaded into the
; data buffer again and then the remaining bytes are loaded from it.

ld_buf:
  ld   a,(hl)              ;0794; Fetch a byte from the data buffer.
  call inc_rpt             ;0795; Increment RPT.
  ld   hl,(dfca.addr)      ;0798; Fetch load address.
  ld   (hl),a              ;079B; Load the byte into memory.
  inc  hl                  ;079C;
  dec  de                  ;079D;
load_file:
  ld   (dfca.addr),hl      ;079E; Store load address into (FILEADDR).
  ld   a,d                 ;07A1;
  or   e                   ;07A2;
  ret  z                   ;07A3; Exit if no more bytes left.
ld_buf1:
  call sect_end_z          ;07A4; The data buffer has to be empty before
  jr   nz,ld_buf           ;07A7; sectors can be loaded directly into
                                ; memory. Jump if data buffer not empty.
  ld   (dfca.left),de      ;07A9; Store the number of bytes left to load
                                ; into (BYTESLEFT).
  ld   d,(hl)              ;07AD; Fetch next track and sector.
  inc  hl                  ;07AE;
  ld   e,(hl)              ;07AF;
  call sto_buflen          ;07B0; Store the data buffer length.
ld_op:
  call last_sec_c          ;07B3; Check if this sector is the last one.
  jp   c,ld_last           ;07B6; Jump if last sector.
  inc  hl                  ;07B9; Balance the Carry flag subtracted in
                                ; 'LAST_SEC_C'.
  ld   (dfca.left),hl      ;07BA; Store number of bytes left after this
                                ; sector has been loaded.
  xor  a                   ;07BD; Clear retry counter.
  ld   ($3DDB),a           ;07BE;
  call store_sec           ;07C1; Store track and sector.
ld_again:
  call set_trksec          ;07C4; Set drive, side, density, sector and
                                ; track.
  ld   c,%10000000         ;07C7; Read a single sector, enable spin-up,
                                ; no settling delay.
  call ld_com_reg          ;07C9; Execute the FDC command.
  call store_iff           ;07CC; Store interrupt state and disable.
  exx                      ;07CF; HL' has to be rescued because the
  push hl                  ;07D0; 'main' ROM needs it.
  ld   bc,251              ;07D1; I/O address of FDC's data register.
  ld   de,2                ;07D4; DE' holds the length of the next sector
                                ; address in each sector.
  call hl_buffer           ;07D7; HL' points to the data buffer.
  exx                      ;07DA;
  ld   bc,251              ;07DB; I/O address of FDC's data register.
  ld   de,(dfca.buflen)    ;07DE; DE holds length of data buffer. DE +
                                ; DE' hold the length of a sector.
  ld   hl,(dfca.addr)      ;07E2; HL holds the load address.
  jr   ld_tst_drq          ;07E5; Jump into the load loop.

ld_loop:
  ini                      ;07E7; Get a byte from the FDC, increment HL.
  dec  de                  ;07E9; Decrement byte counter.
  ld   a,d                 ;07EA;
  or   e                   ;07EB;
  jr   nz,ld_tst_drq       ;07EC; Jump if not zero.
  exx                      ;07EE; Otherwise select the other HL and DE.
ld_tst_drq:
  in   a,(227)             ;07EF; Fetch FDC status.
  bit  1,a                 ;07F1; Test Data ReQuest bit.
  jr   nz,ld_loop          ;07F3; Jump if FDC has read a byte.
  in   a,(227)             ;07F5; Otherwise fetch FDC status again.
  bit  1,a                 ;07F7;
  jr   nz,ld_loop          ;07F9; Jump if FDC has read a byte.
  in   a,(227)             ;07FB;
  bit  1,a                 ;07FD;
  jr   nz,ld_loop          ;07FF;
  in   a,(227)             ;0801;
  bit  1,a                 ;0803;
  jr   nz,ld_loop          ;0805;
  bit  0,a                 ;0807; Test Busy bit.
  jr   nz,ld_tst_drq       ;0809; Repeat until FDC is ready.
  exx                      ;080B; When the FDC is ready, DE and DE' both
  pop  hl                  ;080C; are 0, and the 'EXX' at $07EE has been
  exx                      ;080D; executed twice, so to restore HL'
                                ; a 'EXX' has to be executed first.
  call rest_iff            ;080E; Restore interrupt state.
  and  %00011100           ;0811; Mask non error bits of FDC status.
  jr   z,ld_ok             ;0813; Jump with no errors.
  call fetch_sec           ;0815; Otherwise fetch track and sector again.
  call sec_err1            ;0818; Check if there was a sector error.
  jr   ld_again            ;081B; Try to load the sector again.

; If there are no errors the next sector can be loaded.

ld_ok:
  ld   (dfca.addr),hl      ;081D; Store the load address into (FILEADDR).
  call hl_buffer           ;0820; Make HL point to the data buffer.
  ld   d,(hl)              ;0823; Fetch the next track and sector number.
  inc  hl                  ;0824;
  ld   e,(hl)              ;0825;
  jp   ld_op               ;0826; Load the next sector.

; The last sector is loaded into the data buffer.

ld_last:
  call rsad                ;0829; Load the last sector.
  ld   de,(dfca.left)      ;082C; Fetch number of bytes left (BYTESLEFT)
  jp   ld_buf1             ;0830; and copy them to 'main' RAM.

; ----------------------------------------------
; THE 'STORE BUFFER LENGTH' SUBROUTINE

; This subroutine stores the length of the data buffer into ($1ACA). Because
; the +D only uses double density this is always 510.

sto_buflen:
  ld   bc,510              ;0833; Length of DD data buffer.
  ld   (dfca.buflen),bc    ;0836; Store the length into (BUFLEN).
  ret                      ;083A;

; ----------------------------------------------
; THE 'LAST_SEC_C' SUBROUTINE

; This subroutine returns with the Carry flag set if the last sector is to be
; loaded.

last_sec_c:
  ld   hl,(dfca.left)      ;083B; Fetch the number of bytes left to be
                                ; loaded from (BYTESLEFT).
  ld   bc,(dfca.buflen)    ;083E; Fetch the data buffer length from
                                ; (BUFLEN).
  scf                      ;0842; Set the Carry flag, now the Carry flag
                                ; will be set after the 'SBC' if HL=BC.
  sbc  hl,bc               ;0843; Exit with Carry set signalling 'last
  ret                      ;0845; sector to be loaded'.

; ----------------------------------------------
; THE 'SAVE FILE' ROUTINE

; This is the opposite of the 'LOAD_FILE' routine above. The entry address is
; $0850, on entry HL holds the save address and DE holds the number of bytes
; to be saved.  The routine first fills up the data buffer, which contains the
; 9 byte file header already.  The data buffer is saved to disk, after which a
; sector address table is build for all but the last sector. All sectors, the
; addresses of which are contained in the table, are saved directly from
; memory. The last sector is saved into the data buffer again after which the
; file should be closed.

sa_buf:
  ld   (hl),d              ;0846; Save the byte in the data buffer.
  call inc_rpt             ;0847; Increment RPT.
  ld   hl,(dfca.addr)      ;084A; Fetch save address from (FILEADDR).
  inc  hl                  ;084D;
  pop  de                  ;084E;
  dec  de                  ;084F;
hsvbk_2:
  ld   a,d                 ;0850;
  or   e                   ;0851;
  ret  z                   ;0852; Exit if no more bytes to save.
  push de                  ;0853;
  ld   d,(hl)              ;0854; Fetch a byte from memory.
  ld   (dfca.addr),hl      ;0855; Store save address into (FILEADDR).
  call sect_end_z          ;0858; The data buffer has to be full before
  jr   nz,sa_buf           ;085B; the sector can be saved. Jump if data
                                ; buffer isn't full.
  pop  de                  ;085D; Fetch number of bytes left to save and
  ld   (dfca.left),de      ;085E; store it into (BYTESLEFT).
  call mk_alloc            ;0862; Allocate the first free sector.
  ld   (hl),d              ;0865; Store track and sector number into the
  inc  hl                  ;0866; data buffer.
  ld   (hl),e              ;0867;
  ex   de,hl               ;0868;
  call get_sector          ;0869; Fetch track and sector number of the
                                ; current sector in DE, store the next
                                ; track and sector number.
  call wsad                ;086C; Write the sector to disk.
  xor  a                   ;086F; Clear sector counter.
  ld   ($3DEA),a           ;0870;
  call sto_buflen          ;0873; Store the data buffer length.
  call last_sec_c          ;0876; Check if this is the last sector.
  jp   c,sa_last           ;0879; Jump if it is.
  call hl_buffer           ;087C; HL points to the data buffer.
sa_alloc:
  push hl                  ;087F; Store data buffer address.
  call last_sec_c          ;0880; Check if this is the last sector.
  push hl                  ;0883; DE now holds the number of bytes left
  pop  de                  ;0884; -1.
  pop  hl                  ;0885; Restore data buffer pointer.
  jr   c,sa_op             ;0886; Jump if all but last sector allocated.
  inc  de                  ;0888; Balance the Carry subtracted in
  ld   (dfca.left),de      ;0889; 'LAST_SEC_C' before storing the number
                                ; of bytes left into (BYTESLEFT).
  call mk_alloc            ;088D; Allocate a sector.
  ld   (hl),d              ;0890; Store its track and sector number into
  inc  hl                  ;0891; the data buffer.
  ld   (hl),e              ;0892;
  inc  hl                  ;0893;
  ld   a,($3DEA)           ;0894; Increase sector counter.
  inc  a                   ;0897;
  ld   ($3DEA),a           ;0898;
  jr   nz,sa_alloc         ;089B; Repeat until all sectors have been
                                ; allocated or the sector counter
                                ; overflows.
sa_op:
  xor  a                   ;089D; Reset retry counter.
  ld   ($3DDB),a           ;089E;
  call fetch_sec           ;08A1; Fetch the sector to be saved.
sa_again:
  call set_trksec          ;08A4; Set drive, side, etc.
  call precomp             ;08A7; Enable precompensation when neccesary
                                ; and execute the write sector command.
  call store_iff           ;08AA; Store interrupt state and disable.
  exx                      ;08AD; HL' has to be stored because the
  push hl                  ;08AE; 'main' ROM needs it.
  call rpt_hl1             ;08AF; HL' points to the sector address
                                ; table, build up in the data buffer.
  ld   de,2                ;08B2; DE' holds the length of the next
                                ; sector address in each sector.
  ld   bc,251              ;08B5; BC' holds the I/O address of the FDC's
                                ; data register.
  exx                      ;08B8;
  ld   hl,(dfca.addr)      ;08B9; HL holds the save address.
  ld   de,(dfca.buflen)    ;08BC; DE holds the length of the data space
                                ; inside a sector. DE+DE' hold the
                                ; length of a complete sector.
  ld   bc,251              ;08C0; BC holds the same as BC'.
  jr   sa_tst_drq          ;08C3; Jump into the save loop.

sa_loop:
  outi                     ;08C5; Send a byte to the FDC, increment HL.
  dec  de                  ;08C7; Decrement byte counter.
  ld   a,d                 ;08C8;
  or   e                   ;08C9;
  jr   nz,sa_tst_drq       ;08CA; Jump if not zero.
  exx                      ;08CC; Otherwise select the other HL and DE.
sa_tst_drq:
  in   a,(227)             ;08CD; Fetch FDC status.
  bit  1,a                 ;08CF; Test Data ReQuest bit.
  jr   nz,sa_loop          ;08D1; Jump if FDC requests a byte.
  in   a,(227)             ;08D3; Otherwise fetch FDC status again.
  bit  1,a                 ;08D5;
  jr   nz,sa_loop          ;08D7; Jump if FDC requests a byte.
  in   a,(227)             ;08D9;
  bit  1,a                 ;08DB;
  jr   nz,sa_loop          ;08DD;
  in   a,(227)             ;08DF;
  bit  1,a                 ;08E1;
  jr   nz,sa_loop          ;08E3;
  bit  0,a                 ;08E5; Test Busy bit.
  jr   nz,sa_tst_drq       ;08E7; Repeat until FDC is ready.
  call rest_iff            ;08E9; Restore interrupt state.
  and  %00011100           ;08EC; Mask non error bits of FDC status.
  jr   z,sa_ok             ;08EE; Jump with no errors.
  exx                      ;08F0;
  pop  hl                  ;08F1; Restore HL'.
  exx                      ;08F2;
  call fetch_sec           ;08F3; Fetch track and sector again.
  call sec_err1            ;08F6; Check if there was a sector error.
  jr   sa_again            ;08F9; Try to save the sector again.

; If there are no errors the next sector can be saved, but first its track and
; sector number have to be retrieved.

sa_ok:
  ld   (dfca.addr),hl      ;08FB; Store the save address into (FILEADDR)
  exx                      ;08FE;
  dec  hl                  ;08FF; Fetch track and sector number of next
  ld   e,(hl)              ;0900; sector.
  dec  hl                  ;0901;
  ld   d,(hl)              ;0902;
  call inc_rpt             ;0903; Update RPT.
  call inc_rpt             ;0906;
  call store_sec           ;0909; Store the next sector's track and
                                ; sector number.
  pop  hl                  ;090C; Restore HL'.
  exx                      ;090D;
  ld   a,($3DEA)           ;090E; Decrease sector counter.
  dec  a                   ;0911;
  ld   ($3DEA),a           ;0912; Save the next sector as long as it
  jp   nz,sa_op            ;0915; isn't the last one.
sa_last:
  call res_rpt             ;0918; The bytes of the last sector are saved
  ld   de,(dfca.left)      ;091B; into the data buffer again. Fetch the
  ld   hl,(dfca.addr)      ;091F; number of bytes left and the save
  jp   hsvbk_2             ;0922; address. Then save the bytes into the
                                ; data buffer.

; ----------------------------------------------
; THE 'ALLOCATE SECTOR' SUBROUTINE

; This subroutine allocates the first free sector, which track and sector
; number are returned in the DE register pair. The routine searches the disk
; bitmap at $1A00 for a free sector, if there isn't one an error is reported.

mk_alloc:
  push hl                  ;0925;
  push bc                  ;0926;
  ld   hl,disk_bitmap      ;0927; Address where disk bitmap is located.
  ld   de,$0401            ;092A; Start with track 4, sector 1.
  ld   c,0                 ;092D; Clear bitmap offset.
mk_all1:
  ld   a,(hl)              ;092F;
  cp   $FF                 ;0930;
  jr   nz,mk_all3          ;0932; Jump if there is a free sector here.
  ld   a,e                 ;0934; Otherwise update sector number.
  add  a,8                 ;0935; Each byte holds 8 sectors.
  ld   e,a                 ;0937;
  sub  10                  ;0938; But each track holds 10.
  jr   c,mk_all2           ;093A; Jump if still on the same track, i.e.
  jr   z,mk_all2           ;093C; with sectors <=9 and 10.
  ld   e,a                 ;093E; Otherwise the next sector has been
  call next_track          ;093F; computed, next track is computed now.
mk_all2:
  inc  c                   ;0942; Increase bitmap offset.
  inc  hl                  ;0943; Next byte of bitmap.
  jr   mk_all1             ;0944; Find a free sector.

; Now the routine continues to find which sector is free.

mk_all3:
  ld   b,1                 ;0946; Reset bit pointer.
mk_all4:
  ld   a,(hl)              ;0948;
  and  b                   ;0949;
  jr   z,mk_all5           ;094A; Jump if free sector has been found.
  ; XXX FIXME -- the original HTML uses `mk_alloc5` above, instead of `mk_all5`
  call next_sec            ;094C; Increase sector number.
  call z,next_track        ;094F; Next track if sector is on it.
  rlc  b                   ;0952; Test next sector.
  jr   mk_all4             ;0954;

; ----------------------------------------------
; THE 'NEXT TRACK' SUBROUTINE

; This subroutine checks whether the next track (current track held in D)
; still exists and returns holding the next track in D when it does exist. If
; the drive capacity is exceeded, the 'Not enough SPACE on disc' error is
; given.

next_track:
  inc  d                   ;0956; Increase track.
  call drv_cap             ;0957; Get number of tracks on current drive
                                ; in the A register.
  cp   d                   ;095A; Decrement 'number of files using the
  call z,dec_mapuse        ;095B; disk bitmap' and give an error if
  jp   z,rep_24            ;095E; drive capacity is exceeded.
  and  $7F                 ;0961; Mask off side bit.
  cp   d                   ;0963;
  ret  nz                  ;0964; Return if side 0 isn't full.
  ld   d,128               ;0965; Otherwise return with track 0, side 1.
  ret                      ;0967;

; ----------------------------------------------
; THE 'ALLOCATE SECTOR' ROUTINE CONTINUED

; Now the 'ALLOCATE SECTOR' routine continues by unfreeing the found sector.

mk_all5:
  ld   a,(hl)              ;0968; Make found sector unfree in disk
  or   b                   ;0969; bitmap.
  ld   (hl),a              ;096A;
  ld   a,b                 ;096B;
  ld   b,0                 ;096C;
  push ix                  ;096E;
  add  ix,bc               ;0970; Add bitmap offset.
  or   (ix+34)             ;0972; Set new sector in file bitmap.
  ld   (ix+34),a           ;0975;
  pop  ix                  ;0978; Restore disk channel pointer.
  inc  (ix+31)             ;097A; Increment number of sectors used.
  jr   nz,mk_all6          ;097D;
  inc  (ix+30)             ;097F;
mk_all6:
  pop  bc                  ;0982;
  pop  hl                  ;0983;
  ret                      ;0984; Finished.

; ----------------------------------------------
; THE 'GET DRIVE CAPACITY' SUBROUTINE

; This small subroutine returns with the A register holding the capacity of
; the selected drive, as found in the system variables.

drv_cap:
  push hl                  ;0985;
  ld   hl,traks1           ;0986; This is TRAKS1, drive 1's capacity.
  ld   a,(control_port_status) ;0989; Fetch current control port state.
  bit  0,a                 ;098C;
  jr   nz,drv_cap1         ;098E; Jump if drive 1 selected.
  inc  hl                  ;0990; Otherwise point to TRAKS2.
drv_cap1:
  ld   a,(hl)              ;0991; Fetch drive capacity.
  pop  hl                  ;0992;
  ret                      ;0993; Finished.

; ----------------------------------------------
; THE 'PRINT NAME' SUBROUTINE

; This subroutine is used to print the name of a file during a 'CAT' command
; and when the 'overwrite' message is printed.

prt_name:
  ld   (ix+13),1           ;0994; Point to the first character of the
                                ; name.
  call rpt_hl1             ;0998; Make HL point to it.
  ld   b,10                ;099B; A name has 10 characters.
prt_nam1:
  ld   a,(hl)              ;099D; Fetch a character.
  call prt_a               ;099E; Print it.
  inc  hl                  ;09A1;
  djnz prt_nam1            ;09A2; Repeat for all 10 characters.
  ret                      ;09A4;

; ----------------------------------------------
; THE 'SCAN CATALOGUE' SUBROUTINE

; This very important subroutine scans the CATalogue of a disk, whether this
; is for a free entry, a matching filename, or for printing the directory. On
; entry all needed parameters other than the A register should be contained in
; UFIA1. The A register determines where to scan for as follows:
;
; (bits set)
;
; - bit 0 : Search for the file with the specified program number.
;
; - bit 1 : Print a 'names only' CATalogue to the current stream. A filename
; must be specified.
;
; - bit 2 : Print an 'extended' CATalogue to the current stream. A filename
; has to be specified.
;
; - bit 3 : Search for a file with the specified type and name.
;
; - bit 4 : Search for a file with the specified filename.
;
; - bit 5 : Produce the disk bitmap.
;
; - bit 6 : Find the first unused entry.
;
; Note that some functions exclude others.
;
; A return is made with DE holding the track and sector number of the found
; entry, the data buffer holding the sector, RPT pointing to the entry and the
; Zero flag signalling 'success' when set.

scan_cat:
  ld   ix,dfca             ;09A5;
  ld   (ix+4),a            ;09A9; Store scan-type.
  xor  a                   ;09AC; Clear column counter.
  ld   ($3DEB),a           ;09AD;
  call rest                ;09B0; Reset drive head to track 0, DE = 1.
each_entry:
  call rsad                ;09B3; Load a CATalogue sector.
each_e1:
  call rpt_hl              ;09B6; HL points to the start of data buffer.
  ld   a,(hl)              ;09B9; Fetch file type.
  and  a                   ;09BA; Jump if it's an unused entry (could be
  jp   z,scan_free         ;09BB; ERASEd).
  bit  0,(ix+4)            ;09BE;
  jr   z,no_prgnum         ;09C2; Jump if not searching for a filenumber
  call prog_num            ;09C4; Otherwise load program number into A.
  ld   b,a                 ;09C7;
  ld   a,(ufia1.fstr1)     ;09C8; Fetch specified program number.
  cp   b                   ;09CB;
  ret  z                   ;09CC; Exit if they are equal.
  jp   scan_next           ;09CD; Otherwise continue scanning.

; NOTE: All entries with numbers below the specified one are considered, this
; isn't really needed.

no_prgnum:
  bit  1,(ix+4)            ;09D0; Jump if a short CATalogue should be
  jr   nz,print_cat        ;09D4; printed.
  bit  2,(ix+4)            ;09D6;
  jr   z,no_cat            ;09DA; Jump if no CATalogue is desired.
print_cat:
  ld   (ix+13),11          ;09DC; RPT points to number of sectors used.
  call rpt_hl1             ;09E0; Make HL hold RPT.
  ld   b,(hl)              ;09E3; Fetch number of sectors used.
  inc  hl                  ;09E4;
  ld   c,(hl)              ;09E5;
  ld   (dfca),bc           ;09E6; Store it for printing.
  ld   hl,($3DD8)          ;09EA; Add it to total number of sectors used
  add  hl,bc               ;09ED;
  ld   ($3DD8),hl          ;09EE;
  bit  7,a                 ;09F1;
  jp   nz,scan_next        ;09F3; Jump if this entry is hidden.
  call match_name          ;09F6;
  jp   nz,scan_next        ;09F9; Jump if filename doesn't match.
  bit  1,(ix+4)            ;09FC;
  jr   nz,scan_1           ;0A00; Jump with short CAT.
  call prog_num            ;0A02; Calculate program number.
  push de                  ;0A05;
  ld   h,0                 ;0A06; Program number to HL.
  ld   l,a                 ;0A08;
  ld   a,32                ;0A09; Use leading spaces.
  call prt_n10             ;0A0B; Print the program number.
  pop  de                  ;0A0E; Restore sector address.
  call prt_space           ;0A0F; Print a space.
scan_1:
  call prt_name            ;0A12; Print filename.
  bit  1,(ix+4)            ;0A15;
  jr   z,ext_cat_0A3F      ;0A19; Jump with extended CAT.
  ld   b,3                 ;0A1B; Otherwise print three columns wide.
  ld   a,(ufia1.sstr1)     ;0A1D; Except when using stream 3.
  cp   3                   ;0A20;
  jr   nz,scan_2           ;0A22;
  sla  b                   ;0A24; Then print six columns wide.
scan_2:
  ld   a,($3DEB)           ;0A26; Increment column counter.
  inc  a                   ;0A29;
  cp   b                   ;0A2A;
  jr   z,scan_3            ;0A2B; Jump if last column reached.
  ld   ($3DEB),a           ;0A2D; Otherwise store column counter and
  ld   a,32                ;0A30; separate the columns with a SPACE.
  jr   scan_4              ;0A32;

; This line is full, the next entry will be printed on the next line.

scan_3:
  xor  a                   ;0A34; Clear column counter.
  ld   ($3DEB),a           ;0A35;
  ld   a,13                ;0A38; Print a NEWLINE.
scan_4:
  call prt_a               ;0A3A;
  jr   scan_next           ;0A3D; Continue with the next entry.

; With an extended CAT there has to be printed somewhat more.

ext_cat_0A3F:
  ; XXX FIXME -- the original HTML defines `ext_cat` twice
  push de                  ;0A3F; Store track and sector number.
  ld   hl,(dfca)           ;0A40; Fetch length of file in sectors.
  ld   a,32                ;0A43; Print it with leading spaces.
  call prt_n100            ;0A45;
  call prt_space           ;0A48; Print a trailing space.
  call rpt_hl              ;0A4B; HL points to the start of the entry.
  ld   a,(hl)              ;0A4E; Fetch file type
  call prt_type            ;0A4F; and print it.
  pop  de                  ;0A52; Restore track and sector number.
  jr   scan_next           ;0A53; Continue with the next entry.

; Now the routine continues with the search part.

no_cat:
  bit  3,(ix+4)            ;0A55;
  jr   nz,scan_name        ;0A59; Jump if searching for name and type.
  bit  4,(ix+4)            ;0A5B;
  jr   z,scan_5            ;0A5F; Jump if not searching for name alone.
scan_name:
  call match_name          ;0A61; Return with Zero flag set to signal
  ret  z                   ;0A64; 'matching name (and type) found'.
scan_5:
  bit  5,(ix+4)            ;0A65;
  jr   z,scan_next         ;0A69; Jump if no disk map wanted.

; This part of the routine builds up the bitmap.

  push ix                  ;0A6B;
  ld   (ix+13),15          ;0A6D; RPT points to the start of file bitmap
  call rpt_hl1             ;0A71; Make HL hold RPT.
  ld   ix,disk_bitmap      ;0A74;
  ld   b,disk_bitmap_size  ;0A78;
scan_map:
  ld   a,(ix+0)            ;0A7A; Fetch a disk map byte.
  or   (hl)                ;0A7D; Incorporate the corresponding file map
  ld   (ix+0),a            ;0A7E; byte.
  inc  ix                  ;0A81; Point to the next map bytes.
  inc  hl                  ;0A83;
  djnz scan_map            ;0A84; Repeat for all map bytes.
  pop  ix                  ;0A86; Restore disk channel pointer.

; Another entry has been handled, go on with the next.

scan_next:
  ld   a,(ix+14)           ;0A88; Fetch RPT-hi.
  cp   1                   ;0A8B; Jump if the second entry has been
  jr   z,scan_6            ;0A8D; handled.
  call res_rpt             ;0A8F; Reset RPT.
  inc  (ix+14)             ;0A92; Point to the second entry.
  jp   each_e1             ;0A95; Repeat for this entry.

; The next CAT sector has to be retrieved (if there is one).

scan_6:
  call next_sec            ;0A98; Calculate next sector.
  jp   nz,each_entry       ;0A9B; Jump if on same track.
  inc  d                   ;0A9E; Otherwise next track.
  ld   a,d                 ;0A9F;
  cp   4                   ;0AA0;
  jp   nz,each_entry       ;0AA2; Jump if still a CATalogue track.
  and  a                   ;0AA5; Otherwise signal 'unsuccessfull' and
  ret                      ;0AA6; exit.

; An unused entry was found, so if we are searching for one then exit else
; continue.

scan_free:
  ld   a,(ix+4)            ;0AA7; Fetch scan-type.
  cpl                      ;0AAA; Invert all bits.
  bit  6,a                 ;0AAB;
  ret  z                   ;0AAD; Return if searching for a free entry.
  jr   scan_next           ;0AAE; Otherwise continue with next entry.

; ----------------------------------------------
; THE 'MATCH NAME' SUBROUTINE

; This subroutine checks whether the filename and, when needed, directory
; description of the current entry matches the specification. If they don't
; match the Zero flag is returned reset.

match_name:
  push ix                  ;0AB0; Store disk channel pointer.
  call rpt_hl              ;0AB2; HL points to the start of the entry.
  ld   b,11                ;0AB5; Length of file description.
  bit  3,(ix+4)            ;0AB7;
  ld   ix,ufia1.nstr1      ;0ABB; IX points to the file description in
                                ; UFIA1.
  jr   z,match_n2          ;0ABF; Jump if directory description doesn't
                                ; need to match.
match_n1:
  ld   a,(ix+0)            ;0AC1; Fetch character of search string.
  cp   "*"                 ;0AC4; Jump if it's a '*', then all other
  jr   z,match_n3          ;0AC6; characters don't matter.
  cp   "?"                 ;0AC8; Jump if it's a '?', then this
  jr   z,match_n2          ;0ACA; character doesn't matter.
  xor  (hl)                ;0ACC; Compare with entries character.
  and  $DF                 ;0ACD; Capitalize.
  jr   nz,match_n3         ;0ACF; Jump if they don't match.
match_n2:
  inc  ix                  ;0AD1; Next character.
  inc  hl                  ;0AD3;
  djnz match_n1            ;0AD4; Repeat for all characters.
match_n3:
  pop  ix                  ;0AD6; Restore disk channel pointer.
  ret                      ;0AD8; Return with Zero set signalling
                                ; 'match'.

; ----------------------------------------------
; THE 'OPEN A FILE FOR SAVE' SUBROUTINE

; This subroutine opens a file, with the specified filename, for saving. If
; the filename wasn't used the file is opened, a return is made with the Zero
; flag set to signal 'successfull'. If the filename was used, the 'OVERWRITE'
; message is printed, when the 'Y' key is pressed the existing file is ERASEd
; and the opening is retried.  Otherwise the routine returns with the Zero
; flag reset to signal 'unsuccessfull'.

ofsm_2:
  push ix                  ;0AD9; Store disk channel pointer.
  ld   a,(mapused)         ;0ADB; This is (MAPUSED), the (in)famous
                                ; @7663. It holds the number of files
                                ; which are using the disk bitmap.
  cp   0                   ;0ADE;
  ld   a,%00010000         ;0AE0; Scan catalogue for specified filename.
  jr   nz,ofsm_scan        ;0AE2; Jump if (@7663)<>0, the disk bitmap
                                ; isn't to be rebuild.
  ld   hl,disk_bitmap      ;0AE4; Otherwise clear the disk bitmap.
  ld   b,disk_bitmap_size  ;0AE7;
ofsm_clr_1:
  ld   (hl),0              ;0AE9;
  inc  hl                  ;0AEB;
  djnz ofsm_clr_1          ;0AEC;
  ld   a,%00110000         ;0AEE; Scan catalogue for specified filename
                                ; and produce a disk bitmap.
ofsm_scan:
  call scan_cat            ;0AF0;
  jr   nz,ofsm_free        ;0AF3; Jump if filename not used.
  push de                  ;0AF5; Otherwise store sector address.
  rst  calbas              ;0AF6; Clear the lower part of the screen by
  defw rom_cls_lower       ;0AF7; calling 'CLS_LOWER' in 'main' ROM.
  set  5,(iy+2)            ;0AF9; Signal 'lower screen has to be
                                ; cleared'. (TV_FLAG)
  call mesg_1              ;0AFD; Print 'OVERWRITE' message.
  call prt_name            ;0B00; Print filename.
  call mesg_3              ;0B03; Print 'Y/N' message.
  call test_y              ;0B06; Test the 'Y' key.
  jr   z,ofsm_erase        ;0B09; Jump if 'Y' was pressed.
  pop  de                  ;0B0B; When any other key was pressed the
  pop  ix                  ;0B0C; routine returns with Zero reset to
  ret                      ;0B0E; signal 'unsuccessfull'.

; The filename existed already, the user wants it to be overwritten, so ERASE
; it.

ofsm_erase:
  pop  de                  ;0B0F; Restore track and sector number.
  call rpt_hl              ;0B10; Make HL point to the entry to be
                                ; overwritten.
  ld   (hl),0              ;0B13; ERASE this file.
  call wsad                ;0B15; Write the entry back to disk.
  pop  ix                  ;0B18; Restore disk channel pointer.
  jr   ofsm_2              ;0B1A; Retry opening the file.

; The filename wasn't used so now the file can be opened.

ofsm_free:
  pop  ix                  ;0B1C; Restore disk channel pointer.
  push ix                  ;0B1E;
  ld   b,0                 ;0B20; Clear the file entry space in the disk
ofsm_clr_2:
  ld   (ix+19),0           ;0B22; channel.
  inc  ix                  ;0B26;
  djnz ofsm_clr_2          ;0B28;
  pop  ix                  ;0B2A; Restore disk channel pointer.
  push ix                  ;0B2C;
  ld   hl,ufia1.nstr1      ;0B2E; HL points to the file descriptor in
                                ; UFIA1.
  ld   b,11                ;0B31; Length of file descriptor.
ofsm_fdesc:
  ld   a,(hl)              ;0B33; Copy file descriptor to the file entry
  ld   (ix+19),a           ;0B34; space in the disk channel.
  inc  hl                  ;0B37;
  inc  ix                  ;0B38;
  djnz ofsm_fdesc          ;0B3A;
  pop  ix                  ;0B3C; Restore disk channel pointer.
  call mk_alloc            ;0B3E; Allocate a sector.
  call store_sec           ;0B41; Store its track and sector number.
  ld   (ix+32),d           ;0B44; Store its sector address also into the
  ld   (ix+33),e           ;0B47; file entry space.
  call res_rpt             ;0B4A; Reset RPT.
  ld   a,(mapused)         ;0B4D; Increment (MAPUSED), there is one more
  inc  a                   ;0B50; file which uses the disk bitmap.
  ld   (mapused),a         ;0B51;
  xor  a                   ;0B54; Return with Zero flag set to signal
  ret                      ;0B55; 'successfull'.

; ----------------------------------------------
; THE 'DECREMENT MAPUSE' SUBROUTINE

; This small subroutine decrements the MAPUSED system variable. This variable
; keeps track of the number of files using the disk bitmap. When it reaches 0
; the bitmap has to be rebuild.

dec_mapuse:
  push af                  ;0B56;
  ld   a,(mapused)         ;0B57; Decrease (MAPUSED), the number of
  dec  a                   ;0B5A; files using the disk bitmap.
  ld   (mapused),a         ;0B5B;
  pop  af                  ;0B5E;
  ret                      ;0B5F;

; ----------------------------------------------
; THE 'TEST FOR YES' SUBROUTINE

; This subroutine tests whether the 'Y'-key is pressed, it returns with the
; Zero flag set if it was, reset otherwise.

test_y:
  call beep                ;0B60; Produce a 'middle C' for one second.
test_y1:
  rst  calbas              ;0B63; The 'main' ROM is called to scan the
  defw rom_key_scan        ;0B64; keyboard.
  rst  calbas              ;0B66; It is also called to determine if a
  defw rom_key_test        ;0B67; key was pressed.
  jr   nc,test_y1          ;0B69; Repeat scanning and testing until a
                                ; key has been pressed.
  and  $DF                 ;0B6B; Capitalize.
  cp   "Y"                 ;0B6D; Set the Zero flag if it was the
  push af                  ;0B6F; 'Y'-key.
  rst  calbas              ;0B70; Again the 'main' ROM is called, this
  defw rom_cls_lower       ;0B71; time for clearing the lower screen.
  pop  af                  ;0B73; Retrieve Zero flag.
  ret                      ;0B74; Finished.

; ----------------------------------------------
; THE 'MAKE A BEEP' SUBROUTINE

; This subroutine produces a beep (the note 'middle C' in fact) for one
; second.

beep:
  push hl                  ;0B75;
  push de                  ;0B76;
  push bc                  ;0B77;
  push ix                  ;0B78;
  ld   hl,1642             ;0B7A; Parameters needed by 'BEEPER' to
  ld   de,261              ;0B7D; produce a 'middle C'.
  rst  calbas              ;0B80; Produce the note.
  defw rom_beeper          ;0B81;
  pop  ix                  ;0B83;
  pop  bc                  ;0B85;
  pop  de                  ;0B86;
  pop  hl                  ;0B87;
  ret                      ;0B88;

; ----------------------------------------------
; THE 'CLOSE A SAVE FILE' SUBROUTINE

; This subroutine closes a save file, by writing the last sector (contained in
; the data buffer) to disk and by writing the CATalogue entry.

cfsm:
  call rpt_hl1             ;0B89; HL points to the first unused position
                                ; in the data buffer.
  ld   a,c                 ;0B8C; C holds buffer offset-lo.
  and  a                   ;0B8D;
  jr   nz,cfsm_fill        ;0B8E; Jump if buffer isn't full yet.
  ld   a,b                 ;0B90; B holds buffer offset-hi.
  cp   2                   ;0B91;
  jr   z,cfsm_save         ;0B93; Jump if buffer is full.
cfsm_fill:
  ld   (hl),0              ;0B95; Otherwise fill up buffer with zero's.
  call inc_rpt             ;0B97; Increment RPT.
  jr   cfsm                ;0B9A; And close the file.

; The last sector is ready to be saved, it has been filled up with zero's if
; needed.

cfsm_save:
  call fetch_sec           ;0B9C; Fetch last sector's track and sector
  call wsad                ;0B9F; number and save it to disk.
  call dec_mapuse          ;0BA2; One file less uses the disk bitmap.
  push ix                  ;0BA5; Store disk channel pointer.
  ld   a,%01000000         ;0BA7; Search the CATalogue for an unused
  call scan_cat            ;0BA9; entry.
  jp   nz,rep_25           ;0BAC; If none found report 'Directory FULL'.
  call rpt_hl              ;0BAF; HL points to the entry.
  ld   (dfca.buflen),ix    ;0BB2; Store disk channel pointer 2, this one
                                ; points to the DFCA.
  pop  ix                  ;0BB6; Restore disk channel pointer 1, this
                                ; one can point to 'main' RAM (OPENTYPE)
  push ix                  ;0BB8; Store it again.
  ld   b,0                 ;0BBA; Copy the file entry to the CAT entry
cfsm_entry:
  ld   a,(ix+19)           ;0BBC; in the data buffer.
  ld   (hl),a              ;0BBF;
  inc  ix                  ;0BC0;
  inc  hl                  ;0BC2;
  djnz cfsm_entry          ;0BC3;
  ld   ix,(dfca.buflen)    ;0BC5; Restore disk channel pointer 2.
  call wsad                ;0BC9; Write the sector to disk.
  pop  ix                  ;0BCC; Restore disk channel pointer 1.
  ret                      ;0BCE; Finished.

; ----------------------------------------------
; THE 'OPEN A FILE FOR LOAD' SUBROUTINE

; This subroutine opens a file, with the specified filename, for loading. If
; the filename isn't found an error is given. If the filename is found it is
; opened and the first sector is loaded into the data buffer.

hgfle_2:
  ld   a,(ufia1.lstr1)     ;0BCF; Fetch device description from UFIA1.
  and  $DF                 ;0BD2; Capitalize.
  cp   "P"                 ;0BD4;
  jr   nz,hgfl_nonum       ;0BD6; Jump if no program number specified.
  ld   a,%00000001         ;0BD8; Search for the specified program
  call scan_cat            ;0BDA; number.
  jp   nz,rep_26           ;0BDD; If file isn't found report 'File NOT
                                ; FOUND'.
  call rpt_hl              ;0BE0; HL points to the entry.
  ld   de,ufia1.nstr1      ;0BE3; Copy the 11 byte file descriptor to
  ld   bc,11               ;0BE6; UFIA1.
  ldir                     ;0BE9;
  ld   (ix+13),211         ;0BEB; RPT points to the file header of the
                                ; file.
  call rpt_hl1             ;0BEF; Make HL point to it.
  ld   de,ufia1.hd00       ;0BF2; Copy the 9 byte file header to UFIA1.
  ld   bc,9                ;0BF5;
  ldir                     ;0BF8;
  jr   load_1st            ;0BFA; Jump forward to load the first sector.

; Now search for the file with the given name.

hgfl_nonum:
  ld   a,%00010000         ;0BFC; Search for the specified filename.
  call scan_cat            ;0BFE; If file isn't found report 'File NOT
  jp   nz,rep_26           ;0C01; FOUND'.
                                ; Otherwise the first sector is loaded
                                ; by entering the 'LOAD FIRST SECTOR'
                                ; subroutine below.

; ----------------------------------------------
; THE 'LOAD FIRST SECTOR' SUBROUTINE

; When the CAT entry of the file to be loaded is found, this routine can be
; used to fetch the first sector of the file. The first sector holds the 9
; byte file header (with certain filetypes) which should be identical to the 9
; byte file header present in the CAT entry.

load_1st:
  call rpt_hl              ;0C04; HL points to the entry.
  ld   de,ufia2.nstr1      ;0C07; Copy the 11 byte file descriptor to
  ld   bc,11               ;0C0A; UFIA2.
  ldir                     ;0C0D;
  ld   (ix+13),220         ;0C0F; RPT points to the SNAPSHOT registers,
                                ; that is when they are present.
  call rpt_hl1             ;0C13; Make HL point to it.
  ld   de,$3FEA            ;0C16; Copy the 22 SNAPSHOT values to the
  ld   bc,22               ;0C19; internal stack bottom.
  ldir                     ;0C1C;
  ld   (ix+13),13          ;0C1E; RPT points to track and sector number.
  call rpt_hl1             ;0C22; Now HL points to it also.
  ld   d,(hl)              ;0C25; Fetch track and sector number.
  inc  hl                  ;0C26;
  ld   e,(hl)              ;0C27;
  jp   rsad                ;0C28; And exit while loading the first
                                ; sector.

; ----------------------------------------------
; THE 'FORMAT A DISK' ROUTINE

; This routine formats a disk by writing one track at a time to disk. The
; track is first build up in 'main' RAM. After the formatting is completed,
; the other disk is completely copied (cloned) or the disk is checked for bad
; sectors.

format_run:
  call test_drive.ufia1    ;0C2B; See if the drive is defined.
  call set_drvsd           ;0C2E;
  ld   b,20                ;0C31; First step 20 times inward.
frmt_1:
  push bc                  ;0C33;
  call step_in             ;0C34;
  pop  bc                  ;0C37;
  djnz frmt_1              ;0C38;
  call track_0             ;0C3A; Then position the head above track 0.
  ld   ix,dfca             ;0C3D;
frmt_trk:
  call mk_trk_dd           ;0C41; Build up a double density track.
  ld   c,%11110000         ;0C44; Write track, disable spin-up sequence,
                                ; no delay, enable precompensation.
  call precomp1            ;0C46; Why call this routine? The precomp.
                                ; has already been enabled.
  ld   hl,49152            ;0C49; HL points to the track build up in
                                ; 'main' memory.
  call wr_op               ;0C4C; Write the track.
  call step_delay          ;0C4F; Wait a moment.
  inc  d                   ;0C52; Next track.
  call drv_cap             ;0C53; Get drive capacity in A.
  cp   d                   ;0C56;
  jr   z,frmt_done         ;0C57; Jump if all tracks have been formatted
  and  $7F                 ;0C59; Mask off side.
  cp   d                   ;0C5B;
  jr   z,frmt_side1        ;0C5C; Jump if side1 hasn't been formatted.
  call step_in             ;0C5E; Next track.

; The following code determines the skew, i.e. the shifting between the
; sectors of a track and the previous track. The +D uses a skew of +2, so
; sector 1 on track T lies adjacent to sector 9 on track T+1.

  dec  e                   ;0C61;
  jr   nz,frmt_2           ;0C62; Jump if sector >= 1.
  ld   e,10                ;0C64; Sector numbers have range 1..10.
frmt_2:
  dec  e                   ;0C66;
  jr   nz,frmt_3           ;0C67; Jump if sector >= 1.
  ld   e,10                ;0C69; This instruction is never reached??
frmt_3:
  jp   frmt_trk            ;0C6B; Format the next track.

; If a double sided drive is used, the formatting continues on track 0 side 1.

frmt_side1:
  call track_0             ;0C6E; Reset drive head.
  ld   d,128               ;0C71; Track 0, side 1.
  call set_drvsd           ;0C73; Set drive, side, density, etc.
  jp   frmt_trk            ;0C76; Continue formatting.

; When the formatting of all tracks is completed, the routine checks whether
; it is supposed to copy another disk to this one, or to verify the disk.

frmt_done:
  call rest                ;0C79; Reset drive head.
  ld   a,(ufia2.dstr1)     ;0C7C;
  cp   $FF                 ;0C7F;
  jr   z,frmt_chk          ;0C81; Jump if UFIA2 is empty.

; When the disk in the other drive is to be cloned, it will be copied a track
; at a time.

frmt_copy:
  ld   hl,49152            ;0C83; Address of track buffer.
  ld   (dfca.left),hl      ;0C86; Store load address.
  ld   (dfca.addr),hl      ;0C89; Store save address.
  ld   a,(ufia2.dstr1)     ;0C8C; Fetch source drive number from UFIA2.
  call test_drive.a        ;0C8F; Check and set drive.
frmt_c1:
  call rsad                ;0C92; Load a sector.
  push de                  ;0C95; Store track and sector number.
  ld   hl,$3BD6            ;0C96; DRAM sector buffer address.
  ld   de,(dfca.left)      ;0C99; Fetch load address.
  ld   bc,512              ;0C9D; BC holds sector length.
  ldir                     ;0CA0; Copy the contents of the buffer to
                                ; 'main' RAM.
  ld   (dfca.left),de      ;0CA2; Store new load address.
  pop  de                  ;0CA6; Restore track and sector number.
  call next_sec            ;0CA7; Compute next sector number.
  jr   nz,frmt_c1          ;0CAA; Jump if there is still a sector on this
                                ; track.
  ld   a,(ufia1.dstr1)     ;0CAC; Fetch destination drive from UFIA1.
  call test_drive.a        ;0CAF; Check and set drive.
frmt_c2:
  push de                  ;0CB2; Store track and sector number.
  ld   hl,(dfca.addr)      ;0CB3; Fetch save address.
  ld   de,$3BD6            ;0CB6; DRAM sector buffer address.
  ld   bc,512              ;0CB9; BC holds sector length.
  ldir                     ;0CBC; Copy a sector to the sector buffer.
  ld   (dfca.addr),hl      ;0CBE; Store new save address.
  pop  de                  ;0CC1; Restore track and sector number.
  call wsad                ;0CC2; Save the sector.
  call next_sec            ;0CC5; Compute next sector number.
  jr   nz,frmt_c2          ;0CC8; Jump if not all sectors on this track
                                ; have been written.
  call nxt_trk             ;0CCA; Compute next track number.
  jr   nz,frmt_copy        ;0CCD; Jump if not all tracks have been
                                ; copied.
  ei                       ;0CCF; Enable interrupts and exit via
  jp   rest                ;0CD0; 'REST'.

; The routine now verifies if all sectors are readable. An error is given if a
; sector can't be read, it would have been more usefull if a 'badsectors' file
; was saved.

frmt_chk:
  call rsad                ;0CD3; Load a sector.
  call next_sec            ;0CD6; Compute next sector number.
  jr   nz,frmt_chk         ;0CD9; Jump if not all sectors on one track
                                ; have been loaded.
  call nxt_trk             ;0CDB; Compute next track number.
  jr   nz,frmt_chk         ;0CDE; Jump if not all tracks on the disk have
                                ; been verified.
  ei                       ;0CE0; Enable interrupts and exit via
  jp   rest                ;0CE1; 'REST'.

; ----------------------------------------------
; THE 'NXT_TRK' SUBROUTINE

; This subroutine is almost the same as the 'NEXT_TRACK' subroutine at $0956.
; But the differences are essential. No error is given when a non existent
; track is reached and the Zero flag is used to signal 'no more tracks on this
; side' when set.

nxt_trk:
  inc  d                   ;0CE4; Increase track number.
  call drv_cap             ;0CE5; Get drive capacity in A.
  cp   d                   ;0CE8;
  ret  z                   ;0CE9; Return with Zero set if last track
                                ; reached.
  and  $7F                 ;0CEA; Mask off side bit.
  cp   d                   ;0CEC;
  ret  nz                  ;0CED; Return with Zero reset if last track
                                ; on side0 hasn't been reached.
  call rest                ;0CEE; Reset drive head.
  ld   d,128               ;0CF1; Track 0, side 1.
  cp   d                   ;0CF3; Reset Zero flag.
  ret                      ;0CF4;

; ----------------------------------------------
; THE 'BUILD UP A DD TRACK' SUBROUTINE

; This subroutine builds up a double density track in the 'main' memory
; starting at address 49152.

mk_trk_dd:
  ld   hl,49152            ;0CF5; Start of track buffer.
  ld   bc,$3C4E            ;0CF8; Store 60 bytes $4E. GAP I.
  call b_times_c           ;0CFB;
  ld   b,10                ;0CFE; Number of sectors on a track.
mk_trk_dd1:
  push bc                  ;0D00;
  ld   bc,$0C00            ;0D01; 12 bytes $00. Last part of GAP III.
  call b_times_c           ;0D04;
  ld   bc,$03F5            ;0D07; 3 bytes $F5 (written as $A1).
  call b_times_c           ;0D0A;
  ld   bc,$01FE            ;0D0D; 1 byte  $FE (ID field ID).
  call b_times_c           ;0D10;
  ld   a,d                 ;0D13; Fetch track number.
  and  $7F                 ;0D14; Mask side bit.
  ld   c,a                 ;0D16;
  ld   b,1                 ;0D17; 1 byte  track number.
  call b_times_c           ;0D19;
  ld   a,d                 ;0D1C; Fetch track again.
  and  $80                 ;0D1D; Keep only side bit.
  rlca                     ;0D1F; Rotate it to bit 0.
  ld   c,a                 ;0D20;
  ld   b,1                 ;0D21; 1 byte  side number.
  call b_times_c           ;0D23;
  ld   c,e                 ;0D26; Fetch sector number.
  call next_sec            ;0D27; Increment sector number.
  ld   b,1                 ;0D2A; 1 byte  sector number.
  call b_times_c           ;0D2C;
  ld   bc,$0102            ;0D2F; 1 byte  $02 (sector length = 512).
  call b_times_c           ;0D32;
  ld   bc,$01F7            ;0D35; 1 byte  $F7 (two CRC bytes written).
  call b_times_c           ;0D38;
  ld   bc,$164E            ;0D3B; 22 bytes $4E. GAP II.
  call b_times_c           ;0D3E;
  ld   bc,$0C00            ;0D41; 12 bytes $00.
  call b_times_c           ;0D44;
  ld   bc,$03F5            ;0D47; 3 bytes $F5 (written as $A1).
  call b_times_c           ;0D4A;
  ld   bc,$01FB            ;0D4D; 1 byte  $FB (data field ID).
  call b_times_c           ;0D50;
  ld   bc,$0000            ;0D53; 512 bytes $00. Data bytes.
  call b_times_c           ;0D56;
  call b_times_c           ;0D59;
  ld   bc,$01F7            ;0D5C; 1 byte  $F7 (two CRC bytes written).
  call b_times_c           ;0D5F;
  ld   bc,$184E            ;0D62; 24 bytes $4E. First part of GAP III.
  call b_times_c           ;0D65;
  pop  bc                  ;0D68; Retrieve sector counter.
  dec  b                   ;0D69; Repeat until all 10 sectors have been
  jp   nz,mk_trk_dd1       ;0D6A; build up.
  ld   bc,$004E            ;0D6D; 768 bytes $00. GAP IV.
  call b_times_c           ;0D70;
  call b_times_c           ;0D73;
  jp   b_times_c           ;0D76;

; ----------------------------------------------
; THE 'STORE B TIMES BYTE C' SUBROUTINE

; This subroutine is used in the construction of a track in memory, it stores
; the byte held in the C register, B times.

b_times_c:
  ld   (hl),c              ;0D79; Store C.
  inc  hl                  ;0D7A; Next address.
  djnz b_times_c           ;0D7B; Repeat until B=0.
  ret                      ;0D7D;

; ----------------------------------------------
; THE 'NEXT SECTOR' SUBROUTINE

; This subroutine computes the next sector number in E, it returns with the
; Zero flag set indicating 'next track'.

next_sec:
  inc  e                   ;0D7E; Increment sector number.
  ld   a,e                 ;0D7F;
  cp   11                  ;0D80;
  ret  nz                  ;0D82; Return with Zero reset signalling
                                ; 'same track'.
  ld   e,1                 ;0D83; Otherwise start with sector 1 again.
  ret                      ;0D85; Return with Zero set signalling 'next
                                ; track'.

; ----------------------------------------------
; THE 'MAKE HL POINT TO BUFFER' SUBROUTINE

; This subroutine returns with HL holding the start of the data buffer. On
; entry IX must point to the start of the disk channel.

hl_buffer:
  push bc                  ;0D86;
  push ix                  ;0D87; Disk channel pointer to BC.
  pop  bc                  ;0D89;
  ld   l,(ix+15)           ;0D8A; Fetch data buffer offset.
  ld   h,(ix+16)           ;0D8D;
  add  hl,bc               ;0D90; HL now points to the data buffer.
  pop  bc                  ;0D91;
  ret                      ;0D92;

; ----------------------------------------------
; THE 'FETCH RPT INTO HL' SUBROUTINE

; This subroutine returns with HL holding the RAM PoinTer, which points to the
; next data byte in the data buffer. When entering at $0D93, RPT-lo is first
; reset.

rpt_hl:
  ld   (ix+13),0           ;0D93; Reset RPT-lo.
rpt_hl1:
  call hl_buffer           ;0D97; HL points to the data buffer.
  ld   b,(ix+14)           ;0D9A; Fetch RPT offset into BC.
  ld   c,(ix+13)           ;0D9D;
  add  hl,bc               ;0DA0; Add the offset to the start of the
                                ; data buffer.
  ret                      ;0DA1; Finished.

; ----------------------------------------------
; THE 'INCREMENT RPT' SUBROUTINE

; This small subroutine increments the RAM PoinTer offset.

inc_rpt:
  inc  (ix+13)             ;0DA2; Increment RPT-lo.
  ret  nz                  ;0DA5;
  inc  (ix+14)             ;0DA6; Increment RPT-hi when necessary.
  ret                      ;0DA9;

; ----------------------------------------------
; THE 'RESET RPT' SUBROUTINE

; This small subroutine resets the RAM PoinTer offset.

res_rpt:
  ld   (ix+13),0           ;0DAA; Clear RPT offset.
  ld   (ix+14),0           ;0DAE;
  ret                      ;0DB2;

; ----------------------------------------------
; THE 'FETCH SECTOR ADDRESS' SUBROUTINE

; This subroutine returns with DE holding the stored track and sector number.

fetch_sec:
  ld   d,(ix+18)           ;0DB3;
  ld   e,(ix+17)           ;0DB6;
  ret                      ;0DB9;

; ----------------------------------------------
; THE 'STORE SECTOR ADDRESS' SUBROUTINE

; This subroutine stores the track and sector number held in DE into the disk
; channel.

store_sec:
  ld   (ix+18),d           ;0DBA;
  ld   (ix+17),e           ;0DBD;
  ret                      ;0DC0;

; ----------------------------------------------
; THE 'GET SECTOR ADDRESS' SUBROUTINE

; This subroutine returns with DE holding the stored track and sector number
; and the track and sector number held in HL stored into the disk channel.

get_sector:
  call fetch_sec           ;0DC1; Fetch the stored track and sector
  ld   (ix+18),h           ;0DC4; number. And store the track and sector
  ld   (ix+17),l           ;0DC7; number held in HL.
  ret                      ;0DCA;

; ----------------------------------------------
; THE 'STEP' SUBROUTINES

; These two small subroutines are used to move the drive head one step in or
; out.

step_out:
  ld   c,%01111000         ;0DCB; Step-out, update track register,
  jr   step                ;0DCD; disable spin-up sequence, no verify,
                                ; step rate 6 ms.
step_in:
  ld   c,%01011000         ;0DCF; Step-in, update track register,
                                ; disable spin-up sequence, no verify,
                                ; step rate 6 ms.
step:
  call ld_com_reg          ;0DD1; Execute the command, move one track.
  jp   step_delay          ;0DD4; Wait for the number of milliseconds
                                ; specified by (STPRAT).


; ===============================================================
; The 'Hook code' routines

; The following routines are called by the 'hook and command code' routine at
; $228E (in RAM) whenever a hook code was used.

; ----------------------------------------------
; THE 'HOOK CODE ADDRESSES' TABLE

; This jump table consists of the 24 addresses of the routines called by using
; the various 'hook codes' in the range $1B..$32 (27..50).

if1_hook:
  defw cons_in             ;0DD7; Hook code $1B, 27.
  defw cons_out            ;0DD9; Hook code $1C, 28.
  defw bchan_in            ;0DDB; Hook code $1D, 29.
  defw bchan_out           ;0DDD; Hook code $1E, 30.
  defw prt_out             ;0DDF; Hook code $1F, 31.
  defw kbd_test            ;0DE1; Hook code $20, 32.
  defw sel_drive           ;0DE3; Hook code $21, 33.
  defw op_temp_m           ;0DE5; Hook code $22, 34.
  defw close_m2            ;0DE7; Hook code $23, 35.
  defw erase_111E          ;0DE9; Hook code $24, 36.
  defw read_seq            ;0DEB; Hook code $25, 37.
  defw wr_recd             ;0DED; Hook code $26, 38.
  defw rd_random           ;0DEF; Hook code $27, 39.
  defw rd_sector           ;0DF1; Hook code $28, 40.
  defw rd_next             ;0DF3; Hook code $29, 41.
  defw wr_sector           ;0DF5; Hook code $2A, 42.
  defw set_t_mch           ;0DF7; Hook code $2B, 43.
  defw del_m_buf           ;0DF9; Hook code $2C, 44.
  defw op_temp_n           ;0DFB; Hook code $2D, 45.
  defw close_net           ;0DFD; Hook code $2E, 46.
  defw get_pack            ;0DFF; Hook code $2F, 47.
  defw send_pack           ;0E01; Hook code $30, 48.
  defw hook_31             ;0E03; Hook code $31, 49.
  defw hook_32             ;0E05; Hook code $32, 50.

; ----------------------------------------------
; THE 'RS232 NOT SUPPORTED' SUBROUTINE

; The 'BCHAN_IN' and 'BCHAN_OUT' 'hook codes' are not supported (the +D has no
; RS232 link).

bchan_in:
bchan_out:
  ret                      ;0E07;

; ----------------------------------------------
; THE 'CONSOLE INPUT' SUBROUTINE

; Called by using 'hook code' 27 ($1B), it simply waits until a key is
; pressed. A return is made with the A register holding the character code.

cons_in:
  res  5,(iy+1)            ;0E08; Signal 'ready for a new key'.
wtkey:
  ei                       ;0E0C; Enable interrupts.
  halt                     ;0E0D; Wait for an interrupt.
  rst  calbas              ;0E0E; Call the keyboard scan routine in the
  defw rom_keyboard        ;0E0F; 'main' ROM.
  bit  5,(iy+1)            ;0E11; Repeat the scan until a key has been
  jr   z,wtkey             ;0E15; pressed.
  ld   a,(23560)           ;0E17; Fetch the character code from (LAST_K)
  ret                      ;0E1A;

; ----------------------------------------------
; THE 'CONSOLE OUTPUT' SUBROUTINE

; By using 'hook code' 28 ($1C) the character held in the A register is
; printed on the screen, with scroll suppressed.

cons_out:
  push af                  ;0E1B;
  ld   a,254               ;0E1C; Use stream '-2' (attached to "S" the
                                ; channel).
out_code:
  ld   hl,23692            ;0E1E; This is SCR_CT.
  ld   (hl),$FF            ;0E21; Set scroll counter.
  rst  calbas              ;0E23; Call 'CHAN_OPEN' in the 'main' ROM to
  defw rom_chan_open       ;0E24; make stream -2 the current.
  pop  af                  ;0E26;
  rst  calbas              ;0E27; Print the character to the current
  defw rom_print_a         ;0E28; stream.
  ret                      ;0E2A;

; ----------------------------------------------
; THE 'PRINTER OUTPUT' SUBROUTINE

; This subroutine is called by using 'hook code' 31 ($1F). It is identical to
; the preceding one, but the output is directed to stream 3 (normally the
; printer).

prt_out:
  push af                  ;0E2B;
  ld   a,3                 ;0E2C; Select stream 3.
  jr   out_code            ;0E2E;

; ----------------------------------------------
; THE 'KEYBOARD TEST' SUBROUTINE

; This is called using 'hook code' 32 ($20). A return is made with the Zero
; flag reset if a key is pressed.

kbd_test:
  xor  a                   ;0E30; Clear A, allowing for the whole
                                ; keyboard to be examined.
  in   a,(254)             ;0E31; Read the keyboard.
  and  $1F                 ;0E33; Keep only the keyboard bits.
  sub  $1F                 ;0E35; Return with sign negative and Zero
  ret                      ;0E37; flag reset if a key is pressed.

; ----------------------------------------------
; THE 'SELECT DRIVE' SUBROUTINE

; This subroutine is called by using 'hook code' 33 ($21). On entry, A holds
; the drive number; if A isn't equal to 1 or 2 nothing is done.

sel_drive:
  cp   1                   ;0E38;
  jr   z,sel_drive1        ;0E3A; Jump if drive 1 is to be selected.
  cp   2                   ;0E3C;
  jr   z,sel_drive1        ;0E3E; Jump if drive 2 is to be selected.
  xor  a                   ;0E40;
  ret                      ;0E41; Otherwise exit.
sel_drive1:
  ld   b,a                 ;0E42;
  ld   (dfca.drive),a      ;0E43;
  ld   a,(control_port_status) ;0E46; Fetch current control port status.
  and  $FC                 ;0E49; Drop the drive select bits.
  or   b                   ;0E4B; Use the new drive.
  ld   (control_port_status),a ;0E4C; Exit setting both current control port
  out  (239),a             ;0E4F; status and the control port itself.
  ret                      ;0E51;

; ----------------------------------------------
; THE 'OPEN TEMP. "M" CHANNEL' SUBROUTINE

; This subroutine is used to open a temporary "M" channel in the CHANS area.
; It is called by using 'hook code' 34 ($22). First a temporary "M" channel is
; created, then the drive whose number is held into 'D_STR1' is searched for a
; file whose name is held into 'N_STR1'. A sector map is created with each
; reset bit indicating a free sector.  Various flags are returned as follows:

    ; - bit 0 of CHFLAG                    set with 'write' files.
    ; - bit 1 of RECFLG                    set with 'EOF' block.
    ; - bit 2 of RECFLG                    set with PRINT-type files.

; On exit, HL holds a 'stream data' displacement that may be used to attach
; the channel to a stream.

op_temp_m:
  call set_t_mch           ;0E52; Create a temporary "M" channel.
  push hl                  ;0E55; Save 'stream displacement'.
  ld   a,(ix+25)           ;0E56; Fetch the drive number (CHDRIV).
  call sel_drive           ;0E59; Select the drive.
  push ix                  ;0E5C;
  ld   de,14               ;0E5E; Make IX point to CHNAME, the name of
  add  ix,de               ;0E61; the wanted file.
  call find_file_1146      ;0E63; Search for the filename.
  jr   nz,op_t_2           ;0E66; Jump if not found.
  inc  hl                  ;0E68; Skip number of sectors used.
  inc  hl                  ;0E69;
  ld   d,(hl)              ;0E6A; Fetch first track and sector.
  inc  hl                  ;0E6B;
  ld   e,(hl)              ;0E6C;
  ld   ix,dfca             ;0E6D;
  call rsad                ;0E71; Read the first sector.
  pop  ix                  ;0E74; Restore channel pointer (in 'main'
  push ix                  ;0E76; RAM).
  ld   de,540              ;0E78; Microdrive type files consist of
                                ; records with a length of 540 bytes
                                ; each.
op_t_1:
  push ix                  ;0E7B; Store data buffer pointer (in 'main'
                                ; RAM).
  ld   ix,dfca             ;0E7D;
  call lbyt                ;0E81; Fetch a byte.
  pop  ix                  ;0E84; Restore data buffer pointer.
  ld   (ix+55),a           ;0E86; Loading starts with the data block
                                ; preamble (offset 55).
  inc  ix                  ;0E89;
  call dec_de              ;0E8B; Decrement DE.
  jr   nz,op_t_1           ;0E8E; Repeat until DE=0.
  pop  ix                  ;0E90;
  res  0,(ix+24)           ;0E92; Signal 'read file'.
  pop  hl                  ;0E96; Restore stream 'stream data'.
  ret                      ;0E97; Finished.

op_t_2:
  ld   hl,disk_bitmap      ;0E98; Clear the disk bitmap.
  ld   b,disk_bitmap_size  ;0E9B;
op_t_3:
  ld   (hl),0              ;0E9D;
  inc  hl                  ;0E9F;
  djnz op_t_3              ;0EA0;
  ld   a,%00100000         ;0EA2; Make new disk bitmap.
  call scan_cat            ;0EA4;
  pop  ix                  ;0EA7;
  push ix                  ;0EA9;
  ld   hl,fd_file_type     ;0EAB; Points to dir. descr. of DFCA.
  ld   (hl),6              ;0EAE; File is a 'Microdrive file'.
  inc  hl                  ;0EB0;
  ld   b,10                ;0EB1; Copy the 10 characters of the name.
op_t_4:
  ld   a,(ix+14)           ;0EB3;
  ld   (hl),a              ;0EB6;
  inc  ix                  ;0EB7;
  inc  hl                  ;0EB9;
  djnz op_t_4              ;0EBA;
  ld   b,245               ;0EBC; Clear the rest of the CATalogue entry
op_t_5:
  ld   (hl),0              ;0EBE; of this file.
  inc  hl                  ;0EC0;
  djnz op_t_5              ;0EC1;
  ld   hl,$0000            ;0EC3; Reset RPT.
  ld   (rpt),hl            ;0EC6;
  ld   hl,$3BD6            ;0EC9; Clear the first 256 bytes of the data
  ld   b,0                 ;0ECC; buffer.
op_t_6:
  ld   (hl),0              ;0ECE;
  inc  hl                  ;0ED0;
  djnz op_t_6              ;0ED1;
  ld   ix,dfca             ;0ED3;
  call mk_alloc            ;0ED7; Allocate the first free sector.
  ld   ($3AD4),de          ;0EDA; Store the track and sector number.
  ld   ix,file_descriptor  ;0EDE; Store them also into the CATalogue
  ld   (ix+13),d           ;0EE2; entry.
  ld   (ix+14),e           ;0EE5;
  pop  ix                  ;0EE8;
  res  1,(ix+67)           ;0EEA; Signal 'Not the EOF block' (RECFLG).
  res  2,(ix+67)           ;0EEE; Signal 'PRINT-type file' (opened for
  pop  hl                  ;0EF2; writing). Restore stream 'stream data'
  ret                      ;0EF3; Finished.

; ----------------------------------------------
; THE 'SET A TEMP. "M" CHANNEL' SUBROUTINE

; This subroutine is also called by using 'hook code' 43 ($2B). It sets a
; temporary "M" channel in the CHANS area. The subroutine returns with IX
; pointing to the start of the channel and HL holding a suitable displacement
; to be eventually inserted in the STRMS area to attach the channel to a
; stream.

set_t_mch:
  ld   ix,(23631)          ;0EF4; Fetch (CHANS), the start of the
                                ; channel area.
  ld   de,20               ;0EF8; Make IX point to the start of the
  add  ix,de               ;0EFB; 'new' channels.
set_t_1:
  ld   a,(ix+0)            ;0EFD;
  cp   128                 ;0F00;
  jr   z,set_t_3           ;0F02; Jump if the CHANS area is finished.
  ld   a,(ix+4)            ;0F04; Fetch the channel specifier.
  and  $7F                 ;0F07; Clear bit 7 (drop temporary/permanent
                                ; flag).
  cp   "M"                 ;0F09;
  jr   nz,set_t_2          ;0F0B; Jump if not a "M" channel.
  ld   a,(23766)           ;0F0D; Fetch drive number (D_STR1).
  cp   (ix+25)             ;0F10; Compare it with (CHDRIV).
  jr   nz,set_t_2          ;0F13; Jump if this channel uses a different
                                ; drive.
  ld   bc,(23770)          ;0F15; Fetch length of filename (NSTR_1).
  ld   hl,(23772)          ;0F19; And its startaddress (NSTR_1+2).
  call chk_name            ;0F1C; Check name against 'CHNAME' of this
                                ; channel.
  jr   nz,set_t_2          ;0F1F; Jump if not the same file.
  bit  0,(ix+24)           ;0F21;
  jr   z,set_t_2           ;0F25; Jump if it's a 'read file'.
  jp   md_error            ;0F27; Exit if the file is already opened for
                                ; writing.
set_t_2:
  ld   e,(ix+9)            ;0F2A; Fetch the length of the channel.
  ld   d,(ix+10)           ;0F2D;
  add  ix,de               ;0F30; Point to the next channel.
  jr   set_t_1             ;0F32; Check next channel.

; Now the space for the new channel is created at the end of the CHANS area.

set_t_3:
  ld   hl,(23635)          ;0F34; Calculate end of CHANS area ((PROG)-1)
  dec  hl                  ;0F37; i.e. the start of the channel.
  push hl                  ;0F38;
  ld   bc,595              ;0F39; Length is '595' bytes.
  rst  calbas              ;0F3C; Create the required space by calling
  defw rom_make_room       ;0F3D; 'MAKE_ROOM'.
  pop  de                  ;0F3F; Restore start address of the channel.
  push de                  ;0F40;
  ld   hl,mchan_data       ;0F41; Start of "M" channel data.
  ld   bc,25               ;0F44;
  ldir                     ;0F47; Store channel data into the channel.
  ld   a,(23766)           ;0F49; Fetch drive number (D_STR1).
  ld   (ix+25),a           ;0F4C; Store it into the channel (CHDRIV).
  ld   bc,595              ;0F4F; Length of the channel.
  push ix                  ;0F52; Make HL point to the start of the
  pop  hl                  ;0F54; channel.
  call rest_f_ad           ;0F55; Restore 'start of filename' possibly
                                ; moved during the 'insertion' of the
                                ; channel.
  ex   de,hl               ;0F58; The start address of the filename goes
                                ; to HL.
  ld   bc,(23770)          ;0F59; Fetch length of filename (N_STR1).
  bit  7,b                 ;0F5D; Jump if the name doesn't exist
  jr   nz,set_t_5          ;0F5F; (N_STR1 = $FFFF).

; The channel name is transferred into CHNAME.

set_t_4:
  ld   a,b                 ;0F61;
  or   c                   ;0F62;
  jr   z,set_t_5           ;0F63; Jump if no more bytes left.
  ld   a,(hl)              ;0F65; Transfer a character of the name into
  ld   (ix+14),a           ;0F66; (CHNAME).
  inc  hl                  ;0F69; Point to next locations.
  inc  ix                  ;0F6A;
  dec  bc                  ;0F6C; One byte less.
  jr   set_t_4             ;0F6D; Continue with next character.

; Now the 'preambles' are stored into the channel.

set_t_5:
  pop  ix                  ;0F6F; Restore start address of channel.
  ld   de,28               ;0F71; Offset for header block preamble.
  call setup_pre           ;0F74; Set-up header preamble.
  ld   de,55               ;0F77; Offset for data block preamble.
  call setup_pre           ;0F7A; Set-up data block preamble.
  push ix                  ;0F7D; Make HL point to the start of the
  pop  hl                  ;0F7F; channel.
  ld   de,(23631)          ;0F80; Calculate the required 'stream offset'
  or   a                   ;0F84; into HL (i.e. channel start-(CHANS)+1)
  sbc  hl,de               ;0F85;
  inc  hl                  ;0F87;
  ret                      ;0F88; Finished.

; ----------------------------------------------
; THE 'SET-UP A PREAMBLE' SUBROUTINE

; The following subroutine passes a preamble to the specified channel
; position.  On entry IX points to the start of the channel and DE holds the
; required offset.

setup_pre:
  push ix                  ;0F89; Pass start of channel to HL.
  pop  hl                  ;0F8B;
  add  hl,de               ;0F8C; Add the offset.
  ex   de,hl               ;0F8D; DE now points to the preamble area.
  ld   hl,$0F97            ;0F8E; Start of 'preamble' data.
  ld   bc,12               ;0F91; Preamble is 12 bytes long.
  ldir                     ;0F94;
  ret                      ;0F96;

; ----------------------------------------------
; THE 'PREAMBLE DATA' TABLE

; The header and data block preambles consist of the following bytes:

preamble:
  defb $00,$00,$00,$00,$00 ;0F97;
  defb $00,$00,$00,$00,$00 ;0F9C;
  defb $FF,$FF             ;0FA1;

; The Microdrive needs these bytes to fetch the start of a block of bytes when
; reading a cartridge.

; ----------------------------------------------
; THE 'RESTORE FILENAME ADDRESS' ROUTINE

; After the 'insertion' of some space, the 'filename' whose start addresses
; are held into (N_STR1+2) and (N_STR2+2) have been moved up in the workspace
; area. This routine is entered with HL holding the channel start address, and
; with BC holding the number of 'inserted' bytes. The addresses held into
; (N_STR1+2) and (N_STR2+2) are then updated, unless the filenames are stored
; into 'no-dynamic' areas (i.e. before the channel or after STKEND).

rest_f_ad:
  push hl                  ;0FA3; Save 'start of channel' twice.
  push hl                  ;0FA4;
  ld   de,(23780)          ;0FA5; Restore start address of the second
  call tst_place           ;0FA9; filename.
  ld   (23780),de          ;0FAC;
  pop  hl                  ;0FB0; Restore channel start address.
  ld   de,(23772)          ;0FB1; Restore start address of the first
  call tst_place           ;0FB5; filename.
  ld   (23772),de          ;0FB8;
  pop  hl                  ;0FBC; Restore channel start address.
  ret                      ;0FBD; Finished.

; The following subroutine calculates the new filename address.

tst_place:
  scf                      ;0FBE; Allow for a further byte.
  sbc  hl,de               ;0FBF; No action is made if the filename is
  ret  nc                  ;0FC1; before the channel.
  ld   hl,(23653)          ;0FC2; Or if it is after (STKEND).
  sbc  hl,de               ;0FC5;
  ret  c                   ;0FC7;
  ex   de,hl               ;0FC8; Add to DE the number of 'inserted'
  add  hl,bc               ;0FC9; bytes, so returning the new filename
  ex   de,hl               ;0FCA; address.
  ret                      ;0FCB; Finished.

; ----------------------------------------------
; THE 'CHECK NAME' SUBROUTINE

; Whenever a 'filename' is to be compared against the channel name CHNAME,
; this subroutine is called. On entry, HL must point to the filename to be
; compared, while C must contain its length. If the comparision is succesful,
; the Zero flag is returned set.

chk_name:
  push ix                  ;0FCC; Save start of channel.
  ld   b,10                ;0FCE; Length of a filename.
chk_name1:
  ld   a,(hl)              ;0FD0; Fetch a byte from the name.
  cp   (ix+14)             ;0FD1;
  jr   nz,chk_name3        ;0FD4; Jump if it doesn't match.
  inc  hl                  ;0FD6; Point to the next character.
  inc  ix                  ;0FD7;
  dec  b                   ;0FD9; One byte less.
  dec  c                   ;0FDA; Repeat until all bytes of the name have
  jr   nz,chk_name1        ;0FDB; been matched.
  ld   a,b                 ;0FDD; CHNAME remaining length.
  or   a                   ;0FDE;
  jr   z,chk_name3         ;0FDF; Exit if all bytes of CHNAME matched.
chk_name2:
  ld   a,(ix+14)           ;0FE1; Otherwise the remaining characters of
  cp   32                  ;0FE4; CHNAME have to be spaces.
  jr   nz,chk_name3        ;0FE6; Exit if not a space.
  inc  ix                  ;0FE8; Repeat until all bytes of CHNAME have
  djnz chk_name2           ;0FEA; been examined.
chk_name3:
  pop  ix                  ;0FEC; Restore channel start address.
  ret                      ;0FEE; Finished.

; ----------------------------------------------
; THE 'CALL INP' ROUTINE

; This routine is the same as the Interface 1 'CALL_INP' routine which handles
; all IF1's channels. The +D uses this routine only for "M" channels, for "D"
; channels a similar routine located in RAM is used. (The only difference is
; the test of FLAGS3, i.e. IY+124 while emulating the IF1, $3ACF otherwise.)
; On entry HL holds the address of the service 'input' routine. The routine
; handles both INPUT and INKEY$ commands.

call_inp:
  res  3,(iy+2)            ;0FEF; Signal 'the mode is to be considered
                                ; as being unchanged'.
  push hl                  ;0FF3; Store address of service routine.
  ld   hl,(23613)          ;0FF4; HL points to error address (ERR_SP).
  ld   e,(hl)              ;0FF7; Fetch the error address.
  inc  hl                  ;0FF8;
  ld   d,(hl)              ;0FF9;
  and  a                   ;0FFA;
  ld   hl,rom_ed_error     ;0FFB; If the error address is 'ED_ERROR'
  sbc  hl,de               ;0FFE; ('main' ROM) then an INPUT command was
  jr   nz,inkey_dollar     ;1000; used. Jump if unequal to 'ED_ERROR'.

; Now deal with an 'INPUT #' command referring to a "M" channel.

  pop  hl                  ;1002; Restore address of service routine.
  ld   sp,(23613)          ;1003; Clear the machine stack (ERR_SP).
  pop  de                  ;1007; Remove 'ED_ERROR'.
  pop  de                  ;1008;
  ld   (23613),de          ;1009; Restore the old value of ERR_SP.
in_again:
  push hl                  ;100D; Store address of service routine.
  ld   de,input_end        ;100E; Return address is 'INPUT_END' below.
  push de                  ;1011;
  jp   (hl)                ;1012; Jump to the service routine.

; When the byte has been read from the required channel, a return is made here
; to add the byte to the INPUT line, or to return if the byte is equal to CHR$
; 13, i.e.  ENTER.

input_end:
  jr   c,acc_code          ;1013; Jump with acceptable codes.
  jr   z,no_read           ;1015; Jump with no data read.
input_err:
  jp   md_error            ;1017; Otherwise jump to the 'hook code'
                                ; error routine.
no_read:
  pop  hl                  ;101A; Restore address of service routine and
  jr   in_again            ;101B; try again.

; An acceptable code was received, it is added to the INPUT line.

acc_code:
  cp   13                  ;101D;
  jr   z,end_input         ;101F; Jump if the code is ENTER.
  rst  calbas              ;1021; Otherwise the byte is to be added to
  defw rom_add_char_keeping_current_mode ;1022; the INPUT line. This is done by call-
                                ; ing into the 'ADD_CHAR' subroutine.
  pop  hl                  ;1024; Restore address of the service routine
  jr   in_again            ;1025; and read the next byte.

end_input:
  pop  hl                  ;1027; Drop the address of the service
  jp   unpage_1            ;1028; routine and page-out the +D.

; Enter here to deal with the INKEY$ function (a single character is
; returned).

inkey_dollar:
  pop  hl                  ;102B; Restore address of the service routine
  ld   de,inkey_dollar_end ;102C; Return address is 'INKEY_DOLLAR_END' below.
  push de                  ;102F;
  jp   (hl)                ;1030; Jump to the service routine.

inkey_dollar_end:
  ret  c                   ;1031; Return with acceptable codes or
  ret  z                   ;1032; with no byte read.
  bit  4,(iy+124)          ;1033; Otherwise EOF was reached, so jump to
  jr   z,input_err         ;1037; the error routine except when
                                ; executing a 'MOVE' command.
  or   1                   ;1039; Then return with Zero and Carry flags
  ret                      ;103B; both reset.

; ----------------------------------------------
; THE '"M" CHANNEL INPUT' ROUTINE

; The actual 'input' is handled via 'CALL_INP' above. The service routine is
; 'MCHAN_IN' below.

m_input:
  ld   ix,(23633)          ;103C; Make IX point to start of channel.
  ld   hl,mchan_in         ;1040; Address of the service routine.
  jp   call_inp            ;1043; Jump to the control routine.

; ----------------------------------------------
; THE '"M" CHANNEL INPUT' SERVICE ROUTINE

; This is the actual read a byte from the "M" channel routine. The byte is
; read from the data buffer in the channel, if it is empty the next sector is
; loaded from disk (provided that the 'current' data block is not the EOF one)
; before reading the byte.

mchan_in:
  bit  0,(ix+24)           ;1046; Jump to the 'hook code' error routine
  jp   nz,md_error         ;104A; if (CHFLAG) indicates 'read' file.
test_m_buf:
  ld   e,(ix+11)           ;104D; Fetch current byte counter from
  ld   d,(ix+12)           ;1050; (CHBYTE).
  ld   l,(ix+69)           ;1053; Fetch record length from (RECLEN).
  ld   h,(ix+70)           ;1056;
  scf                      ;1059; Include byte to be read.
  sbc  hl,de               ;105A;
  jr   c,chk_m_eof         ;105C; Jump if all bytes have been read.
  inc  de                  ;105E; Include byte to be read in the byte
                                ; counter.
  ld   (ix+11),e           ;105F; And store it.
  ld   (ix+12),d           ;1062;
  dec  de                  ;1065; Position of character to be read.
  push ix                  ;1066; Save start address of channel.
  add  ix,de               ;1068; IX now points to 'byte to be
                                ; read - 82'.
  ld   a,(ix+82)           ;106A; Fetch the byte.
  pop  ix                  ;106D; Restore start of channel.
  scf                      ;106F; Signal 'acceptable code'.
  ret                      ;1070; Finished.

; If all bytes in the data block have been read, a check is made to see if it
; is the 'end of file' block, i.e. the last one.

chk_m_eof:
  bit  1,(ix+67)           ;1071; Jump if (RECFLG) indicates 'not the
  jr   z,new_buff          ;1075; End Of File' block.
  xor  a                   ;1077; Otherwise Zero and Carry flag are
                                ; reset to signal 'EOF'.
  add  a,13                ;1078; Returned byte is CHR$ 13, i.e. ENTER.
  ret                      ;107A; Finished.

; A new data block is now read from the disk drive.

new_buff:
  ld   de,0                ;107B; Clear the byte counter.
  ld   (ix+11),e           ;107E;
  ld   (ix+12),d           ;1081;
  inc  (ix+13)             ;1084; Increment (CHREC), i.e. record number.
  call get_recd            ;1087; Fetch a new data block.
  jr   test_m_buf          ;108A; Read the byte.

; ----------------------------------------------
; THE 'GET A RECORD' SUBROUTINE

; This subroutine is used to load a record of a 'MICRODRIVE'-type file.

get_recd:
  ld   c,3                 ;108C; Three retries will be made before the
                                ; routine is exitted when an error
                                ; occurs.
  bit  1,(ix+67)           ;108E;
  jr   nz,get_r3           ;1092; Jump if (RECFLG) indicates 'EOF' block
get_r1:
  push ix                  ;1094; Store channel pointer (in 'main' RAM).
  ld   de,540              ;1096; Microdrive file records have 540 bytes
                                ; each.
get_r2:
  push ix                  ;1099; Store data buffer pointer.
  ld   ix,dfca             ;109B;
  call lbyt                ;109F; Fetch a byte.
  pop  ix                  ;10A2; Restore data buffer pointer.
  ld   (ix+55),a           ;10A4; Loading starts with the data block
                                ; preamble (offset 55).
  inc  ix                  ;10A7;
  call dec_de              ;10A9; Decrement DE.
  jr   nz,get_r2           ;10AC; Repeat until DE=0.
  pop  ix                  ;10AE; Restore channel pointer.
  ld   a,(ix+68)           ;10B0; Fetch number of this record (RECNUM).
  cp   (ix+13)             ;10B3; Test it against wanted record number
  ret  z                   ;10B6; (CHREC), exit if they are equal.
  bit  1,(ix+67)           ;10B7; Jump to load the next record if
  jr   z,get_r1            ;10BB; (RECFLG) indicates that this isn't the
                                ; EOF one.
get_r3:
  dec  c                   ;10BD; Decrement retry counter.
  jr   z,md_error1         ;10BE; Exit via the 'hook code' error routine
                                ; when three retries have been made.

; Now the routine reloads the first sector of the file. With 'MICRODRIVE'-type
; files it is possible to have a 'read' channel attached to a file to which is
; also a 'write' channel attached. So the last record could have been read
; into the 'read' channels data buffer after which a new record was added by
; the 'write' channel. The reason why three retries are made is probably
; because of the ignoring of errors, signalled by a set Carry flag (remember
; this is a 'hook code' executing), reported by 'LBYT' and 'RSAD'. The routine
; does some retrying before quitting.

  push hl                  ;10C0; Store the registers needed by the
  push ix                  ;10C1; routine above.
  push bc                  ;10C3;
  ld   a,(ix+25)           ;10C4; Fetch the drive number from CHDRIV.
  call sel_drive           ;10C7; Select the drive.
  ld   de,14               ;10CA; Make IX point to CHNAME, the name of
  add  ix,de               ;10CD; the requested file.
  call find_file_1146      ;10CF; Search for the filename.
  jr   nz,md_error1        ;10D2; Jump if not found.
  inc  hl                  ;10D4; Skip 'number of sectors used'.
  inc  hl                  ;10D5;
  ld   d,(hl)              ;10D6; Fetch first track and sector.
  inc  hl                  ;10D7;
  ld   e,(hl)              ;10D8;
  ld   ix,dfca             ;10D9;
  call rsad                ;10DD; Read the first sector.
  pop  bc                  ;10E0; Restore registers.
  pop  ix                  ;10E1;
  pop  hl                  ;10E3;
  jr   get_r1              ;10E4; Try to find the right record again.

; ----------------------------------------------
; THE 'JUMP TO ERROR ROUTINE'

; Because this jump is only two times 'jump relatived to', it wastes one byte.

md_error1:
  jp   md_error            ;10E6; Jump to the 'hook code' error routine.

; ----------------------------------------------
; THE '"M" CHANNEL DATA' TABLE

; The '25' bytes that compose the initial part of an "M" channel are as
; follows:

mchan_data:
  defw $0008               ;10E9; Main ROM 'output' routine.
  defw $0008               ;10EB; Main ROM 'input' routine.
  defb "M"+128             ;10ED; Channel specifier.
  defw mchan_out           ;10EE; +D ROM 'output' routine.
  defw m_input             ;10F0; +D ROM 'input' routine.
  defw 595                 ;10F2; Channel length.
  defw $0000               ;10F4; Default for CHBYTE.
  defb $00                 ;10F6; Default for CHREC.
  defm "          "        ;10F7; Default for CHNAME (10 spaces).
  defb $FF                 ;1101; Default for CHFLAG ('write' channel).

; ----------------------------------------------
; THE 'CLOSE FILE' SUBROUTINE

; By using 'hook code' 35 ($23) the following subroutine is called. It CLOSEs
; an "M" channel which start adddress is held in the IX register. If the
; channel is used for reading, then it is reclaimed; but if it is used for
; writing, any unsent data in the buffer is written to disk before reclaiming
; the channel.

close_m2:
  bit  0,(ix+24)           ;1102; Jump if (CHFLAG) indicates that this
  jr   z,close_m1          ;1106; is a 'read' channel.
  set  1,(ix+67)           ;1108; Otherwise signal 'EOF record',
  call wr_recd             ;110C; and save it on disk.
  push ix                  ;110F; Save channel pointer.
  ld   ix,dfca             ;1111;
  call cfsm                ;1115; Close the File Sector Map.
  pop  ix                  ;1118; Restore channel pointer.
close_m1:
  call del_m_buf           ;111A; Reclaim the channel.
  ret                      ;111D;

; ----------------------------------------------
; THE 'ERASE' SUBROUTINE

; This subroutine is called using 'hook code' 36 ($24). It deals with the
; ERASEing of all file types. It differs from the +D's ERASE 'command code':
; this routine uses a temporary channel and the IF1's extra system variables
; to ERASE a file. On entry 'D_STR1' must hold the drive number and 'N_STR1'
; the length and the start of the filename.

erase_111E:
  call set_t_mch           ;111E; Create a temporary "M" channel.
  push ix                  ;1121; Store channel pointer.
  ld   de,14               ;1123; Make IX point to CHNAME, the name of
  add  ix,de               ;1126; the file to be ERASEd.
  call find_file_1146      ;1128; Search for the file.
  pop  ix                  ;112B; Restore channel pointer.
  push af                  ;112D; Save flags.
  jr   nz,erase_1          ;112E; Jump if the file wasn't found.
  ld   hl,$3BD6            ;1130; Point to the start of the disk buffer.
  add  hl,bc               ;1133; BC holds the directory entries offset
                                ; (i.e. 0 for first, 256 for second).
  ld   (hl),0              ;1134; Signal 'ERASEd file'.
  push ix                  ;1136; Store channel pointer.
  ld   ix,dfca             ;1138;
  call wsad                ;113C; Write sector DE.
  pop  ix                  ;113F; Restore channel pointer.
erase_1:
  call del_m_buf           ;1141; Reclaim the channel.
  pop  af                  ;1144; Exit with Zero reset indicating 'file
  ret                      ;1145; not found'.

; ----------------------------------------------
; THE 'FIND A FILE' SUBROUTINE

; This routine searches the disk CATalogue for the filename pointed to by the
; IX register.  On exit, Zero reset signals 'file not found'.

find_file_1146:
  ; XXX FIXME -- the original HTML defines `find_file` twice
  call rest                ;1146; Reset drive to track 0.
  ld   (dfca.buflen),ix    ;1149; Store the pointer to filename
                                ; requested.
find_f1:
  ld   ix,dfca             ;114D;
  call rsad                ;1151; Load a sector to the disk buffer.
  ld   bc,0                ;1154; First entry's offset.
find_f2:
  ld   hl,$3BD6            ;1157; Point to the start of the disk buffer.
  add  hl,bc               ;115A; Point to directory entry.
  ld   a,(hl)              ;115B;
  cp   0                   ;115C;
  jr   z,find_f4           ;115E; Jump if the file is ERASEd.
  inc  hl                  ;1160; Point to the filename.
  ld   ix,(dfca.buflen)    ;1161; Fetch pointer to filename requested.
  ld   a,10                ;1165; Length of filename.
  ld   ($3DF3),a           ;1167;
find_f3:
  ld   a,(ix+0)            ;116A; Fetch a byte from requested name.
  xor  (hl)                ;116D; Compare against found name.
  and  $DF                 ;116E; Capitalize.
  jr   nz,find_f4          ;1170; Jump if they don't match.
  inc  ix                  ;1172; Next characters.
  inc  hl                  ;1174;
  ld   a,($3DF3)           ;1175;
  dec  a                   ;1178;
  ld   ($3DF3),a           ;1179;
  jr   nz,find_f3          ;117C; Repeat for all characters in the name.
  ret                      ;117E; Return with Zero set to indicate 'file
                                ; found'.

; The requested filename wasn't found yet, so examine the next file.

find_f4:
  ld   a,b                 ;117F;
  cp   1                   ;1180;
  jr   z,find_f5           ;1182; Jump if second entry handled.
  ld   a,(control_port_status) ;1184;
  and  $04                 ;1187; Jump if using single density, i.e.
  jr   nz,find_f5          ;1189; each sector holds one entry.
  ld   bc,256              ;118B; Otherwise examine second entry.
  jr   find_f2             ;118E;

; The next CATalogue sector has to be loaded, if present.

find_f5:
  inc  e                   ;1190; Next sector.
  ld   a,e                 ;1191;
  cp   11                  ;1192; Jump if last sector on current track
  jr   nz,find_f1          ;1194; hasn't been loaded yet.
  ld   e,1                 ;1196; Otherwise start with sector 1
  inc  d                   ;1198; on the next track.
  ld   a,d                 ;1199;
  cp   4                   ;119A; Jump if last track in CATalogue hasn't
  jr   nz,find_f1          ;119C; been handled yet.
  cp   0                   ;119E; Otherwise reset Zero flag to signal
  ret                      ;11A0; 'file not found' and exit.

; ----------------------------------------------
; THE 'READ SEQUENTIAL' SUBROUTINE

; This is called by using 'hook code' 37 ($25). The subroutine reads into the
; data block of the current "M" channel, the next record of a named PRINT-type
; file. On entry IX must hold the "M" channel start address, and CHREC the
; number of the current record.  CHREC will be automatically incremented.
; CHDRIV must hold the drive number and CHNAME must hold the filename.

read_seq:
  bit  1,(ix+67)           ;11A1; Jump if (RECFLG) indicates that the
  jr   z,increc            ;11A5; current record isn't the EOF one.
  jp   md_error            ;11A7; Otherwise exit via the 'hook code'
                                ; error routine.
increc:
  inc  (ix+13)             ;11AA; Increment the record number (CHREC)
                                ; and continue into 'RD_RANDOM'.

; ----------------------------------------------
; THE 'READ RANDOM' SUBROUTINE

; This subroutine is called by using 'hook code' 39 ($27). The record number
; CHREC of a PRINT-type file is loaded into the data block. The other
; variables are to be set as for 'READ_SEQ' above.

rd_random:
  call get_recd            ;11AD; Load CHREC record.
  bit  2,(ix+67)           ;11B0; Return only if (RECFLG) indicates that
  ret  z                   ;11B4; it is a PRINT-type file.
  call del_m_buf           ;11B5; Otherwise reclaim the channel and exit
  jp   md_error            ;11B8; via the 'hook code' error routine.

; ----------------------------------------------
; THE '"M" CHANNEL OUTPUT' ROUTINE

; This routine handles the "M" channel output. The byte stored in the A
; register is stored into the 512-byte buffer. When it is filled, the record
; is written onto disk.

mchan_out:
  ld   ix,$FFFA            ;11BB; This is -6.
  add  ix,de               ;11BF; Point to the start of the channel.
  bit  0,(ix+24)           ;11C1; Continue only if (CHFLAG) indicates
  jp   z,md_error          ;11C5; that this is a 'write' file.
  ld   e,(ix+11)           ;11C8; Fetch the byte pointer (CHBYTE).
  ld   d,(ix+12)           ;11CB;
  push ix                  ;11CE; Save start address of channel.
  add  ix,de               ;11D0; Point to 'first free byte in
                                ; buffer'-82.
  ld   (ix+82),a           ;11D2; Store the byte into the buffer.
  pop  ix                  ;11D5; Restore start of channel.
  inc  de                  ;11D7; Update (CHBYTE).
  ld   (ix+11),e           ;11D8;
  ld   (ix+12),d           ;11DB;
  bit  1,d                 ;11DE; Return if the buffer is not filled
  ret  z                   ;11E0; (position 512 has not been reached).

; If the buffer is filled, the routine continues into 'WR_RECD' below.

; ----------------------------------------------
; THE 'WRITE RECORD' SUBROUTINE

; This subroutine is called by using 'hook code' 38 ($26). The record held in
; the "M" channel pointed by the IX register (with name CHNAME and number
; CHREC), is written onto the disk inserted into drive CHDRIV.

wr_recd:
  ld   a,(ix+25)           ;11E1; Fetch the drive number (CHDRIV).
  call sel_drive           ;11E4; Select the drive.
  push ix                  ;11E7; Save start address of channel.
  ld   b,10                ;11E9; Counts ten characters.
cp_name:
  ld   a,(ix+14)           ;11EB; Copy CHNAME into RECNAM.
  ld   (ix+71),a           ;11EE;
  inc  ix                  ;11F1;
  djnz cp_name             ;11F3;
  pop  ix                  ;11F5; Restore start of channel.
  ld   c,(ix+11)           ;11F7; Copy CHBYTE into RECLEN.
  ld   (ix+69),c           ;11FA;
  ld   a,(ix+12)           ;11FD;
  ld   (ix+70),a           ;1200;
  ld   a,(ix+13)           ;1203; Copy CHREC into RECNUM.
  ld   (ix+68),a           ;1206;
  push ix                  ;1209; Make HL point to the start of the data
  pop  hl                  ;120B; workspace,
  ld   de,67               ;120C; i.e. RECFLG.
  add  hl,de               ;120F;
  call chks_hd_r           ;1210; Calculate DESCHK checksum.
  ld   de,15               ;1213; Make HL point to the start of the
  add  hl,de               ;1216; 512-byte buffer.
  call chks_buf            ;1217; Calculate DCHK checksum.
  call save_recd           ;121A; Save the record to disk.
  ld   de,0                ;121D; Clear CHBYTE.
  ld   (ix+11),e           ;1220;
  ld   (ix+12),d           ;1223;
  inc  (ix+13)             ;1226; Increment the record number (CHREC).
  ret                      ;1229; Finished.

; ----------------------------------------------
; THE 'CALCULATE/COMPARE CHECKSUM' ROUTINE

; This routine is used to calculate DESCHK and DCHK checksums, or to compare
; the previous checksum against the current one; the Zero flag is returned set
; if the checksums match.  The entry point is CHK_HD_R for DESCHK, or
; CHKS_BUFF for DCHK checksum. On entry in both cases HL must contain the
; start address of the block for which the checksum is to be obtained.

chks_hd_r:
  ld   bc,14               ;122A; The block length.
  jr   chks_all            ;122D; Calculate checksum for the block.

chks_buf:
  ld   bc,512              ;122F; The block length.
chks_all:
  push hl                  ;1232; The start address is preserved.
  ld   e,0                 ;1233; Clear checksum.
chks_1:
  ld   a,e                 ;1235; Add the current byte to the previous
  add  a,(hl)              ;1236; sum.
  inc  hl                  ;1237; Point to next location.
  adc  a,1                 ;1238; Include also the carry + 1.
  jr   z,chks_2            ;123A; Jump if A reaches zero.
  dec  a                   ;123C; Otherwise balance the 'ADC' above.
chks_2:
  ld   e,a                 ;123D; Update sum.
  dec  bc                  ;123E; One byte less to add.
  ld   a,b                 ;123F;
  or   c                   ;1240;
  jr   nz,chks_1           ;1241; Repeat until all bytes have been added
  ld   a,e                 ;1243;
  cp   (hl)                ;1244; Compare with previous checksum.
  ld   (hl),a              ;1245; Store the new one.
  pop  hl                  ;1246; Restore start address.
  ret                      ;1247; Finished.

; ----------------------------------------------
; THE 'SAVE A RECORD' SUBROUTINE

; This subroutine saves the 540 byte Microdrive-file record to disk.

save_recd:
  push ix                  ;1248; Save the channel pointer.
  push ix                  ;124A;
  pop  hl                  ;124C; Calculate the address of the first
  ld   de,55               ;124D; byte to SAVE, i.e. the data block
  add  hl,de               ;1250; preamble (offset 55).
  ld   de,540              ;1251; Length of the record to be written.
  ld   ix,dfca             ;1254;
save_rec1:
  ld   a,(hl)              ;1258; Fetch a byte.
  call sbyt                ;1259; Save it to disk.
  inc  hl                  ;125C;
  call dec_de              ;125D; Decrement DE.
  jr   nz,save_rec1        ;1260; Repeat until DE=0.
  pop  ix                  ;1262; Restore the channel pointer.
  ret                      ;1264; Finished.

; ----------------------------------------------
; THE 'DECREMENT DE' SUBROUTINE

; This very small subroutine decrements DE and returns with the Zero flag
; indicating if DE holds zero on exit. The purpose of this three-byte
; subroutine is unclear, it doesn't save a single byte (a CALL instruction
; takes also three bytes so this subroutine makes the code only longer), and
; the readability of the code (or the source) doesn't improve really.

dec_de:
  dec  de                  ;1265; DE=DE-1.
  ld   a,d                 ;1266;
  or   e                   ;1267; Set Zero flag if DE=0.
  ret                      ;1268; Finished.

; ----------------------------------------------
; THE 'READ SECTOR' SUBROUTINE

; This subroutine is not implemented, it is called by using 'hook code' 40
; ($28).  When used with an IF1 the sector, which number is held in CHREC, is
; read into the channel area. If the sector doesn't belong to a PRINT-type
; file the data buffer is cleared before returning. On entry the required
; drive motor has to be turned on.

rd_sector:
  ret                      ;1269;

; ----------------------------------------------
; THE 'READ NEXT SECTOR' SUBROUTINE

; This subroutine called by using 'hook code' 41 ($29) isn't implemented
; either.  It should load into the channel area the first header and data
; block that pass through the Microdrive head. The required drive motor has to
; be started before calling this routine.

rd_next:
  ret                      ;126A;

; ----------------------------------------------
; THE 'WRITE SECTOR' SUBROUTINE

; Another unimplemented subroutine, called by using 'hook code' 42 ($2A) it
; writes the data block in the current channel (pointed to by IX) to the
; sector specified by CHREC.  The required Microdrive has to be started and
; all channel variables, such as CHNAME, are to be set as required before
; calling the routine.

wr_sector:
  ret                      ;126B;

; ----------------------------------------------
; THE 'RECLAIM "M" CHANNEL' SUBROUTINE

; This subroutine (also called by using 'hook code' 44 ($2C)) is used to
; reclaim the "M" channel pointed by the IX register. Unlike the IF1 routine
; this routine neither closes the stream(s) attached to this channel, nor
; updates the stream data for channels moved down after the reclaiming.

del_m_buf:
  push ix                  ;126C; Make HL point to the start of the
  pop  hl                  ;126E; channel.
  ld   bc,595              ;126F; Length of the channel.
  rst  calbas              ;1272; Delete the channel area by calling
  defw rom_reclaim_2       ;1273; 'RECLAIM_2' in the 'main' ROM.
  ret                      ;1275; Finished.

; ----------------------------------------------
; THE 'OPEN TEMP. "N" CHANNEL' SUBROUTINE

; The +D doesn't support the use of "N" channels, temporary or permanent, by
; the user.  This routine is called by using 'hook code' 45 ($2D).

op_temp_n:
  ret                      ;1276;

; ----------------------------------------------
; THE 'CLOSE NETWORK CHANNEL' SUBROUTINE

; Because the +D doesn't support "N" channels, the CLOSEing of them isn't
; supported either ('hook code' 46 ($2E)).

close_net:
  ret                      ;1277;

; ----------------------------------------------
; THE 'GET PACKET FROM NETWORK' SUBROUTINE

; Called by using 'hook code' 47 ($2F), this subroutine to fetch a header and
; data block from the network isn't implemented.

get_pack:
  ret                      ;1278;

; ----------------------------------------------
; THE 'SEND PACKET' SUBROUTINE

; The +D doesn't support the sending of a header and data block over the
; network ('hook code' 48 ($30)).

send_pack:
  ret                      ;1279;

; ----------------------------------------------
; THE 'CREATE IF1 VARIABLES' SUBROUTINE

; This subroutine (called by using 'hook code' 49 ($31)) has the task of
; creating the IF1's new system variables if nonexistent. Many variables are
; initialised to their default values.

hook_31:
  ld   hl,(23631)          ;127A; Fetch start of channel area (CHANS).
  ld   de,$A349            ;127D; This is -23735.
  add  hl,de               ;1280; The Carry flag is now set if the CHANS
                                ; area starts after address 23734, i.e.
                                ; the 'new' variables exist already.
  jr   c,var_exist         ;1281; Jump if they exist already.
  ld   hl,(23651)          ;1283; Clear the calculator stack by copying
  ld   (23653),hl          ;1286; (STKBOT) into (STKEND).
  ld   hl,23698            ;1289; Set (MEM) with the address of the
  ld   (23656),hl          ;128C; MEMBOT area.
  ld   hl,23733            ;128F; One location before the new space is
                                ; needed.
  ld   bc,58               ;1292; There are 58 new variables.
  rst  calbas              ;1295; Use 'main' ROM 'MAKE_ROOM' to create
  defw rom_make_room       ;1296; the space.
  ; XXX FIXME -- the original HTML has a typo in the ROM label above
  ld   hl,if1_vars         ;1297; Address of 'default values' table.
  ld   bc,19               ;129B; There are 19 default values.
  ld   de,23734            ;129E; Start of 'new' variables area.
  ldir                     ;12A1; Store default values.
  ld   a,1                 ;12A3; Set (COPIES) to 1.
  ld   (23791),a           ;12A5;
  ret                      ;12A8; Finished.

var_exist:
  res  1,(iy+124)          ;12A9; Signal 'new variables already exist'.
  ret                      ;12AD;

; ----------------------------------------------
; THE 'SYSTEM VARS DEFAULT VALUES' TABLE

; This table contains the default values of all the 'new' IF1 system variables
; from FLAGS3 to SER_FL.

if1_vars:
  defb $02                 ;12AE; Default for FLAGS3 (bit 1 is set to
                                ; signal that the shadow ROM has been
                                ; paged in for the first time).
  defw $01F0               ;12AF; Default for VECTOR is the IF1's
                                ; 'ERR_6' address (nonsense for +D).
  ld   hl,$0000            ;12B1; This short subroutine is used to call
  call $0000               ;12B4; 'main' ROM routines from the IF1 ROM,
  ld   (23738),hl          ;12B7; it isn't used with the +D.
  ret                      ;12BA;
  defw $000C               ;12BB; Default for BAUD, i.e. 9600 baud.
  defb $01                 ;12BD; Default for NSTAT.
  defb $00                 ;12BE; Default for IOBORD, the colour during
                                ; IF1 I/O (black).
  defw $0000               ;12BF; Default for SER_FL.

; ----------------------------------------------
; THE 'CALL IF1 SUBROUTINE' SUBROUTINE

; This subroutine, called by using 'hook code' 50 ($32), is designed to call
; IF1 ROM-routines when the 'main' ROM is paged in. The difference with IF1 is
; that the +D uses DE to pass the address to be called.

hook_32:
  ex   de,hl               ;12C1;
  jp   (hl)                ;12C2;

; ----------------------------------------------
; THE 'HOOK CODE ERROR' ROUTINE

; Whenever an error is encountered in the 'hook code' routines a jump is made
; here to signal the error and clear the machine stack when necessary.

md_error:
  call bord_rest           ;12C3; Restore the border colour.
  ld   hl,(d_err_sp)       ;12C6;
  ld   a,h                 ;12C9;
  or   l                   ;12CA;
  jr   z,md_err1           ;12CB; Jump if the stack isn't to be cleared.
  ld   sp,hl               ;12CD; Otherwise clear the stack.
md_err1:
  xor  a                   ;12CE;
  dec  a                   ;12CF;
  scf                      ;12D0; Exit with A holding 255 and Carry flag
  ret                      ;12D1; set.


; ===============================================================
; The Printer routines

; ----------------------------------------------
; THE 'NORMAL SCREENDUMP' SUBROUTINE

; This routine dumps a normal screendump to the printer. It can be called also
; by using command code 58 ($3A).

cops:
  call system_z            ;12D2; If a system file has been loaded
  call z,jcops             ;12D5; call its screendump routine.
  ld   hl,16384            ;12D8; Start of screen.
  ld   de,n_per_72_lspc    ;12DB; Print the escape sequence for n/72 inch
  call po_esc_seq          ;12DE; line feeds.
  ld   a,8                 ;12E1; Make it 8/72.
  call pntp                ;12E3;
c1_line:
  ld   de,graph_dpi        ;12E6; Print the escape sequence for a normal
  call po_esc_seq          ;12E9; screendump. (60 dpi)
  ld   a,0                 ;12EC; Signal '256 dot columns will follow'
  call pntp                ;12EE; to the printer.
  ld   a,1                 ;12F1;
  call pntp                ;12F3;
  push hl                  ;12F6;
c1_char:
  ld   b,8                 ;12F7; Eight pixels in each byte.
c1_pixel:
  push hl                  ;12F9;
c1_pixrow:
  call pixel_col           ;12FA; Get pixel colour.
  and  $04                 ;12FD;
  jr   nz,c1_adddot        ;12FF; Jump with colour codes 4-7 (no dot).
  scf                      ;1301; Set a dot for colour codes 0-3.
c1_adddot:
  ld   a,($3E4F)           ;1302; Incorporate one dot in dot column.
  rla                      ;1305;
  ld   ($3E4F),a           ;1306;
  inc  h                   ;1309; Next pixel row.
  ld   a,h                 ;130A;
  and  $07                 ;130B;
  jr   nz,c1_pixrow        ;130D; Repeat until all eight pixelrows have
                                ; been 'scanned'.
  ld   a,($3E4F)           ;130F;
  call pntp                ;1312; Print the dot column.
  pop  hl                  ;1315; Repeat until all eight pixels in a byte
  djnz c1_pixel            ;1316; have been printed. One character cell
                                ; (64 pixels) has been printed now.
  inc  l                   ;1318; Next character position.
  ld   a,l                 ;1319;
  and  $1F                 ;131A;
  jr   nz,c1_char          ;131C; Loop for all 32 character columns.
  call adv_paper           ;131E; Advance printer paper one line.
  pop  hl                  ;1321;
  ld   a,h                 ;1322; Make HL point to the next screen third
  add  a,8                 ;1323; 'N_CHARROW' will adjust HL if
  ld   h,a                 ;1325; necessary.
  call n_charrow           ;1326; Calculate the address of the next
  jr   nz,c1_line          ;1329; characterrow and loop until end of
                                ; pixel area reached.
  jp   dump_exit           ;132B; Exit via 'DUMP_EXIT' to reset printer.

; ----------------------------------------------
; THE 'ADVANCE PRINTER PAPER' SUBROUTINE

; This subroutine advances the paper by sending a CR (carriage return) and
; (when needed) a LF (line feed) to the printer.

adv_paper:
  ld   a,13                ;132E; Send a CR to the printer.
  call pntp                ;1330;
  ld   a,(lfeed)           ;1333; This is 'LFEED'.
  and  a                   ;1336;
  ret  z                   ;1337; Return if no LF has to be printed.
  ld   a,10                ;1338; Otherwise send a LF.
  call pntp                ;133A;
  ret                      ;133D; Finished.

; ----------------------------------------------
; THE 'GREYSCALE SCREENDUMP' SUBROUTINE

; This routine prints a large screendump. It can also be called by using
; command code 66 ($42).

cops2:
  call system_z            ;133E; If a system file has been loaded
  call z,jcops2            ;1341; call its screendump routine.
  ld   hl,$57E0            ;1344; Address of the lowest pixelrow of the
                                ; charactersquare in bottom left corner.
  ld   de,n_per_72_lspc    ;1347; Print the escape sequence for n/72
  call po_esc_seq          ;134A; inch line feeds.
  ld   a,6                 ;134D; Make it 6/72.
  call pntp                ;134F;
  ld   b,128               ;1352; There are 128 2-pixel columns.
  ld   c,8                 ;1354; 8 pixels make one byte. Start with
                                ; leftmost bit in a byte.
c2_2pixcol:
  push bc                  ;1356;
  push hl                  ;1357;
  ld   de,grey_bitim       ;1358; Print the escape sequence for the
  call po_esc_seq          ;135B; greyscale bitimage mode.
  ld   b,24                ;135E; There are 24 characterrows.
c2_scrrow:
  push bc                  ;1360;
  push hl                  ;1361;
  ld   b,8                 ;1362; A character has 8 pixelrows.
c2_pixrow:
  push bc                  ;1364;
  push hl                  ;1365;
  ld   de,$3BD6            ;1366; Clear the buffer for the 2 pixels.
  ld   b,3                 ;1369;
c2_clrbuf:
  xor  a                   ;136B;
  ld   (de),a              ;136C;
  inc  de                  ;136D;
  djnz c2_clrbuf           ;136E;
  ld   b,2                 ;1370; The dot columns for 2 pixels are build
                                ; up each time.
c2_2pix:
  push bc                  ;1372;
  push hl                  ;1373;
  ld   b,c                 ;1374;
  call pixel_col           ;1375; Get the colour of the (B-1)th pixel.
  and  $07                 ;1378; Keep only the least significant 3 bits
  inc  a                   ;137A; Make the range 1..8.
  ld   b,a                 ;137B;
  ld   c,0                 ;137C; Set the bit in the C register which
  scf                      ;137E; corresponds to the colour.
c2_mk_mask:
  rl   c                   ;137F;
  djnz c2_mk_mask          ;1381;
  ld   de,greyscale        ;1383; DE points to the 'GREYSCALE' table.
  ld   hl,$3BD6            ;1386; HL points to the 2-pixel buffer.
  ld   b,3                 ;1389; Each pixel is printed as 3*3 dots.
c2_dotcol:
  push bc                  ;138B;
  ld   b,3                 ;138C;
c2_dotrow:
  ld   a,(de)              ;138E; Get colour pattern.
  and  c                   ;138F; Only keep the bit with the right
  ld   a,(hl)              ;1390; colour.
  jr   z,c2_add_dot        ;1391; Jump if bit isn't set.
  scf                      ;1393; Otherwise set this dot.
c2_add_dot:
  rl   a                   ;1394; Incorporate this dot.
  ld   (hl),a              ;1396;
  inc  de                  ;1397; Next entry in 'GREYSCALE' table.
  djnz c2_dotrow           ;1398; Repeat for 3 dotrows.
  inc  hl                  ;139A;
  pop  bc                  ;139B;
  djnz c2_dotcol           ;139C; Repeat for 3 dotcolumns.
  pop  hl                  ;139E;
  pop  bc                  ;139F;
  dec  c                   ;13A0; Next pixel.
  djnz c2_2pix             ;13A1; Two pixels are handled at a time.
  ld   b,3                 ;13A3; Three dotcolumns are to be printed.
  ld   hl,$3BD6            ;13A5;
c2_prt3x3:
  ld   a,(hl)              ;13A8; Print each dotcolumn in turn.
  call pntp                ;13A9;
  inc  hl                  ;13AC;
  djnz c2_prt3x3           ;13AD; Repeat for all three.
  pop  hl                  ;13AF;
  dec  h                   ;13B0; Next pixelrow.
  pop  bc                  ;13B1; Repeat for the eight pixelrows in a
  djnz c2_pixrow           ;13B2; character square.
  pop  hl                  ;13B4;
  ld   a,l                 ;13B5; One character row up.
  sub  32                  ;13B6;
  ld   l,a                 ;13B8;
  jr   nc,c2_chrrow        ;13B9; Jump if still within the same third.
  ld   a,h                 ;13BB; Otherwise update MSB of address.
  sub  8                   ;13BC;
  ld   h,a                 ;13BE;
c2_chrrow:
  pop  bc                  ;13BF;
  djnz c2_scrrow           ;13C0; Repeat for the 24 rows on the screen.
  call adv_paper           ;13C2; Advance the paper.
  pop  hl                  ;13C5;
  pop  bc                  ;13C6;
  dec  c                   ;13C7; Skip the two pixels which have already
  dec  c                   ;13C8; been printed.
  jr   nz,c2_byte          ;13C9; Jump if not all pixels within this
                                ; byte have been printed.
  ld   c,8                 ;13CB; Otherwise reset 'pixels in a byte'
  inc  hl                  ;13CD; counter and point to the next
                                ; character position to the right.
c2_byte:
  djnz c2_2pixcol          ;13CE; Repeat for the 128 2-pixelcolumns.
  ld   b,4                 ;13D0; Advance the paper for four lines.
c2_advpap:
  call adv_paper           ;13D2;
  djnz c2_advpap           ;13D5;
dump_exit:
  ld   de,n_per_72_lspc    ;13D7; Print the escape sequence for n/72 inch
  call po_esc_seq          ;13DA; line feeds.
  ld   a,(lspce)           ;13DD; Make it (lspce)/72.
  jp   pntp                ;13E0; Exit via 'PNTP'.

; ----------------------------------------------
; THE 'PIXEL COLOUR' SUBROUTINE

; This routine returns with the low 3 bits of the A register holding the
; colour of the Bth pixel from address HL (i.e. the paper colour for an 'off'
; pixel and the ink colour for an 'on' pixel).

pixel_col:
  push hl                  ;13E3; Save address of current 8-pixels.
  push bc                  ;13E4; Save pixel number (range 1..8).
  xor  a                   ;13E5;
  scf                      ;13E6;
pixel_col1:
  rla                      ;13E7; Now set (B-1)th bit of A (range 0..7).
  djnz pixel_col1          ;13E8;
  and  (hl)                ;13EA; Zero flag now reflects state of pixel
  push af                  ;13EB; (i.e. set means pixel set).
  ld   a,h                 ;13EC; Calculate attribute address.
  rrca                     ;13ED;
  rrca                     ;13EE;
  rrca                     ;13EF;
  and  $03                 ;13F0;
  or   $58                 ;13F2;
  ld   h,a                 ;13F4;
  pop  af                  ;13F5;
  ld   a,(hl)              ;13F6; Fetch the attribute.
  pop  bc                  ;13F7;
  pop  hl                  ;13F8;
  ret  nz                  ;13F9; Return if ink colour is to be used.
  rrca                     ;13FA; Otherwise move paper colour
  rrca                     ;13FB; to the lower three bits.
  rrca                     ;13FC;
  ret                      ;13FD;

; ----------------------------------------------
; THE 'NEXT CHAR. ROW ADDRESS' SUBROUTINE

; This subroutine calculates the address of the next characterrow, if the end
; of the pixel area is reached a return with Zero set will be made.

n_charrow:
  ld   a,l                 ;13FE; Update low address byte to next
                                ; character row.
  add  a,32                ;13FF; The carry will be reset within display
  ld   l,a                 ;1401; thirds.
  ccf                      ;1402; Invert carry.
  sbc  a,a                 ;1403; A holds $FF within same third, 0 else.
  and  $F8                 ;1404; A will hold $F8 (i.e. -8) within a
  add  a,h                 ;1406; third, but 0 when a new third is
  ld   h,a                 ;1407; reached. Update high byte (which was
                                ; already incremented by 8).
  cp   $58                 ;1408; Return with the Zero flag set if
  ret                      ;140A; attributes reached.

; ----------------------------------------------
; THE 'PRINT ESCAPE SEQUENCE' SUBROUTINE

; This subroutine is used to send escape sequences to the printer. The start
; of the sequence is held in the DE register, a sequence ends with a CHR$ 128.

po_esc_seq:
  ld   a,(de)              ;140B; Fetch a code.
  cp   128                 ;140C;
  ret  z                   ;140E; Exit if it's 128.
  call pntp                ;140F; Otherwise send it to the printer.
  inc  de                  ;1412; Continue until the sequence is
  jr   po_esc_seq          ;1413; finished.

; ----------------------------------------------
; THE '"P" CHANNEL OUTPUT' ROUTINE

; This routine handles the +D's "P" channel, the @6 system variable (PCODE)
; signals if it's to be handled as a "t" or a "b" channel. (As with the Opus
; Discovery and the ZX Interface 1.)

pchan_out:
  call system_z            ;1415; If the system file is loaded call the
  call z,jpchan            ;1418; alternative routine.
  ld   a,($2006)           ;141B; This is PCODE.
  and  a                   ;141E;
  ld   a,($3E4F)           ;141F; Fetch the code to be send to the
  jp   nz,pntp             ;1422; printer, send it right away if
                                ; (PCODE)=1, i.e. when the +D
                                ; mustn't interfere.
  ld   hl,(output_p_routine) ;1425; Jump to the appropriate 'output'
  jp   (hl)                ;1428; routine.

; This is the normal 'output' routine, but a few (control) characters are
; followed by one or two operands, these have to be handled different. This is
; done by altering the 'output' routine address.

p_all:
  ld   hl,width            ;1429; This is 'WIDTH'.
  cp   32                  ;142C;
  jp   nc,p_noctrl         ;142E; Jump if not a control code (>=32).
  cp   6                   ;1431; This is the "PRINT comma" code.
  jp   c,p_escape          ;1433; Jump with codes < 6.
  jr   nz,p_nocomma        ;1436; Jump with codes > 6.
  ld   a,(hl)              ;1438; Fetch the number of characters per
  srl  a                   ;1439; line, divide it by two.
  ld   b,a                 ;143B;
  ld   hl,$3E4E            ;143C; $3E4E holds the position on the
                                ; current line (i.e. the number of
                                ; characters already printed on this
  sub  (hl)                ;143F; line).
  jr   c,p_newline         ;1440; Jump if already on 2nd half of line.
  ld   h,b                 ;1442; Otherwise jump with H holding the
  jp   p_tab               ;1443; center position of the line.

p_nocomma:
  cp   8                   ;1446; This is "cursor left" or "backspace".
  jp   c,p_escape          ;1448; Jump with codes < 8.
  jr   nz,p_noback         ;144B; Jump with codes > 8 (examine further).
  ld   hl,$3E4E            ;144D; Get current position.
  ld   a,(hl)              ;1450;
  and  a                   ;1451;
  ret  z                   ;1452; Return if already on leftmost position
  dec  (hl)                ;1453; Otherwise decrement current position.
  ld   a,127               ;1454; This isn't "BACKSPACE", this is
                                ; "DELETE" !
  jp   pntp                ;1456; Print a "DELETE".

p_noback:
  cp   13                  ;1459; This is "ENTER" or "CARRIAGE RETURN".
  jr   c,p_escape          ;145B; Jump with codes < 13.
  jr   nz,p_noenter        ;145D; Jump with codes > 13.
  ld   hl,enter_flag       ;145F; This flag, when set, indicates that a
  bit  1,(hl)              ;1462; newline has already been send to the
                                ; printer. I.e. the previous line was
                                ; full (see $15C0).
  res  1,(hl)              ;1464; Reset the flag.
  ret  nz                  ;1466; Return if this newline has been send
                                ; already.
p_newline:
  ld   hl,enter_flag       ;1467; Signal 'newline has been send'.
  res  1,(hl)              ;146A;
  ld   hl,$3E4E            ;146C;
  ld   (hl),0              ;146F; Set current position to 0.
  ld   a,(lfeed)           ;1471; Fetch (LFEED), the number of line
  and  a                   ;1474; feeds needed after a carriage return.
  jr   z,p_carret          ;1475; Jump if it is 0.
  ld   b,a                 ;1477; Otherwise send the line feeds.
p_lfeed:
  ld   a,10                ;1478; CHR$ 10 is line feed.
  call pntp                ;147A;
  djnz p_lfeed             ;147D; Loop until (LFEED) line feeds send.
p_carret:
  ld   a,13                ;147F; Now send the carriage return.
  call pntp                ;1481;
  ld   a,(lmarg)           ;1484; Fetch (LMARG), that is the left margin
  and  a                   ;1487;
  ret  z                   ;1488; Return if it is 0.
  ld   b,a                 ;1489; Otherwise send (LMARG) spaces.
  ld   (hl),a              ;148A; Adjust current print position.
p_lmarge:
  ld   a,32                ;148B;
  call pntp                ;148D;
  djnz p_lmarge            ;1490; Loop until (LMARG) spaces send.
  ret                      ;1492; Finished.

; Now the control codes with operands are handled. The control codes from INK
; to OVER (16..21) and ESC (27) require a single operand, whereas the control
; characters AT & TAB are required to be followed by two operands. The
; following routines leads to the control character code being stored in
; TVDATA-lo, the first operand in TVDATA-hi or the A register if there is only
; a single operand required, and the second operand in the A register. The ESC
; control code is handled separately, the single operand is send directly to
; the printer.

p_noenter:
  cp   16                  ;1493; This is "INK control".
  jr   c,p_escape          ;1495; Jump with codes < 16.
  cp   24                  ;1497; This is "TAB control"+1.
  jr   nc,p_escape         ;1499; Jump with codes >= 24.
  cp   22                  ;149B; This is "AT control".
  jr   nc,p_2_oper         ;149D; Jump with AT & TAB.
  ld   de,p_cont           ;149F; Otherwise the '"P" channel output'
                                ; routine is to be changed to 'P_CONT'.
p_tv_1:
  ld   (23566),a           ;14A2; Store the control character code in
                                ; (TVDATA-lo).

; The current 'output' routine address is changed temporarily.

p_change:
  ld   hl,output_p_routine ;14A5; HL points to the 'output' routine
  ld   (hl),e              ;14A8; address. Enter the new 'output'
  inc  hl                  ;14A9; routine address and thereby force the
  ld   (hl),d              ;14AA; next character to be considered as an
  ret                      ;14AB; operand.

; Once the operands have been collected the routine continues.

p_cont:
  ld   de,p_all            ;14AC; Restore the original address for
  call p_change            ;14AF; 'P_ALL'.
  ld   hl,(23566)          ;14B2; Fetch the control code and the first
                                ; operand if there are indeed two
                                ; operands (TVDATA).
  ld   d,a                 ;14B5; The 'last' operand and the control
  ld   a,l                 ;14B6; code are moved.
  cp   22                  ;14B7;
  jr   c,p_co_temps        ;14B9; Jump if handling INK to OVER.
  jr   nz,p_tab            ;14BB; Jump if handling TAB.
  jr   p_at                ;14BD; Jump if handling AT.

; The control codes INK to OVER are handled by the 'main' ROM 'CO_TEMP'
; routine.  It is entered with the control code in the A register and the
; parameter in the D register. Note that all changes are to the 'temporary'
; system variables.

p_co_temps:
  ld   hl,rom_co_temp_5    ;14BF; Return via the calling routine to
  ex   (sp),hl             ;14C2; 'CO_TEMP' in the 'main' ROM.
  push hl                  ;14C3;
  ret                      ;14C4;

p_tv_2:
  ld   de,p_cont           ;14C5; Store the first operand in TVDATA-hi
  ld   (23567),a           ;14C8; and change the address of the 'output'
  jr   p_change            ;14CB; routine to 'P_CONT'.

; Enter here when handling the control codes AT & TAB.

p_2_oper:
  ld   de,p_tv_2           ;14CD; The control code will be stored in
  jr   p_tv_1              ;14D0; TVDATA-lo and the address of the
                                ; 'output' routine changed to 'P_TV_2'.

p_escape:
  cp   27                  ;14D2;
  jr   nz,p_quest          ;14D4; Print a '?' if it isn't ESC.
  ld   de,p_esc            ;14D6; Otherwise change the address of the
  jp   p_change            ;14D9; 'output' routine to 'P_ESC'.

; Enter here when handling the ESC control code, the character code following
; the ESC is send directly to the printer.

p_esc:
  ld   de,p_all            ;14DC; Restore the original address for
  call p_change            ;14DF; 'P_ALL'.
  jp   pntp                ;14E2; Send the code following the ESC to the
                                ; printer.

; A question mark is printed whenever an attempt is made to print an
; unprintable character code.

p_quest:
  ld   a,"?"            ;14E5; The character '?'.
  jr   p_noctrl         ;14E7; Send it to the printer.

; Now deal with the TAB control code.

p_tab:
  ld   a,(width)           ;14E9; Fetch (WIDTH), that is the line length
  ld   b,a                 ;14EC;
  ld   a,h                 ;14ED; Fetch the position where to TAB
  sub  b                   ;14EE; (or AT) to.
  jr   c,p_inrange         ;14EF; Jump if position is on this line.
  ld   hl,rom_report_b     ;14F1; Otherwise return to 'REPORT_B' in the
  ex   (sp),hl             ;14F4; 'main' ROM ('Integer out of range').
  push hl                  ;14F5;
  ret                      ;14F6;
p_inrange:
  ld   a,($3E4E)           ;14F7; Fetch current position.
  ld   b,a                 ;14FA;
  ld   a,h                 ;14FB;
  sub  b                   ;14FC;
  push hl                  ;14FD; Print on a new line if print position
  call c,p_newline         ;14FE; exceeds TAB position.
  pop  hl                  ;1501;
  ld   a,($3E4E)           ;1502; Fetch the current position again.
  sub  h                   ;1505; Calculate the number of spaces wanted.
  ret  z                   ;1506; Return if already there.
  cpl                      ;1507; The number is negative so make it
  inc  a                   ;1508; positive.
  ld   b,a                 ;1509; Print the needed spaces.
p_space:
  ld   a,32                ;150A;
  push bc                  ;150C;
  call p_all               ;150D;
  pop  bc                  ;1510;
  djnz p_space             ;1511;
  ret                      ;1513;

; Enter here when handling AT.

p_at:
  ld   h,d                 ;1514; Store the second operand and continue
  jr   p_tab               ;1515; in the TAB routine.

; The 'not control' characters are divided into four groups: the ordinary
; characters, the tokens, the graphics and the user-defined graphics.

p_noctrl:
  cp   128                 ;1517; This is the first graphic.
  jr   c,p_ascii           ;1519; Jump with ASCII characters (< 128).
  cp   144                 ;151B; This is the first UDG.
  jr   nc,p_tokens_and_udg ;151D; Jump with UDG's and tokens.
  ld   b,a                 ;151F; Construct the graphic in the
  rst  calbas              ;1520; calculator's memory area by calling
  defw rom_po_gr_1         ;1521; 'PO_GR_1' in the 'main' ROM.
  ld   hl,23698            ;1523; HL points to the start of the graphic
                                ; form; i.e. MEMBOT.
  jr   p_graph             ;1526; Jump to print the graphic character.

p_tokens_and_udg:
  sub  token.rnd           ;1528; This is the RND token.
  jr   c,p_udgs            ;152A; Jump with UDG's (< 165).
  ld   hl,rom_po_tokens    ;152C; The routine indirectly jumps to the
  ex   (sp),hl             ;152F; 'PO_TOKENS' routine in the 'main' ROM
  push hl                  ;1530; to expand the token. That routine then
  ret                      ;1531; calls recursively the 'P_ALL' routine
                                ; above for each character of the token.

p_udgs:
  add  a,21                ;1532; Adjust range, UDG's now from 0..20.
  ld   bc,(23675)          ;1534; BC points to the start of the UDG area
  ld   h,0                 ;1538; (UDG).
  ld   l,a                 ;153A; Pass the code to HL.
  add  hl,hl               ;153B; Each UDG is made by eight bytes, so
  add  hl,hl               ;153C; multiply the code by eight.
  add  hl,hl               ;153D;
  add  hl,bc               ;153E;
p_graph:
  ld   de,$3E3D            ;153F; Move the eight bytes to the +Ds
  ld   bc,8                ;1542; internal printerbuffer.
  ldir                     ;1545;

; Now the eight pixelrows are converted to eight dotcolumns.

  push ix                  ;1547;
  ld   ix,$3E4C            ;1549; The last address of the dotcolumns.
  ld   b,8                 ;154D; Each graphic has eight pixelrows.
p_graph1:
  ld   hl,$3E3D            ;154F; Address of the graphic's pixelrows.
  ld   c,8                 ;1552; Each pixelrow has eight pixels.
p_graph2:
  ld   d,(hl)              ;1554; Each bit is moved in turn into the E
  rr   d                   ;1555; register.
  ld   (hl),d              ;1557;
  rl   e                   ;1558;
  inc  hl                  ;155A;
  dec  c                   ;155B;
  jr   nz,p_graph2         ;155C; Repeat for the eight pixels.
  ld   (ix+0),e            ;155E; Store the dotcolumn.
  dec  ix                  ;1561;
  djnz p_graph1            ;1563; Repeat for the eight rows.
  pop  ix                  ;1565;
  ld   de,graph_dpi        ;1567; Print the escape sequence for
  call po_esc_seq          ;156A; graphic images.
  ld   a,8                 ;156D; Signal to the printer 'there follow
  call pntp                ;156F; eight bytes of bitimage data'.
  ld   a,0                 ;1572;
  call pntp                ;1574;
  ld   b,8                 ;1577; Send the eight bytes to the printer.
p_graph3:
  ld   a,(hl)              ;1579;
  call pntp                ;157A;
  inc  hl                  ;157D;
  djnz p_graph3            ;157E;
  jr   p_up_pos            ;1580; Update the current position.

; Now deal with the printing of normal ASCII characters.

p_ascii:
  ld   hl,enter_flag       ;1582;
  res  1,(hl)              ;1585; Reset 'newline already send' flag.
  ld   ($3E4F),a           ;1587;
  ld   a,(graph)           ;158A; Fetch (GRAPH), when it's 1 the +D
  and  a                   ;158D; has to generate the graphic
  ld   a,($3E4F)           ;158E; representation of some characters.
  jr   z,p_others          ;1591; Jump if the normal code has to be send

; Because some Spectrum characters aren't supported by all printers the +D can
; send the graphic representation of those characters instead of the original
; character code. The characters supported £, # and (c).

  cp   96                  ;1593; Pound sign?
  jr   nz,p_nopound        ;1595; Jump if it isn't '£'.
  ld   hl,pound_sign       ;1597; Point to the bitimage data for '£'.
  jp   p_graph             ;159A; Handle it as an ordinary graphic.
p_nopound:
  cp   "#"                 ;159D;
  jr   nz,p_nohash         ;159F; Jump if it isn't '#'.
  ld   hl,hash_sign        ;15A1; Point to the bitimage data for '#'.
  jp   p_graph             ;15A4; Handle it as a graphic.
p_nohash:
  cp   127                 ;15A7; Copyright sign?
  jr   nz,p_others         ;15A9; Jump to handle all non '(c)' characters.
  ld   hl,copyright_sign   ;15AB; Point to the bitimage data for '(c)'.
  jp   p_graph             ;15AE; Handle it as a graphic.

; Finally the normal characters can be send to the printer.

p_others:
  call pntp                ;15B1; Send the character to the printer.
p_up_pos:
  ld   a,($3E4E)           ;15B4; Update the current position.
  inc  a                   ;15B7;
  ld   ($3E4E),a           ;15B8;
  ld   hl,width            ;15BB; HL points to WIDTH.
  sub  (hl)                ;15BE;
  ret  c                   ;15BF; Return if the line isn't full yet.
  call p_newline           ;15C0; Otherwise someone has forgotten that
  ld   hl,enter_flag       ;15C3; printer lines aren't endless, so print
  set  1,(hl)              ;15C6; a 'NEWLINE' and signal 'ignore next
  ret                      ;15C8; character if it is a CR'.

; ----------------------------------------------
; THE 'SEND A BYTE TO PRINTER' SUBROUTINE

; This routine is also called by using command code 57 ($39). It sends the 8
; bit code in the A register to the printer port, after checking if the
; printer is busy. The BREAK key is tested.

pntp:
  ld   ($3E4F),a           ;15C9; Store the code temporarily.
pntp_1:
  call tst_break           ;15CC; Exit if the BREAK key is pressed.
  in   a,(247)             ;15CF; Test the BUSY line of the printer.
  bit  7,a                 ;15D1;
  jr   nz,pntp_1           ;15D3; Wait until printer isn't BUSY.
  in   a,(247)             ;15D5;
  bit  7,a                 ;15D7;
  jr   nz,pntp_1           ;15D9;
  in   a,(247)             ;15DB;
  bit  7,a                 ;15DD;
  jr   nz,pntp_1           ;15DF;
  ld   a,($3E4F)           ;15E1; Send the code to the printer port.
  out  (247),a             ;15E4;
  ld   a,(control_port_status) ;15E6; Fetch current control port status.
  or   $40                 ;15E9; Give a STROBE.
  out  (239),a             ;15EB;
  and  $BF                 ;15ED; Reset STROBE.
  out  (239),a             ;15EF;
  ld   a,($3E4F)           ;15F1; Return with the A register holding the
                                ; outputted byte, 'RET' forgotten?


; ===============================================================
; The flag set and test routines

; ----------------------------------------------
; THE 'SIGNAL ..' SUBROUTINES

; These subroutines are used to signal various states of the +D. The
; corresponding test routines are located from $161C and onwards. Clearing is
; done by loading 0 into FLASG3, resetting all flags at once.

sign_0:
  rst  f_addr              ;15F4;
  set  0,(hl)              ;15F5;
  pop  hl                  ;15F7;
  ret                      ;15F8;

sign_1:
  rst  f_addr              ;15F9;
  set  1,(hl)              ;15FA;
  pop  hl                  ;15FC;
  ret                      ;15FD;

sign_2:
  rst  f_addr              ;15FE;
  set  2,(hl)              ;15FF;
  pop  hl                  ;1601;
  ret                      ;1602;

sign_3:
  rst  f_addr              ;1603;
  set  3,(hl)              ;1604;
  pop  hl                  ;1606;
  ret                      ;1607;

sign_4:
  rst  f_addr              ;1608;
  set  4,(hl)              ;1609;
  pop  hl                  ;160B;
  ret                      ;160C;

sign_5:
  rst  f_addr              ;160D;
  set  5,(hl)              ;160E;
  pop  hl                  ;1610;
  ret                      ;1611;

sign_6:
  rst  f_addr              ;1612;
  set  6,(hl)              ;1613;
  pop  hl                  ;1615;
  ret                      ;1616;

sign_7:
  rst  f_addr              ;1617;
  set  7,(hl)              ;1618;
  pop  hl                  ;161A;
  ret                      ;161B;

; ----------------------------------------------
; THE 'TEST ..' SUBROUTINES

; These subroutines are used to test the various states of the +D system.

test_0:
  rst  f_addr              ;161C;
  bit  0,(hl)              ;161D;
  pop  hl                  ;161F;
  ret                      ;1620;

test_1:
  rst  f_addr              ;1621;
  bit  1,(hl)              ;1622;
  pop  hl                  ;1624;
  ret                      ;1625;

test_2:
  rst  f_addr              ;1626;
  bit  2,(hl)              ;1627;
  pop  hl                  ;1629;
  ret                      ;162A;

test_3:
  rst  f_addr              ;162B;
  bit  3,(hl)              ;162C;
  pop  hl                  ;162E;
  ret                      ;162F;

test_4:
  rst  f_addr              ;1630;
  bit  4,(hl)              ;1631;
  pop  hl                  ;1633;
  ret                      ;1634;

test_5:
  rst  f_addr              ;1635;
  bit  5,(hl)              ;1636;
  pop  hl                  ;1638;
  ret                      ;1639;

test_6:
  rst  f_addr              ;163A;
  bit  6,(hl)              ;163B;
  pop  hl                  ;163D;
  ret                      ;163E;

test_7:
  rst  f_addr              ;163F;
  bit  7,(hl)              ;1640;
  pop  hl                  ;1642;
  ret                      ;1643;


; ===============================================================
; The error restarts

; ----------------------------------------------
; THE 'ERROR' RESTARTS

; The following 32 routines consist each of a call to the +D error routine
; directly followed by the error byte.

rep_0:
  rst  disc_err            ;1644;
  defb $00                 ;1645; 'Nonsense in G+DOS'
rep_1:
  rst  disc_err            ;1646;
  defb $01                 ;1647; 'Nonsense in GNOS'
rep_2:
  rst  disc_err            ;1648;
  defb $02                 ;1649; 'Statement END error'
rep_3:
  rst  disc_err            ;164A;
  defb $03                 ;164B; 'BREAK requested'
rep_4:
  rst  disc_err            ;164C;
  defb $04                 ;164D; ',SECTOR error'
rep_5:
  rst  disc_err            ;164E;
  defb $05                 ;164F; 'FORMAT data lost'
rep_6:
  rst  disc_err            ;1650;
  defb $06                 ;1651; 'CHECK DISC in drive'
rep_7:
  rst  disc_err            ;1652;
  defb $07                 ;1653; 'No "+ SYS " file'
rep_8:
  rst  disc_err            ;1654;
  defb $08                 ;1655; 'Invalid FILE NAME'
rep_9:
  rst  disc_err            ;1656;
  defb $09                 ;1657; 'Invalid STATION'
rep_10:
  rst  disc_err            ;1658;
  defb $0A                 ;1659; 'Invalid DEVICE'
rep_11:
  rst  disc_err            ;165A;
  defb $0B                 ;165B; 'VARIABLE not found'
rep_12:
  rst  disc_err            ;165C;
  defb $0C                 ;165D; 'VERIFY failed'
rep_13:
  rst  disc_err            ;165E;
  defb $0D                 ;165F; 'Wrong FILE type'
rep_14:
  rst  disc_err            ;1660;
  defb $0E                 ;1661; 'MERGE error'
rep_15:
  rst  disc_err            ;1662;
  defb $0F                 ;1663; 'CODE error'
rep_16:
  rst  disc_err            ;1664;
  defb $10                 ;1665; 'PUPIL set'
rep_17:
  rst  disc_err            ;1666;
  defb $11                 ;1667; 'Invalid CODE'
rep_18:
  rst  disc_err            ;1668;
  defb $12                 ;1669; 'Reading a WRITE file'
rep_19:
  rst  disc_err            ;166A;
  defb $13                 ;166B; 'Writing a READ file'
rep_20:
  rst  disc_err            ;166C;
  defb $14                 ;166D; 'O.K. G+DOS'
rep_21:
  rst  disc_err            ;166E;
  defb $15                 ;166F; 'Network OFF'
rep_22:
  rst  disc_err            ;1670;
  defb $16                 ;1671; 'Wrong DRIVE'
rep_23:
  rst  disc_err            ;1672;
  defb $17                 ;1673; 'Disc WRITE protected'
rep_24:
  rst  disc_err            ;1674;
  defb $18                 ;1675; 'Not enough SPACE on disc'
rep_25:
  rst  disc_err            ;1676;
  defb $19                 ;1677; 'Directory FULL'
rep_26:
  rst  disc_err            ;1678;
  defb $1A                 ;1679; 'File NOT FOUND'
rep_27:
  rst  disc_err            ;167A;
  defb $1B                 ;167B; 'END of file'
rep_28:
  rst  disc_err            ;167C;
  defb $1C                 ;167D; 'File NAME used'
rep_29:
  rst  disc_err            ;167E;
  defb $1D                 ;167F; 'NO G+DOS loaded'
rep_30:
  rst  disc_err            ;1680;
  defb $1E                 ;1681; 'STREAM used'
rep_31:
  rst  disc_err            ;1682;
  defb $1F                 ;1683; 'CHANNEL used'


; ===============================================================
; Miscalleneous routines II

; ----------------------------------------------
; THE 'FLASH BORDER' SUBROUTINE

; When +D system variable RBCC (address @0) doesn't hold zero, this subroutine
; flashes the border. The border colour is then obtained by masking the E
; register (holds sectornumber) with RBCC.

flash_bord:
  ld   a,(rbcc)            ;1684; Fetch RBCC.
  and  e                   ;1687; Incorporate sectornumber.
  ret  z                   ;1688; Return if 'no flashing'.
  and  $07                 ;1689; Keep border colour only.
  out  (254),a             ;168B; Set the border and finished.
  ret                      ;168D;

; ----------------------------------------------
; THE 'BORDER COLOUR RESTORE' SUBROUTINE

; This subroutine is used whenever the border colour was changed during an I/
; O operation, and needs to be restored to its original state.

bord_rest:
  push af                  ;168E;
  ld   a,(23624)           ;168F; Fetch lower screen attribute (BORDCR).
  and  $38                 ;1692; Only the border bits.
  rrca                     ;1694; Move the bits to 0-2.
  rrca                     ;1695;
  rrca                     ;1696;
  out  (254),a             ;1697; Restore colour.
  pop  af                  ;1699;
  ret                      ;169A;

; ----------------------------------------------
; THE 'PRINT DIRECTORY DESCR.' SUBROUTINE

; This subroutine is used to print the directory description of a file during
; an 'extended CAT' command. On entry the A register holds the directory
; description.

prt_type:
  push af                  ;169B;
  ld   hl,type_table       ;169C; Start of messages table.
  ld   bc,85               ;169F; Length of table excluding 'WHAT?'.
  cpir                     ;16A2; Make HL point to right message. HL
                                ; points to 'WHAT?' with unknown types.
  call prt_msg_hl          ;16A4; Print the message.
  pop  af                  ;16A7; Restore file type.
  cp   1                   ;16A8;
  jr   nz,prt_nobas        ;16AA; Jump with no 'BASIC' files.
  ld   (ix+13),219         ;16AC; Make RPT point to autostart line high.
  call rpt_hl1             ;16B0; HL points to it now.
  ld   a,(hl)              ;16B3;
  and  192                 ;16B4;
  jr   nz,prt_exit         ;16B6; Jump if no autostart line present.
  ld   d,(hl)              ;16B8; Otherwise fetch it.
  dec  hl                  ;16B9;
  ld   e,(hl)              ;16BA;
  ex   de,hl               ;16BB;
  call prt_num             ;16BC; Print it.
  jr   prt_exit            ;16BF;

; Now the other directory descriptions are handled.

prt_nobas:
  cp   4                   ;16C1;
  jr   nz,prt_exit         ;16C3; Jump with no 'CODE' files.
  ld   (ix+13),215         ;16C5; RPT points to file address high byte.
  call rpt_hl1             ;16C9; Make HL hold RPT.
  ld   d,(hl)              ;16CC; Fetch file address.
  dec  hl                  ;16CD;
  ld   e,(hl)              ;16CE;
  ex   de,hl               ;16CF;
  push de                  ;16D0;
  call prt_num             ;16D1; Print file address.
  ld   a,44                ;16D4; Print a ','.
  call prt_a               ;16D6;
  pop  hl                  ;16D9;
  dec  hl                  ;16DA;
  ld   d,(hl)              ;16DB; Fetch file length.
  dec  hl                  ;16DC;
  ld   e,(hl)              ;16DD;
  ex   de,hl               ;16DE;
  ld   a,0                 ;16DF; Ignore leading zero's.
  call prt_n10000          ;16E1; Print the length.
prt_exit:
  ld   a,13                ;16E4; Print a NEWLINE and exit.
  jp   prt_a               ;16E6;

; ----------------------------------------------
; THE 'DIRECTORY DESCRIPTION' TABLE

; This table contains the directory description messages as printed with an
; 'extended CAT'. Each message is preceeded by is description value.

type_table:
  defb 1                   ;16E9;
  defm "BAS "              ;16EA;
  defb 2                   ;16EE;
  defm "D.ARRAY"           ;16EF;
  defb 3                   ;16F6;
  defm "$.ARRAY"           ;16F7;
  defb 4                   ;16FE;
  defm "CDE "              ;16FF;
  defb 5                   ;1703;
  defm "SNP 48K"           ;1704;
  defb 6                   ;170B;
  defm "MD.FILE"           ;170C;
  defb 7                   ;1713;
  defm "SCREEN$"           ;1714;
  defb 8                   ;171B;
  defm "SPECIAL"           ;171C;
  defb 9                   ;1723;
  defm "SNP 128K"          ;1724;
  defb 10                  ;172C;
  defm "OPENTYPE"          ;172D;
  defb 11                  ;1735;
  defm "EXECUTE"           ;1736;
  defb 12                  ;173D;
  defm "WHAT?"             ;173E;
  defb 0                   ;1743;

; ----------------------------------------------
; THE 'PRINT NUMBER' SUBROUTINE

; This subroutine prints the number held in the HL register. Entering the
; routine at $1744 prints leading spaces, while the other entry points prints
; the character held in the A register in place of leading zero's. A value of
; 0 means don't print anything.

prt_num:
  ld   a,32                ;1744; Spaces are printed in place of leading
                                ; zero's.
prt_n10000:
  ld   de,10000            ;1746; Start printing with tens-of-thousands.
  call prt_digit           ;1749;
prt_n1000:
  ld   de,1000             ;174C; Start printing with thousands.
  call prt_digit           ;174F;
prt_n100:
  ld   de,100              ;1752; Start printing with hundreds.
  call prt_digit           ;1755;
prt_n10:
  ld   de,10               ;1758; Start printing with tens.
  call prt_digit           ;175B;
  ld   a,l                 ;175E; Print units.
  add  a,"0"               ;175F; Add ASCII offset for digits.
  jr   prt_a               ;1761;

; ----------------------------------------------
; THE 'PRINT DIGIT' SUBROUTINE

; This subroutine is used to print a digit, the HL register holds the number
; and the DE register the value for 'repeated subtraction'.

prt_digit:
  push af                  ;1763; Preserve leading character.
  xor  a                   ;1764; Clear Carry and counter.
prt_dig1:
  sbc  hl,de               ;1765; The 'trial' subtraction.
  jr   c,prt_dig2          ;1767; Jump if exhausted.
  inc  a                   ;1769; Count each trial.
  jr   prt_dig1            ;176A; Jump back for next try.

; The A register now holds the digit to be printed.

prt_dig2:
  add  hl,de               ;176C; Restore last subtraction.
  and  a                   ;176D;
  jr   nz,prt_dig3         ;176E; Jump if a non zero value is to be
                                ; printed.
  pop  de                  ;1770; Retrieve the leading character into D.
  add  a,d                 ;1771; Add it to zero.
  ret  z                   ;1772; Return if nothing has to be printed.
  jr   prt_a               ;1773; Otherwise print the leading character.

; Now print the digit.

prt_dig3:
  add  a,"0"               ;1775; Add ASCII offset for digits.
  call prt_a               ;1777; Print the digit.
  pop  de                  ;177A; Balance the stack.
  ld   a,"0"               ;177B; All zeroes after any non zero digit
  ret                      ;177D; will be printed as '0'.

; ----------------------------------------------
; THE 'PRINT OUT MESSAGE' SUBROUTINE

; This subroutine handles the printing of messages directly following the
; 'CALL' instruction to this routine. When the +D's own error stack pointer
; (D_ERR_SP) holds a non-zero value, i.e during hook and command codes, no
; printing has to take place. The carry flag is set and the A register then
; holds 32, signalling 'error during hook/command code execution' as usual.

po_msg:
  ld   hl,(d_err_sp)       ;177E; Fetch (D_ERR_SP).
  ld   a,h                 ;1781;
  or   l                   ;1782;
  jr   z,po_msg1           ;1783; Jump if it isn't used.
  ld   sp,hl               ;1785; Clear machine stack.
  ld   a,32                ;1786; Signal 'error 32'.
  scf                      ;1788;
  ret                      ;1789; Exit.

; Now the message can be printed.

po_msg1:
  pop  hl                  ;178A; HL points to the message to be printed
po_msg2:
  ld   a,(hl)              ;178B; Fetch a character.
  and  $7F                 ;178C;
  call prt_a               ;178E; Print it.
  bit  7,(hl)              ;1791; Bit 7 set signals 'End of message'.
  ret  nz                  ;1793;
  inc  hl                  ;1794;
  jr   po_msg2             ;1795; Repeat for all characters.

; ----------------------------------------------
; THE 'PRINT A SPACE' SUBROUTINE

; This subroutine prints a space to the current stream.

prt_space:
  ld   a,32                ;1797; Continue in the 'PRT_A' routine.

; ----------------------------------------------
; THE 'PRINT CHARACTER' SUBROUTINE

; This subroutine prints the character held in the A register to the current
; stream.

prt_a:
  push af                  ;1799;
  push bc                  ;179A;
  push de                  ;179B;
  push hl                  ;179C;
  push ix                  ;179D;
  rst  calbas              ;179F; Print the character in the A register
  defw rom_print_a         ;17A0; by calling the 'main' ROM routine.
  pop  ix                  ;17A2;
  pop  hl                  ;17A4;
  pop  de                  ;17A5;
  pop  bc                  ;17A6;
  pop  af                  ;17A7;
  ret                      ;17A8;

; ----------------------------------------------
; THE 'ROM' MESSAGES

; Now follow some messages used by the +D system.

mesg_0:
  call po_msg              ;17A9;
  defb $0D,$0D,$0D,$0D,$0D,$0D;17AC;
  defm '        "SYSTEM" LOADING';17B2;
  defb $0D,$0D             ;17CA;
  defm "          PLEASE  WAIT";17CC;
  defb $0D,$0D             ;17E2;
  defm "        (+D ROM Ver 1.A)";17E4;
  defb $0D,$8D             ;17FC;

mesg_1:
  call po_msg              ;17FE;
  defm "OVERWRITE "        ;1801;
  defb '"'+128             ;180B;

mesg_2:
  call po_msg              ;180C;
  defm "Are you SURE ? (y/n";180F;
  defb ")"+128             ;1822;

mesg_3:
  call po_msg              ;1823;
  defm " (y/n)"            ;1826;
  defb ")"+128             ;182C;


; ===============================================================
; The error routines

; ----------------------------------------------
; THE '+D ERROR' ROUTINE

; Whenever a +D error is encountered this routine is executed to handle it.
; During syntax checking the error is handled by the 'main' ROM error handler.
; Whenever an error is found while executing a command code, a return is made
; with the Carry flag set and the A register holding the error number. Only
; during runtime the error message is printed.

d_error:
  call bord_rest           ;182D; Restore normal border colour.
  ld   ($3DED),de          ;1830; Track & sector with sector error.
  xor  a                   ;1834;
  ld   (flags3),a          ;1835; Clear FLAGS3.
  pop  hl                  ;1838; Fetch return address.
  ld   de,(d_err_sp)       ;1839; Fetch (D_ERR_SP).
  ld   a,d                 ;183D;
  or   e                   ;183E;
  ld   a,(hl)              ;183F; Fetch error code.
  jr   z,d_error1          ;1840; Jump if (D_ERR_SP) isn't used.

; Whenever hook or command codes are being executed, errors are reported to
; the calling routine by setting the carry flag. The A register holds the
; error code.

  ld   sp,(d_err_sp)       ;1842; Clear the machine stack.
  scf                      ;1846; Carry set to signal 'error'.
  ret                      ;1847;

; The routine continues here when an error message is to be printed.

d_error1:
  ld   (23610),a           ;1848; Store error code into (ERR_NR).
  res  5,(iy+1)            ;184B; Signal 'ready for a new key'.
  ld   sp,(23613)          ;184F; Clear machine stack by using (ERR_SP).
  rst  syntax_z            ;1853; Return via 'main' ROM 'SET_STK'
  ld   hl,rom_set_stk      ;1854; routine to the error handler during
  jp   z,unpage_hl         ;1857; syntax checking.
  ld   hl,0                ;185A;
  ld   (iy+55),h           ;185D; Clear FLAGX.
  ld   (iy+38),h           ;1860; And X_PTR-hi.
  ld   (23563),hl          ;1863; Clear DEFADD.
  inc  l                   ;1866; Ensure that stream 0 points to channel
  ld   (23574),hl          ;1867; 'K'.
  rst  calbas              ;186A; Clear all the work areas and the
  defw rom_set_min         ;186B; calculator stack.
  ld   a,(23728)           ;186D;
  and  a                   ;1870; Exit via 'END' if error messages are
  jp   nz,the_end          ;1871; to be supressed.
  res  5,(iy+55)           ;1874; Signal 'EDIT mode' FLAGX.
  rst  calbas              ;1878; Clear the lower screen.
  defw rom_cls_lower       ;1879;
  set  5,(iy+2)            ;187B; Signal 'lower screen will require
                                ; clearing'. (TV_FLAG)
  res  3,(iy+2)            ;187F; Signal 'mode is to be considered
                                ; unchanged'.
  ld   a,(23610)           ;1883;
  cp   4                   ;1886;
  jr   nz,d_error2         ;1888; Jump if error isn't 'SECTOR error'.
  push af                  ;188A;
  ld   de,($3DED)          ;188B; Fetch track and sector where error
  ld   h,0                 ;188F; was signalled.
  ld   l,d                 ;1891;
  push de                  ;1892;
  xor  a                   ;1893; Print the track number, no leading
  call prt_n100            ;1894; characters.
  ; XXX FIXME -- in the original HTML the previous label is wrong
  ld   a,":"               ;1897; Print a colon.
  call prt_a               ;1899;
  pop  de                  ;189C;
  ld   h,0                 ;189D;
  ld   l,e                 ;189F;
  xor  a                   ;18A0; Print the sector number, no leading
  call prt_n10             ;18A1; characters.
  ; XXX FIXME -- in the original HTML the previous label is wrong
  pop  af                  ;18A4;

; The routine now continues with the printing of the error message.

d_error2:
  ld   hl,err_msgs         ;18A5; HL points to the error message table.
  ld   bc,503              ;18A8; Length of error message table.
  cpir                     ;18AB; Search for the message.
  call prt_msg_hl          ;18AD; Print it.
  inc  sp                  ;18B0; Drop address of 'main' ROM error
  inc  sp                  ;18B1; handler.
  ld   hl,rom_main_5_1349  ;18B2; Print the line and statement number by
  jp   unpage_hl           ;18B5; jumping into the Spectrum error
                                ; handler.

; ----------------------------------------------
; THE 'PRINT MESSAGE HL' SUBROUTINE

; This subroutine prints the message pointed to by the HL register.

prt_msg_hl:
  ld   a,(hl)              ;18B8; Fetch a character.
  cp   32                  ;18B9;
  ret  c                   ;18BB; Exit if it isn't printable, message is
                                ; finished.
  call prt_a               ;18BC; Print the character.
  inc  hl                  ;18BF;
  jr   prt_msg_hl          ;18C0; Continue until message end is reached.

; ----------------------------------------------
; THE 'ERROR MESSAGES' TABLE

; The following table contains the +D's error messages. Each message starts
; with its error number.

err_msgs:
  defb $00                 ;18C2;
  defm "Nonsense in G+DOS" ;18C3;
  defb $01                 ;18D4;
  defm "Nonsense in GNOS"  ;18D5;
  defb $02                 ;18E5;
  defm "Statement END error";18E6;
  defb $03                 ;18F9;
  defm "BREAK requested"   ;18FA;
  defb $04                 ;1909;
  defm ",SECTOR error"     ;190A;
  defb $05                 ;1917;
  defm "FORMAT data lost"  ;1918;
  defb $06                 ;1928;
  defm "CHECK DISC in drive";1929;
  defb $07                 ;193C;
  defm 'No "+ SYS  " file' ;193D;
  defb $08                 ;194D;
  defm "Invalid FILE NAME" ;194E;
  defb $09                 ;195F;
  defm "Invalid STATION"   ;1960;
  defb $0A                 ;196F;
  defm "Invalid DEVICE"    ;1970;
  defb $0B                 ;197E;
  defm "VARIABLE not found";197F;
  defb $0C                 ;1991;
  defm "VERIFY failed"     ;1992;
  defb $0D                 ;199F;
  defm "Wrong FILE type"   ;19A0;
  defb $0E                 ;19AF;
  defm "MERGE error"       ;19B0;
  defb $0F                 ;19BB;
  defm "CODE error"        ;19BC;
  defb $10                 ;19C6;
  defm "PUPIL set"         ;19C7;
  defb $11                 ;19D0;
  defm "Invalid CODE"      ;19D1;
  defb $12                 ;19DD;
  defm "Reading a WRITE file";19DE;
  defb $13                 ;19F2;
  defm "Writing a READ file";19F3;
  defb $14                 ;1A06;
  defm "O.K. G+DOS"        ;1A07;
  defb $15                 ;1A11;
  defm "Network OFF"       ;1A12;
  defb $16                 ;1A1D;
  defm "Wrong DRIVE"       ;1A1E;
  defb $17                 ;1A29;
  defm "Disc write PROTECTED";1A2A;
  defb $18                 ;1A3E;
  defm "Not enough SPACE on disc";1A3F;
  defb $19                 ;1A57;
  defm "Directory FULL"    ;1A58;
  defb $1A                 ;1A66;
  defm "File NOT FOUND"    ;1A67;
  defb $1B                 ;1A75;
  defm "END of file"       ;1A76;
  defb $1C                 ;1A81;
  defb "File NAME used"    ;1A82;
  defb $1D                 ;1A90;
  defm "NO G+DOS loaded"   ;1A91;
  defb $1E                 ;1AA0;
  defm "STREAM used"       ;1AA1;
  defb $1F                 ;1AAC;
  defm "CHANNEL used"      ;1AAD;
  defb $00                 ;1AB9;

  defs $1FFF-$1ABA+1,$FF ; $1ABA..$1FFF Unused locations (all filled with $FF)

; ===============================================================
; RAM

  org $2000

plus_d_ram:

plus_d_ram_size: equ 8192


; ===============================================================
; The +D system variables and tables

; ----------------------------------------------
; THE 'SYSTEM VARIABLES'

; These variables hold various settings for drives etc. The variables starting
; at address $2000 can be accessed from BASIC with POKE @p,n. Where p is 0 for
; RBCC at $2000.

system_variables:

rbcc:
  defb $07                 ;2000; Flashing borders.
                                ; This value is used as a bitmask
                                ; of the sector number. Then resulting
                                ; bits 0..2 are used as border colour.
                                ; See `flash_bord` routine.
traks1:
  defb 80+128              ;2001; Drive 1 80 tracks double sided.
traks2:
  defb 80+128              ;2002; Drive 2 80 tracks double sided.
stprat:
  defb 0                   ;2003; "Steprate" 0 ms.
nstat:
  defb 1                   ;2004; Network on?
width:
  defb 80                  ;2005; Printer right margin.
pcode:
  defb 0                   ;2006; Expand tokens, etc. before printing.
lspce:
  defb 12                  ;2007; Line spacing 12/72 inch.
lfeed:
  defb 1                   ;2008; Number of line feeds after CR 1.
lmarg:
  defb 0                   ;2009; Left margin at 0.
graph:
  defb 0                   ;200A; Print special graphics off.
zxpnt:
  defb 0                   ;200B; +D printer port on.
reserved:
  defw $0000               ;200C;
onerr:
  defw $0000               ;200E; Address of routine called after an
                                ; error has occurred.
every_int:
  defw jjiffy              ;2010; Address of routine called at every
                                ; interrupt.

; ----------------------------------------------
; THE 'PRINTER CODES' TABLE

; Here the printer control codes are stored.

; XXX TODO -- rename labels, these are the default data

init_prt:
  defb 27,"@",$80,$80      ;2012;
  defb $80,$80,$80,$80     ;2016;
char_pitch:
  defb $80,$80,$80,$80     ;201A;
  defb $80,$80,$80,$80     ;201E;
n_per_72_lspc:
  defb 27,"A",$80,$80      ;2022;
  defb $80,$80,$80,$80     ;2026;
graph_dpi:
  defb 27,"*",5,$80        ;202A;
  defb $80,$80,$80,$80     ;202E;
init_prt2:
  defb $80,$80,$80,$80     ;2032;
  defb $80,$80,$80,$80     ;2036;

; ----------------------------------------------
; THE 'GRAPHIC REPRESENTATION' TABLE

; This table consists of the graphic representations of the £, # and © signs.
; The 'GRAPH' system variable (@10) determines whether the normal code or the
; graphic representation is outputted to the printer.

pound_sign:
  defb %00011000           ;203A;
  defb %00100000           ;203B;
  defb %00100000           ;203C;
  defb %01111000           ;203D;
  defb %00100000           ;203E;
  defb %00100000           ;203F;
  defb %01111100           ;2040;
  defb %00000000           ;2041;

hash_sign:
  defb %00000000           ;2042;
  defb %00100100           ;2043;
  defb %01111110           ;2044;
  defb %00100100           ;2045;
  defb %00100100           ;2046;
  defb %01111110           ;2047;
  defb %00100100           ;2048;
  defb %00000000           ;2049;

copyright_sign:
  defb %01111110           ;204A;
  defb %10000001           ;204B;
  defb %10111101           ;204C;
  defb %10100001           ;204D;
  defb %10100001           ;204E;
  defb %10111101           ;204F;
  defb %10000001           ;2050;
  defb %01111110           ;2051;

; ----------------------------------------------
; THE 'GREYSCALE' PRINTER CONTROL CODE

; This code is outputted to the printer if a 'SCREEN$ 2' screendump is wanted.

grey_bitim:
  defb 27,"*",5,$40        ;2052;
  defb $02,$80,$80,$80     ;2056;

; ----------------------------------------------
; THE 'GREYSCALE' TABLE

; This table consists of three times three bytes of greyscale info. Each
; screen pixel is converted into 3x3 printer dots during greyscale printing.
; The printer dots are ordered as follows: The first dot row is produced from
; the first three bytes by taking the bit, which number is corresponding with
; the colour number, from each of the three bytes. E.g.  for colour 2 (=red)
; bit 2 is used. In the same way the second and third dot rows are produced
; from the second and third three bytes respectively.  The following eight 3x3
; matrices are produced:

 ; White  Yellow  Cyan  Green Magenta  Red    Blue  Black
 ;  000    000    100    000    100    010    110    111
 ;  000    010    010    101    111    111    111    111
 ;  000    000    001    000    001    010    011    111

; Note that some greytones aren't right. E.g. cyan is darker than green, which
; isn't so on the screen.

;                      colour
;                     76543210

greyscale:
  defb %00101011           ;205A;
  defb %00011111           ;205B; first row
  defb %00000001           ;205C;

  defb %00000111           ;205D;
  defb %01101111           ;205E; second row
  defb %00000111           ;205F;

  defb %00000001           ;2060;
  defb %00011111           ;2061; third row
  defb %00101011           ;2062;

output_p_routine:
  defw p_all               ;2063; Address of 'output' routine for "P".
enter_flag:
  defb $00                 ;2065; The 'ENTER' flag.
d_err_sp:
  defw $0000               ;2066; D_ERR_SP
  defb $00                 ;2067;

; ----------------------------------------------
; THE 'SNAPSHOT-FILE' UFIA

; The following bytes are the last 20 bytes of a snapshot file UFIA.

snap_ufia:
  defb 0                   ;2068; Directory description.
  defm "Snap      "        ;2069; File name.
  defb 3                   ;2073; File type.
  defw $0000               ;2074; File length.
  defw $0000               ;2076; File address.
  defw $0000               ;2078; Not used with Snap's.
  defw $FFFF               ;207A; Not used with Snap's.

; ----------------------------------------------
; SOME 'LOST' ASSEMBLER TEXT

; Miles-Gordon seem to have lost some of their assembler text.

  defm "JP"                ;207C;
  defb $07                 ;207E;
  defb "Z"                 ;207F;

; ----------------------------------------------
; THE 'RAM JUMPS'

; These 13 'jumps' are used from the ROM to call +D System routines present in
; RAM (after the System file has been loaded).

jcops:
  nop                      ;2080; The small dump isn't patched.
  nop                      ;2081;
  ret                      ;2082;
jcops2:
  nop                      ;2083; Neither is the greyscale dump.
  nop                      ;2084;
  ret                      ;2085;
jpchan:
  nop                      ;2086; Nor the PCHAN_OUT routine.
  nop                      ;2087;
  ret                      ;2088;
jpoke:
  nop                      ;2089; Nor the POKE routine.
  nop                      ;208A;
  ret                      ;208B;
jprtr:
  nop                      ;208C; Even the TAKE_PRTR routine isn't
  nop                      ;208D; patched.
  ret                      ;208E;
jjiffy:
  nop                      ;208F; Called EVERY_INT.
  nop                      ;2090;
  ret                      ;2091;
jload:
  jp   ld_vf_mr1           ;2092; Load the file.
jhxfer:
  jp   hxfer               ;2095; Transfer UFIA to DFCA.
jkscan:
  jp   jiffy               ;2098; Called every interrupt.
jmsg3:
  jp   msg_3               ;209B; Give the copyright message.
jhook:
  jp   hook_code           ;209E; Execute the hook or command code.
jsnap:
  jp   snap                ;20A1; Continue with the Snapshot routine.
jctrl:
  jp   ctrl                ;20A4; Continue with the control routine.

; ----------------------------------------------
; THE 'CONTROL ROUTINE' CONTINUED

; The final part of the control routine determines which command failed the
; Spectrum syntax. If it is a +D command then the apropriate routine is
; executed.

ctrl:
  push af                  ;20A7;
  ld   hl,$3DF4            ;20A8;
  ld   bc,60               ;20AB;
reset_vars:
  ld   (hl),255            ;20AE; Reset +D work areas, including UFIA1
  inc  hl                  ;20B0; and UFIA2.
  dec  bc                  ;20B1;
  ld   a,b                 ;20B2;
  or   c                   ;20B3;
  jr   nz,reset_vars       ;20B4;
  ld   (flags3),a          ;20B6; Clear FLAGS3.
  ld   ix,dfca             ;20B9;
  pop  af                  ;20BD; Fetch the command.
  ld   ($3DFF),a           ;20BE; Store it.
  cp   207                 ;20C1; Is the command 'CAT' ?
  jp   z,cat               ;20C3; Jump to the CAT routine if so.
  cp   208                 ;20C6; Also for 'FORMAT',...
  jp   z,format            ;20C8;
  cp   209                 ;20CB; ...'MOVE',...
  jp   z,move              ;20CD;
  cp   210                 ;20D0; ...'ERASE',...
  jp   z,erase_250C        ;20D2;
  cp   211                 ;20D5; ...'OPEN #',...
  jp   z,open              ;20D7;
  cp   212                 ;20DA; ...'CLOSE #',...
  jp   z,close             ;20DC;
  cp   213                 ;20DF; ...'MERGE',...
  jp   z,merge             ;20E1;
  cp   214                 ;20E4; ...'VERIFY',...
  jp   z,verify            ;20E6;
  cp   239                 ;20E9; ...'LOAD',...
  jp   z,load              ;20EB;
  cp   248                 ;20EE; ...'SAVE',...
  jp   z,save              ;20F0;
  cp   251                 ;20F3; ...'CLS',...
  jp   z,cls               ;20F5;
  cp   253                 ;20F8; ...'CLEAR',...
  jp   z,clear             ;20FA;
  cp   255                 ;20FD; ...'COPY',...
  jp   z,copy              ;20FF;
  ld   hl,(onerr)          ;2102; Fetch ONERR address.
  ld   a,h                 ;2105;
  or   l                   ;2106;
  ret  z                   ;2107; Return if no ON ERROR address.
  ld   ($2110),hl          ;2108; Store it so it can be CALBASsed.
  pop  hl                  ;210B; Drop return address.
  ld   a,($3DFF)           ;210C; Fetch command which has to be examined
  rst  calbas              ;210F; by user-routine (BASIC extensions).
  defw $0000               ;2110; CALL the extend BASIC routine(s).
  jp   the_end             ;2112; Test end of command and exit.

; ----------------------------------------------
; THE 'SNAPSHOT ROUTINE' CONTINUED

; Here the snapshot routine continues with the disk related functions, keys
; 3-5.

snap:
  ld   hl,16384            ;2115; start of RAM (also start of SCR$).
  bit  2,e                 ;2118;
  jr   nz,no_scr           ;211A; 3: Save SCREEN$.
  ld   a,7                 ;211C; type=SCR$.
  ld   de,6912             ;211E; length of SCR$.
  jr   snap_save           ;2121;

no_scr:
  bit  3,e                 ;2123;
  jr   nz,no_snp48         ;2125; 4: 48K Snapshot.
  ld   a,5                 ;2127; type=48K Snap.
  ld   de,49152            ;2129; length of 48K RAM.
  jr   snap_save           ;212C;

no_snp48:
  bit  4,e                 ;212E;
  ret  nz                  ;2130; Exit if not 5: 128K Snapshot.
  ld   a,9                 ;2131; Type=128K Snap.
  ld   de,16384            ;2133; Length of a RAM-page.
  ld   hl,49152            ;2136; Start of a RAM-page.
snap_save:
  ld   ($2068),a           ;2139; Store type in snapshot UFIA.
  ld   ($2074),de          ;213C; Store length in UFIA.
  ld   ($2076),hl          ;2140; And the start-address.
  pop  af                  ;2143; Drop return addres.
  ld   b,$FE               ;2144; Key CAPS-V I/O address.
  in   a,(c)               ;2146;
  bit  0,a                 ;2148;
  jr   nz,snap_name        ;214A; If CAPS is pressed the Snap goes to
  ld   a,(dfca.drive)      ;214C; the other drive.
  xor  $03                 ;214F;
  ld   (dfca.drive),a      ;2151;
snap_name:
  ld   a,%01000000         ;2154;
  call scan_cat            ;2156; Search first free catalogue entry.
  ret  nz                  ;2159; Exit if catalogue full.
  ld   a,d                 ;215A; Track to A.
  and  $07                 ;215B; Jump if CAT-entry will be located
  jr   z,snap_n1           ;215D; on track 0.

; The name a snapshot-file is given, depends on the position it's going to
; occupy in the directory. When the entry will be located on the first track
; the names range from 'Snap A' to 'Snap T', if however the entry will be
; located on track 1 to 3 the character after 'Snap' will be the track number.
; I.e. 'Snap1A' to 'Snap1T' for track 1, etc.  Notice that the character after
; 'Snap' is never set to a ' '.

  add  a,48                ;215F; ASCII offset for '0'.
  ld   ($206D),a           ;2161; Store a 1, 2 or 3 in name-part of UFIA.
snap_n1:
  ld   l,e                 ;2164; Store sector in L.
  sla  l                   ;2165; Two entries per sector.
  dec  l                   ;2167;
  ld   a,(ix+14)           ;2168; Is it the first or second entry in the
  add  a,l                 ;216B; CAT-sector.
  add  a,64                ;216C; Add ASCII 'A' offset.
  ld   ($206E),a           ;216E; Store 'A' to 'T' in name-part of UFIA.
  ld   hl,snap_ufia        ;2171; Copy UFIA to DFCA.
  ld   de,ufia1.nstr1      ;2174;
  ld   bc,20               ;2177;
  ldir                     ;217A;
  call ofsm_2              ;217C; Open the file.
  ld   hl,$3FEA            ;217F; Copy snap registers to catalogue entry.
  ld   de,$3BB2            ;2182;
  ld   bc,22               ;2185;
  ldir                     ;2188;
  ld   a,($2068)           ;218A; Get directory description.
  cp   9                   ;218D;
  jp   nz,no_snp128        ;218F; Jump if not a 128K Snapshot.
  ld   hl,49152            ;2192; Now the 5 first bytes of the current
  ld   de,$3BD6            ;2195; RAM-page are saved in the +D RAM
  ld   bc,5                ;2198; and replaced by the "BRUCE" message.
  ldir                     ;219B; This is done to determine the currently
  ld   hl,bruce            ;219D; paged in RAM-page.
  ld   de,49152            ;21A0;
  ld   bc,5                ;21A3;
  ldir                     ;21A6;
  xor  a                   ;21A8; Signal '128K ROM bank active'.
  ld   ($3E19),a           ;21A9;
  call d_rombank           ;21AC; Determine current 'main' ROM bank.
  jr   nz,snp128_1         ;21AF; Jump if 128K ROM bank.
  ld   a,$10               ;21B1; Signal '48K ROM bank active'.
  ld   ($3E19),a           ;21B3;
snp128_1:
  call rest_pbuf           ;21B6; Restore printer buffer contents.
  ld   a,($3E19)           ;21B9;
  call rampage_a           ;21BC; Page in current ROM bank & RAM page 0.

; The code now tests which screen is active. Because it isn't possible to
; detect which is the active screen, the user is consulted. By making nice
; border stripes the user is signalled that 'Y' (meaning: yes, screen changed)
; or 'N' (meaning: no, screen hasn't changed) has to be pressed.

snp128_2:
  ld   bc,$DFFE            ;21BF; Keyboard port and I/O address for Y-P.
  in   e,(c)               ;21C2;
  bit  4,e                 ;21C4;
  jr   z,changed_s         ;21C6; Jump if 'Y' was pressed, screen changed
  ld   b,$7F               ;21C8; I/O address for B-SPACE.
  in   e,(c)               ;21CA;
  bit  3,e                 ;21CC;
  jr   z,same_s            ;21CE; Jump if 'N' was pressed, same screen.
  inc  a                   ;21D0;
  and  $07                 ;21D1;
  out  (c),a               ;21D3; Make nice stripes in border again.
  jr   snp128_2            ;21D5; Only 'Y' or 'N' is accepted.

changed_s:
  ld   a,($3E19)           ;21D7;
  or   $08                 ;21DA; Signal 'screen 1'.
n_rambank:
  ld   ($3E19),a           ;21DC;
  call rampage_a           ;21DF; Page in active ROM bank and screen.

; Now the 'which RAM bank' test is executed. The active RAM bank is determined
; by searching which bank has been given the "BRUCE" message.

same_s:
  ld   de,49152            ;21E2; Here the message has been placed.
  ld   hl,bruce            ;21E5; Message to be found.
  ld   b,5                 ;21E8; There are five bytes in the message.
bruce_1:
  ld   a,(de)              ;21EA;
  cp   (hl)                ;21EB;
  jr   z,bruce_2           ;21EC; Jump if characters match.
  ld   a,($3E19)           ;21EE; Otherwise it has to be one of the other
  inc  a                   ;21F1; banks.
  jr   n_rambank           ;21F2;

bruce_2:
  inc  de                  ;21F4;
  inc  hl                  ;21F5;
  djnz bruce_1             ;21F6; All five characters have to match.
  ld   hl,$3BD6            ;21F8; The active RAM bank has been found,
  ld   de,49152            ;21FB; restore the original five bytes.
  ld   bc,5                ;21FE;
  ldir                     ;2201;
  ld   a,($3E19)           ;2203;
  push af                  ;2206; Save the page-configuration byte in the
  call sbyt                ;2207; snapshot file.
  and  $F8                 ;220A; Mask RAM bank, start with 0.
  ld   b,8                 ;220C; There are eight RAM banks
save_bank:
  push af                  ;220E;
  push bc                  ;220F;
  call rampage_a           ;2210; Page in RAM bank.
  ld   hl,($2076)          ;2213;
  ld   de,($2074)          ;2216;
  call hsvbk_2             ;221A; Save DE bytes starting at address HL.
  pop  bc                  ;221D;
  pop  af                  ;221E;
  inc  a                   ;221F; Next RAM bank.
  djnz save_bank           ;2220; Loop for all eight 16K RAM banks.
  pop  af                  ;2222;
  call rampage_a           ;2223; Page in original RAM bank.
  jr   snap_close          ;2226;

bruce:
  defm "BRUCE"             ;2228;

no_snp128:
  cp   7                   ;222D; Copy the 9 header bytes to the file if
  call z,save_head1        ;222F; it is a SCREEN$.
  ld   hl,($2076)          ;2232;
  ld   de,($2074)          ;2235;
  call hsvbk_2             ;2239; Save DE bytes starting at address HL.
snap_close:
  jp   cfsm                ;223C; Close the file.

; ----------------------------------------------
; THE 'PAGE 128K RAM' ROUTINE

; The 128K RAM-bank contained in the A register is paged-in.

rampage_a:
  ld   bc,$7FFD            ;223F; 128K bank-switch port address.
  out  (c),a               ;2242; Select RAM bank.
  ret                      ;2244;

; ----------------------------------------------
; THE 'JIFFY' CALL

; This routine is executed whenever KEY-SCAN in the Spectrum ROM is reached at
; $028E. It can be used to executed a routine with every interrupt.

jiffy:
  ld   hl,(every_int)      ;2245; Call routine which has to be called
  jp   (hl)                ;2248; every 'interrupt'. Normal: `jjiffy` ($208F)


; ----------------------------------------------
; THE 'MOUSE' ROUTINE

; This routine is also present in the DISCiPLE and tests a mouse-like device.
; Pointers which seem to keep track of screen coordinates are updated when
; necessary.

test_mouse:
  ld   bc,$03FF            ;2249; The MGT mouse port?
  in   a,(c)               ;224C;
  bit  7,a                 ;224E;
  ret  nz                  ;2250; Return if no activity.
  cpl                      ;2251;
  and  $05                 ;2252; Return if there was no horizontal or
  ret  z                   ;2254; vertical movement.
  ld   hl,sign_mouse       ;2255;
  push hl                  ;2258;
  ld   hl,move_vert        ;2259;
  push hl                  ;225C;
  in   d,(c)               ;225D; Read mouse bits again.
  ld   hl,$3DF1            ;225F; Mouses x-coordinate.
  bit  0,d                 ;2262;
  ret  nz                  ;2264; Return to vertical movement test.
  bit  1,d                 ;2265;
  jr   z,move_right        ;2267; Jump if mouse was moved right.
  ld   a,0                 ;2269; Left side of screen.
  cp   (hl)                ;226B;
  ret  z                   ;226C; Return if left movement isn't possible.
  dec  (hl)                ;226D; Otherwise decrement x-coordinate.
  ret                      ;226E;

move_right:
  ld   a,255               ;226F; Right side of screen.
  cp   (hl)                ;2271;
  ret  z                   ;2272; Return if right movement impossible.
  inc  (hl)                ;2273; Otherwise increment x.
  ret                      ;2274;

move_vert:
  ld   hl,$3DF2            ;2275; Y-coordinate of mouse.
  bit  2,d                 ;2278;
  ret  nz                  ;227A; Return to signal mouse.
  bit  3,d                 ;227B;
  jr   nz,move_up          ;227D; Jump if mouse was moved up.
  ld   a,0                 ;227F; Bottom side of screen.
  cp   (hl)                ;2281;
  ret  z                   ;2282; Return if bottom has been reached.
  dec  (hl)                ;2283; Otherwise move towards it.
  ret                      ;2284;

move_up:
  ld   a,175               ;2285; Top side of screen.
  cp   (hl)                ;2287;
  ret  z                   ;2288; Return if top was reached.
  inc  (hl)                ;2289; Otherwise increment y-coordinate.
  ret                      ;228A;

sign_mouse:
  out  (c),d               ;228B; Give original signal to mouse.
  ret                      ;228D;


; ===============================================================
; The Hook and Command code routine & The Command code table

; This routine is entered with the A register holding an 'IF1 hook code', a
; '+D command code' or an invalid error code. The routine calls a set of
; subroutines in the +D system, and is intended to help machine-code access to
; the drives. There are two tables containing addresses of the routines, the
; first is located in ROM (at $0DD7) and consists of the addresses of the
; routines for the IF1 hookcodes. The second table is located at address $22DE
; and consists of the addresses of the +D command code routines.

hook_code:
  ld   (dfca.left),de      ;228E;
  cp   24                  ;2292;
  jr   nc,comm_code        ;2294; Jump if code isn't a hook code.
  ld   de,if1_hook         ;2296; Address of hook (IF1) code table.
code_cont:
  ld   (iy+0),$FF          ;2299; Clear error.
  set  2,(iy+1)            ;229D; What's the purpose of this? ; XXX TODO --
  inc  hl                  ;22A1; Advance return address past the code.
  push hl                  ;22A2;
  add  a,a                 ;22A3; Table is made of two byte addresses, so
  ld   l,a                 ;22A4; double code.
  ld   h,0                 ;22A5;
  add  hl,de               ;22A7; Point codes entry in table.
  ld   e,(hl)              ;22A8; Fetch the address of the routine.
  inc  hl                  ;22A9;
  ld   d,(hl)              ;22AA;
  ld   hl,hook_ret         ;22AB; Return address after completion of
  push hl                  ;22AE; code.
  ld   (d_err_sp),sp       ;22AF; Set D_ERR_SP.
  ex   de,hl               ;22B3;
  ld   de,(dfca.left)      ;22B4; Restore DE and A.
  ld   a,( $3E4F)          ;22B8;
  jp   (hl)                ;22BB; Jump to the routine.

comm_code:
  sub  24                  ;22BC; Adjust range for command codes (0..20).
  cp   21                  ;22BE;
  jp   nc,rep_17           ;22C0; Give error if not a command code.
  ld   de,mgt_hook         ;22C3; Address of command code table.
  jr   code_cont           ;22C6; Continue with command codes.

; ----------------------------------------------
; THE 'HOOK_RET' ROUTINE

; This routine is entered whenever a hook or command code is finished.

hook_ret:
  push hl                  ;22C8;
  ld   hl,$0000            ;22C9;
  ld   (d_err_sp),hl       ;22CC; Clear D_ERR_SP.
  pop  hl                  ;22CF;
  call bord_rest           ;22D0; Return to the calling routine with the
  jp   unpage_1            ;22D3; 'main' ROM paged in.

; ----------------------------------------------
; THE 'PAGE-IN +D' SUBROUTINE

; This is called by using 'command code' 71. On return the +D is paged-in and
; the HL register contains 0, to indicate that this is a +D (with a DISCiPLE
; HL holds 1).

patch:
  pop  hl                  ;22D6; Drop 'HOOK_RET' return address.
  ld   hl,$0000            ;22D7; Clear 'D_ERR_SP'.
  ld   (d_err_sp),hl       ;22DA;
  ret                      ;22DD; HL=0, meaning 'this is a +D'.

; ----------------------------------------------
; THE 'COMMAND CODE ADRESSES' TABLE

; This jump table consists of the 21 addresses of the routines called by using
; the various 'command codes'.

mgt_hook:
  defw hxfer               ;22DE; Command code $33, 51.
  defw ofsm                ;22E0; Command code $34, 52.
  defw hofle               ;22E2; Command code $35, 53.
  defw sbyt                ;22E4; Command code $36, 54.
  defw hsvbk               ;22E6; Command code $37, 55.
  defw cfsm                ;22E8; Command code $38, 56.
  defw pntp                ;22EA; Command code $39, 57.
  defw cops                ;22EC; Command code $3A, 58.
  defw hgfle               ;22EE; Command code $3B, 59.
  defw lbyt                ;22F0; Command code $3C, 60.
  defw hldbk               ;22F2; Command code $3D, 61.
  defw jwsad               ;22F4; Command code $3E, 62.
  defw jrsad               ;22F6; Command code $3F, 63.
  defw rest                ;22F8; Command code $40, 64.
  defw heraz               ;22FA; Command code $41, 65.
  defw cops2               ;22FC; Command code $42, 66.
  defw pcat                ;22FE; Command code $43, 67.
  defw hrsad               ;2300; Command code $44, 68.
  defw hwsad               ;2302; Command code $45, 69.
  defw otfoc               ;2304; Command code $46, 70.
  defw patch               ;2305; Command code $47, 71.


; ===============================================================
; The BASIC command execution routines I

; ----------------------------------------------
; THE 'COPY FILE(S)' ROUTINE

; This routine handles the copying of files. It is executed as soon as the
; 'EXPT_PARMS' routine at $2665 finds a 'TO' keyword. The return address to
; the routine which called 'EXPT_PARMS' is dropped at $230E.

to:
  call test_save           ;2308;
  jp   z,rep_0             ;230B; Give error if not SAVEing.
  pop  hl                  ;230E; Drop return address to SAVE routine.
  call swap_ufias          ;230F; Swap the UFIAS.
  rst  next_c              ;2312;
  and  $DF                 ;2313; Drop lower case bit.
  cp   "D"                 ;2315;
  jp   nz,rep_0            ;2317; Jump if 2nd device isn't "D".
  ld   (ufia1.lstr1),a     ;231A; Store it in DEV_TYPE1.
  call expt_devn           ;231D; Evaluate drive num., store it in UFIA1.
  call separator           ;2320; Test for a separator, jump if one
  jr   z,to_1              ;2323; found, i.e. a 2nd name is given.
  call sign_4              ;2325; Used here to signal 'use source
                                ; filename for destination file'.
to_1:
  call z,expt_fname        ;2328; Evaluate filename if there was a
                                ; separator.
  call swap_ufias          ;232B; Swap the UFIAS again.
  call st_end_ram          ;232E; Confirm end of statement and exit
                                ; during syntax checking.
  ld   hl,ufia2.nstr1      ;2331; Copy the second filename and directory
  ld   de,$3E32            ;2334; description.
  ld   bc,11               ;2337;
  ldir                     ;233A;
  ld   hl,$0001            ;233C; Track 0 sector 1.
  ld   ($3DED),hl          ;233F;
  ld   hl,$0000            ;2342; Disk buffer offset $0000.
  ld   ($3DEB),hl          ;2345;
to_2:
  call test_drive.ufia1    ;2348; Is the drive defined?
  call to_search           ;234B; Search for a file to be copied.
  jp   nz,to_exit          ;234E; Jump if there are no files left.
  call load_1st            ;2351; Copy file description (directory
                                ; description and filename) to UFIA2 and
                                ; load the first sector of the file into
                                ; the disk buffer.
  ld   a,(ufia2.nstr1)     ;2354; Get directory description.
  cp   5                   ;2357;
  jr   z,to_2              ;2359; Jump with 'Snapshot 48K'.
  cp   6                   ;235B;
  jr   z,to_2              ;235D; Jump with 'Microdrive file'.
  cp   9                   ;235F;
  jr   z,to_2              ;2361; Jump with 'Snapshot 128K'.
  cp   10                  ;2363;
  jr   z,to_2              ;2365; Jump with 'Opentype file'.
  cp   11                  ;2367;
  jr   z,to_2              ;2369; Jump with 'Execute file'.
                                ; These five file types can't be copied
                                ; with the 'SAVE .. TO ..' command.

; Now the file is going to be copied.  NOTE: The file to be copied will
; destroy everything above 'start of BASIC'+256 and no checks are made if the
; file fits in memory and if the stack isn't overwritten.

  call load_head2          ;236B; Copy the file header (the 9 bytes
                                ; consisting of filetype, length, etc.)
                                ; to UFIA2.
  ld   hl,(23635)          ;236E; Fetch start of BASIC program (PROG).
  inc  h                   ;2371; Add 256 to it.
  ld   de,(ufia2.hd0b)     ;2372; Fetch length of file (LENGTH2_1).
  call load_file           ;2376; Load DE bytes, starting at address HL.
  call to_msg              ;2379; Print the message "CHANGE disc ...." if
                                ; source drive is destination drive.
  call swap_ufias          ;237C; Swap the UFIA's again. The header of
                                ; the loaded file is now held in UFIA1.
  call test_4              ;237F; Used here to test whether a 2nd
  jr   nz,to_5             ;2382; filename was given. Jump if not.
  ld   hl,$3E33            ;2384; Here the 2nd filename was stored.
  ld   de,ufia1.nstr2      ;2387; Start of filename of loaded file.
  ld   b,10                ;238A; Filename length.

; Now the characters from the filename of the loaded file are replaced by the
; characters of the 2nd filename. Except when the wildcard characters '*' and
; '?' were used in the 2nd name. With '*' all next characters are left
; unchanged, with '?' the current character isn't changed.

to_3:
  ld   a,(hl)              ;238C;
  cp   "*"                 ;238D; With a '*' don't replace the remaining
  jr   z,to_5              ;238F; characters.
  cp   "?"                 ;2391; With a '?' in name 2 don't replace this
  jr   z,to_4              ;2393; character.
  ld   (de),a              ;2395; Store this character.
to_4:
  inc  hl                  ;2396;
  inc  de                  ;2397;
  djnz to_3                ;2398; Repeat for all 'normal' characters.
to_5:
  call test_drive.ufia1    ;239A;
  call ofsm_2              ;239D; Open the file for SAVEing.
  jr   nz,to_6             ;23A0; Jump if file existed already and the
                                ; user didn't want to overwrite it.
  call save_head1          ;23A2; SAVE the 9 header bytes to the file.
  ld   hl,(23635)          ;23A5; Fetch start of BASIC (PROG), and add
  inc  h                   ;23A8; 256 to it. (here the file was loaded)
  ld   de,(ufia1.hd0b)     ;23A9; Length of file.
  call hsvbk_2             ;23AD; Save the file.
  call cfsm                ;23B0; Close the file.
to_6:
  call swap_ufias          ;23B3; Swap the UFIA's again.
  call sign_0              ;23B6; Signal 'at least one file has been
                                ; copied'
  call to_msg              ;23B9; Print message "Input ..." if necessary
  jp   to_2                ;23BC; Repeat until no more files have to be
                                ; copied.

to_exit:
  call test_0              ;23BF; Give error if there isn't one file
  jp   z,rep_26            ;23C2; copied.
  ld   hl,rom_new          ;23C5; Otherwise jump to the appropriate 'NEW'
  jp   to_new              ;23C8; routine (128K or 48K).

; ----------------------------------------------
; THE 'PRINT "CHANGE DISC"' SUBROUTINE

; This subroutine tests whether source and destination drives are equal. If
; they are the messages "Insert SOURCE disc - press SPACE" and "Insert TARGET
; disc - press SPACE" are printed in turn.

to_msg:
  ld   a,(ufia1.dstr1)     ;23CB; Fetch source drive.
  ld   b,a                 ;23CE;
  ld   a,(ufia2.dstr1)     ;23CF; Fetch destination drive.
  cp   b                   ;23D2;
  ret  nz                  ;23D3; Return if they aren't equal.
  rst  calbas              ;23D4; Otherwise clear lower screen area.
  defw rom_cls_lower       ;23D5;
  set  5,(iy+2)            ;23D7; Signal 'lower screen has to be cleared'
  call to_msg1             ;23DB; Print "Input ... disc" message.
  call beep                ;23DE; Give a beep.
to_wspc:
  ld   a,$7F               ;23E1; Keyboard row B-SPACE address.
  in   a,(254)             ;23E3;
  rra                      ;23E5;
  jr   c,to_wspc           ;23E6; Jump unless the SPACE key is pressed.
  rst  calbas              ;23E8; Clear lower screen.
  defw rom_cls_lower       ;23E9;
  ret                      ;23EB; Finished.

; ----------------------------------------------
; THE 'SEARCH FILES' SUBROUTINE

; This subroutine searches for files which have to be copied. It returns with
; the Zero flag set if the current file is to be copied, if the complete
; directory is searched the routine returns with Zero reset.

to_search:
  ld   de,($3DED)          ;23EC; Track & sector to DE.
  ld   a,d                 ;23F0;
  cp   4                   ;23F1; Jump if not reached track 4, i.e.
  jr   nz,to_search1       ;23F3; directory hasn't been read completely.
  cp   0                   ;23F5; Reset Zero flag.
  ret                      ;23F7;

; The directory isn't finished yet, so read sector and test the file(s).

to_search1:
  call rsad                ;23F8; Read sector E from track D.
to_search2:
  call to_copy             ;23FB; Check if this file is to be copied.
  push af                  ;23FE; Store result (Zero flag).
  ld   hl,($3DEB)          ;23FF; Disk buffer offset to HL.
  ld   a,h                 ;2402;
  cp   1                   ;2403;
  jr   z,to_nxtsec         ;2405; Jump if second entry.
  ld   a,(control_port_status) ;2407; Fetch current control port status.
  and  $04                 ;240A;
  jr   nz,to_nxtsec        ;240C; Jump with single density.
  ld   hl,256              ;240E; Otherwise offset is for second entry.
  ld   ($3DEB),hl          ;2411;
  pop  af                  ;2414; Restore Zero flag.
  ret  z                   ;2415; Return if this file is to be copied.
  jr   to_search2          ;2416; Otherwise next file.

; The file entries of the current sector have been tested so point to the next
; sector.

to_nxtsec:
  ld   hl,0                ;2418; Offset is for first entry.
  ld   de,($3DED)          ;241B; Fetch track and sector.
  inc  e                   ;241F; Next sector.
  ld   a,e                 ;2420;
  cp   11                  ;2421;
  jr   nz,to_nxt1          ;2423; Jump if not last sector on this track.
  ld   e,1                 ;2425; Start with sector 1.
  inc  d                   ;2427; Next track.
to_nxt1:
  ld   ($3DED),de          ;2428; Store track & sector.
  ld   ($3DEB),hl          ;242C; Store disk buffer offset.
  pop  af                  ;242F; Restore Zero flag.
  ret  z                   ;2430; Return if previous file is to be
  jr   to_search           ;2431; copied. Otherwise jump.

; ----------------------------------------------
; THE 'COPY THIS FILE ?' SUBROUTINE

; This subroutine checks if the 'current' filename is to be  copied. The
; routine returns with the Zero flag set to signal yes and RPT pointing to the
; directory description of the file to be copied.

to_copy:
  ld   hl,$3BD6            ;2433; Point to start of sector.
  ld   de,($3DEB)          ;2436; Offset to DE.
  ld   (ix+14),d           ;243A; Update RPT (RAM PoinTer (?)).
  add  hl,de               ;243D; Update HL.
  ld   a,(hl)              ;243E; Fetch directory description.
  and  a                   ;243F;
  jr   nz,to_copy1         ;2440; Jump if the file isn't ERASEd.
  inc  a                   ;2442; Reset Zero flag to signal 'do not copy
  ret                      ;2443; this file' and exit.

to_copy1:
  inc  hl                  ;2444; Step past directory descriptor.
  ld   de,ufia1.nstr2      ;2445; DE now points to FILE_NAME1.
  ld   b,10                ;2448; A filename is 10 characters long.
to_copy2:
  ld   a,(de)              ;244A; Fetch character.
  cp   "*"                 ;244B; If it was a '*' all other characters
  ret  z                   ;244D; don't matter. Signal 'copy this one'.
  cp   "?"                 ;244E; If it was a '?' this character doesn't
  jr   z,to_copy3          ;2450; matter.
  xor  (hl)                ;2452;
  and  $DF                 ;2453; Upper and lower case? don't bother.
  ret  nz                  ;2455; Exit if characters are unequal.
to_copy3:
  inc  de                  ;2456; Check next character.
  inc  hl                  ;2457;
  djnz to_copy2            ;2458;
  ret                      ;245A; Finished.

; ----------------------------------------------
; THE 'CAT' COMMAND SYNTAX ROUTINE

; This routine checks that the command is in the form CAT <#s;>d<<;>n$> .

cat:
  ld   ix,dfca             ;245B;
  ld   hl,ufia1.nstr2      ;245F; "*" is the default name of the files
  ld   (hl),"*"            ;2462; being CATted.
  ld   hl,ufia1.sstr1      ;2464; Just like #2 is the default output
  ld   (hl),2              ;2467; stream.
  rst  next_c              ;2469; Get next character.
  cp   13                  ;246A; Give an error if an 'end of line' (CR)
  jp   z,rep_2             ;246C; is found right after "CAT".
  cp   ":"                 ;246F;
  jp   z,rep_2             ;2471; Same error for ":".
  cp   "#"                 ;2474; Jump if no stream specified, use
  jr   nz,cat_drv          ;2476; default stream #2.
  call expt_stream_nr      ;2478; Evaluate stream number.
  call separator           ;247B; Check if there is a separator.
  jp   nz,rep_0            ;247E; Give an error if no separator found.
cat_drv:
  call expt_devn2          ;2481; Evaluate drive number.
  call separator           ;2484; Evaluate filename if there is a
  call z,expt_fname        ;2487; separator.
  cp   "!"                 ;248A; If there is no "!" then an extended
  jr   nz,ext_cat_2499     ;248C; catalogue is given.
  rst  next_c              ;248E; Next character.
  call st_end_ram          ;248F; Confirm end of statement and exit when
                                ; syntax checking.
  call test_drive.ufia1    ;2492; See if drive is defined.
  ld   a,%00000010         ;2495; Signal 'small' CAT.
  jr   do_cat1             ;2497;

ext_cat_2499:
  ; XXX FIXME -- the original HTML defines `ext_cat` twice
  call st_end_ram          ;2499; Confirm end of statement and exit
                                ; during syntax time.
  rst  calbas              ;249C; Clear the screen by calling 'main' ROM
  defw rom_cl_all          ;249D; routine.
do_cat:
  call test_drive.ufia1    ;249F; See if drive is defined.
  ld   a,%00000100         ;24A2; Signal extended CAT.
do_cat1:
  call cat_run             ;24A4; Give the CAT.
  jp   the_end             ;24A7; Finished.

; ----------------------------------------------
; THE 'CAT' COMMAND ROUTINE

; This routine makes a catalogue of the disk inserted in the specified drive,
; by calling the +D ROM routine 'SCAN_CAT'.

cat_1:
  ld   hl,ufia1.nstr2      ;24AA; Point to name.
  ld   (hl),"*"            ;24AD; All files.
  ld   hl,ufia1.sstr1      ;24AF; Point to stream number.
  ld   a,2                 ;24B2; Make it stream 2.
  ld   (hl),a              ;24B4;
cat_run:
  push af                  ;24B5;
  ld   a,(ufia1.sstr1)     ;24B6;
  rst  calbas              ;24B9; Open the desired stream by calling
  defw rom_chan_open       ;24BA; 'CHAN_OPEN' in the 'main' ROM.
  ld   a,13                ;24BC;
  call prt_a               ;24BE; Printing starts on the next line.
  call msg_0               ;24C1; Print the 1st part of "DIR"-message.
  ld   a,(dfca.drive)      ;24C4; Fetch current drive.
  and  $03                 ;24C7; Only bits 0&1.
  or   $30                 ;24C9; Make ASCII "1" or "2".
  call prt_a               ;24CB; Print drive number.
  call msg_1               ;24CE; Print the 2nd part of "DIR"-message.
  ld   hl,0                ;24D1; Reset 'total number of sectors'
  ld   ($3DD8),hl          ;24D4; occupied.
  pop  af                  ;24D7; Restore 'CAT' type.
  call scan_cat            ;24D8; Print the CAT entries.
  call msg_2               ;24DB; Print "Free ..." message.
  call drv_cap             ;24DE; Get drive capacity in A register.
  push bc                  ;24E1;
  bit  7,a                 ;24E2;
  jr   z,cat_run1          ;24E4; Jump if drive is single sided.
  add  a,a                 ;24E6; Otherwise double the number of tracks
                                ; and get rid of the side bit.
cat_run1:
  sub  4                   ;24E7; Subtract number of catalogue tracks.
  ld   hl,0                ;24E9;
  ld   b,10                ;24EC; Each track has 10 sectors.
  ld   d,0                 ;24EE; Number of tracks to DE.
  ld   e,a                 ;24F0;
cat_run2:
  add  hl,de               ;24F1; Calculate total number of sectors.
  djnz cat_run2            ;24F2;
  pop  bc                  ;24F4;
  nop                      ;24F5; New code is two bytes shorter.
  nop                      ;24F6;
  ld   de,($3DD8)          ;24F7; Get number of used sectors.
  xor  a                   ;24FB; Clear carry.
  sbc  hl,de               ;24FC; Calculate number of free sectors.
  srl  h                   ;24FE; Divide it by two to get number of free
  rr   l                   ;2500; K-bytes.
  xor  a                   ;2502;
  call prt_n1000           ;2503; Print the number.
  ld   a,13                ;2506;
  call prt_a               ;2508; Print a newline.
  ret                      ;250B;

; ----------------------------------------------
; THE 'ERASE' COMMAND SYNTAX ROUTINE

; This routine checks that the command is in the form ERASE *n$ to erase a
; file or ERASE *n1$ TO n2$ to rename a file. The '*' stands for +D syntax
; ('d'd<;>) or Microdrive syntax ('"m"';d;).

erase_250C:
  ; XXX FIXME -- the original HTML defines `erase` twice
  rst  next_c              ;250C; Get next character.
  ld   (ufia1.lstr1),a     ;250D; Store the device descriptor.
  cp   '"'                 ;2510; Test for Microdrive syntax if it was a
  call z,md_syn1           ;2512; quote.
  call expt_devn           ;2515; Evaluate the drive number.
  call separator           ;2518; Test for a separator.
  jp   nz,rep_0            ;251B; Give error if none found.
  call expt_fname          ;251E; Evaluate filename.
  cp   token.to            ;2521; Is the filename followed by "TO"?
  jr   z,rename            ;2523; Jump if so, rename is wanted.
  call st_end_ram          ;2525; Confirm end of statement and exit
                                ; during syntax checking.
  ld   a,(ufia1.lstr1)     ;2528; Fetch device descriptor.
  and  $DF                 ;252B; Drop lower case bit.
  cp   "D"                 ;252D;
  jr   z,erase_run         ;252F; Jump if it was "D".
  cp   "M"                 ;2531;
  jp   nz,rep_10           ;2533; Give error if it wasn't "M".

; ----------------------------------------------
; THE 'ERASE A FILE' ROUTINE

; This routine deletes the specified file(s) on the specified drive. First it
; calls the routine 'FIND_FILE' to find a matching name, then it marks the
; file ERASEd by setting the directory description to 0, the dir. entry is
; then SAVEd back to disc.

erase_run:
  call test_drive.ufia1    ;2536; See if drive is defined.
erase_loop:
  call find_file_2559      ;2539; Find the file.
  jr   nz,not_found        ;253C; Jump if not found.
  ld   (hl),0              ;253E; Directory description 0 means ERASEd.
  call wsad                ;2540; Write sector DE.
  call sign_0              ;2543; Signal 'at least one file ERASEd'.
  jr   erase_loop          ;2546; ERASE all files with this filename.

not_found:
  call test_0              ;2548; Give an error if there wasn't at least
  jp   z,rep_26            ;254B; one file ERASEd.
erase_exit:
  ld   a,(ufia1.lstr1)     ;254E;
  cp   "D"                 ;2551; If the device descriptor was a
  call z,cat_1             ;2553; (capital) "D", then give a CATalogue.
  jp   the_end             ;2556; Finished.

; ----------------------------------------------
; THE 'FIND A FILE' SUBROUTINE

; This routine searches the directory for a matching filename by calling the
; +D ROM routine 'SCAN_CAT', it returns with HL pointing to the directory
; description of the matching file. This routine is also called by command
; code 65 routine.

find_file_2559:
  ; XXX FIXME -- the original HTML defines `find_file` twice
  ld   a,%00010000         ;2559; Scan the CATalogue for a matching
  call scan_cat            ;255B; filename.
  jp   rpt_hl              ;255E; Make HL point to the start of the dir.
                                ; entry buffer and exit.

; ----------------------------------------------
; THE 'RENAME A FILE' ROUTINE

; This routine renames a file by replacing its filename, given first, by the
; filename given second. It first tests whether the 'new' name isn't used
; already. If not, a check is made whether the file to be renamed exists.

rename:
  rst  next_c              ;2561; Get next character.
  call separator           ;2562; Check if there is a separator.
  jp   nz,rep_0            ;2565; Give an error if none found.
  call expt_2fnam          ;2568; Evaluate 2nd filename.
  call st_end_ram          ;256B; Confirm end of statement and exit when
                                ; syntax checking.
  ld   a,(ufia1.lstr1)     ;256E; Fetch device descriptor.
  and  $DF                 ;2571; Drop lower case bit.
  cp   "D"                 ;2573;
  jr   z,rename_run        ;2575; Jump if it was a "D".
  cp   "M"                 ;2577;
  jp   nz,rep_10           ;2579; Give error if it wasn't a "M".
rename_run:
  call test_drive.ufia1    ;257C; See if the drive is defined.
  call swap_ufias          ;257F; Swap UFIA 1 & 2 in the DFCA.
  call find_file_2559      ;2582; Does the 2nd filename exist?
  jp   z,rep_28            ;2585; Error 28 if it does exist.
  call swap_ufias          ;2588; Swap UFIA 1 & 2 in the DFCA.
  call find_file_2559      ;258B; Does the 1st filename exist?
  jp   nz,rep_26           ;258E; Error 26 if it doesn't exist.
  inc  hl                  ;2591; Point to the first filename
  push de                  ;2592; Save track and sector of its catalogue entry.
  ld   de,ufia2.nstr2      ;2593; Second filename.
  ex   de,hl               ;2596; HL=second filename; DE=first filename.
  ld   bc,10               ;2597; Filename length.
  ldir                     ;259A; Rename.
  pop  de                  ;259C; Restore track and sector.
  call wsad                ;259D; Write the CATalogue sector.
  jr   erase_exit          ;25A0; Exit via 'ERASE_EXIT'.


; ===============================================================
; The syntax checking routines

; ----------------------------------------------
; THE 'SEPARATOR' SUBROUTINE

; This small subroutine tests whether the current character is a separator or
; a quote. It returns with Zero flag set if it was a ";", "," or a """, with
; the first two A holds the next character.

separator:
  cp   ","                 ;25A2;
  jr   z,separ_1           ;25A4; Jump if current character is a comma.
  cp   ";"                 ;25A6;
  jr   z,separ_1           ;25A8; Jump if it is a semicolon.
  cp   '"'                 ;25AA;
  ret                      ;25AC; Return with Zero set if it's a quote.
separ_1:
  rst  next_c              ;25AD; Get next character.
  ld   ($3DEA),a           ;25AE;
  xor  a                   ;25B1; Set Zero flag.
  ld   a,($3DEA)           ;25B2;
  ret                      ;25B5;

; ----------------------------------------------
; THE 'EVALUATE STRING EXPR.' SUBROUTINE

; A call is made to the 'main' ROM 'EXPT_EXP' (class-0A) subroutine, to
; evaluate a string expression. During runtime, the parameters of the string
; (start and length) are returned in the DE and BC register pairs.

expt_str:
  rst  calbas              ;25B6; Evaluate the string expression.
  defw rom_expt_exp        ;25B7;
  rst  syntax_z            ;25B9;
  ret  z                   ;25BA; Return if syntax is being checked.
  push af                  ;25BB; Save the character following the string
  rst  calbas              ;25BC; and the zero flag.
  defw rom_stk_fetch       ;25BD; Fetch the string parameters.
  pop  af                  ;25BF;
  ret                      ;25C0;

; ----------------------------------------------
; THE 'EVAL. MICRODRIVE SYNTAX' SUBROUTINE

; This subroutine is entered at 'MD_SYNTAX' or 'MD_SYNTAX1' depending upon
; whether or not the character pointer is to be updated to the next character.
; A single character string is evaluated, and its ASCII value is stored during
; runtime. If a separator isn't present after the single character string, an
; error is given.

md_syntax:
  rst  next_c              ;25C1; Next character.
md_syn1:
  call expt_str            ;25C2;
  jr   z,md_syn2           ;25C5; Jump if syntax is being checked.
  push af                  ;25C7; Save the character following the
  ld   a,c                 ;25C8; string. A holds string length low byte.
  dec  a                   ;25C9;
  or   b                   ;25CA; Give an error if there isn't exactly
  jp   nz,rep_10           ;25CB; one character in the string.
  ld   a,(de)              ;25CE; Fetch the channel specifier.
  rst  calbas              ;25CF; Call 'ALPHA' to see if it's a valid
  defw rom_alpha           ;25D0; letter.
  jp   nc,rep_10           ;25D2; Give error if not a valid letter.
  ld   (ufia1.lstr1),a     ;25D5; Store the specifier in the UFIA.
  pop  af                  ;25D8; Restore next character.
md_syn2:
  cp   ";"                 ;25D9;
  ret  z                   ;25DB; Return if it's a semicolon.
  cp   ","                 ;25DC;
  ret  z                   ;25DE; Return if it's a comma.
  jp   rep_0               ;25DF; Otherwise give error.

; ----------------------------------------------
; THE 'EVALUATE DEVICE NUMBER' SUBROUTINE

; This subroutine is used to evaluate the device number.

expt_devn:
  and  $DF                 ;25E2; Make upper case.
  cp   "P"                 ;25E4;
  jr   nz,expt_devn1       ;25E6; Jump if the device wasn't "P".
  rst  next_c              ;25E8; Next character.
  call expt_num            ;25E9; Get the program number.
  ret  z                   ;25EC; Return if syntax checking.
  push af                  ;25ED;
  ld   a,(ufia1)           ;25EE; Store program number. XXX TODO -- program number?
  ld   (ufia1.fstr1),a     ;25F1;
  call last_drv            ;25F4; Drive is last drive.
  pop  af                  ;25F7;
  ret                      ;25F8;

; Now a check is made whether the last used device is wanted.

expt_devn1:
  rst  next_c              ;25F9; Get next character.
expt_devn2:
  cp   "*"                 ;25FA;
  jr   nz,expt_num         ;25FC; Jump if it wasn't a "*".
  rst  syntax_z            ;25FE;
  call nz,last_drv         ;25FF; Store last drive number during runtime.
  rst  next_c              ;2602; Next character.
  ret                      ;2603;

; ----------------------------------------------
; THE 'SET LAST DRIVE' SUBROUTINE

; This subroutine is used whenever the last used drive is to be used again.

last_drv:
  ld   a,(control_port_status) ;2604; Fetch current control port status.
  and  $01                 ;2607; Keep only drive select.
  add  a,$01               ;2609; A holds 1 for drive 2, 2 for drive 1.
  xor  $03                 ;260B; 1 becomes 2, 2 becomes 1.
  ld   (ufia1.dstr1),a     ;260D; Store drive number.
  ret                      ;2610;

; ----------------------------------------------
; THE 'EVALUATE NUMERIC EXPR.' SUBROUTINE

; This subroutine is used to evaluate a single numeric expression. The result
; is returned during runtime into the BC register pair and into UFIA1.

expt_num:
  rst  calbas              ;2611; Evaluate the expression by calling
  defw rom_expt_1num       ;2612; 'EXPT_1NUM' in the 'main' ROM.
  rst  syntax_z            ;2614;
  ret  z                   ;2615; Return if syntax is being checked.
  push af                  ;2616;
  rst  calbas              ;2617; Fetch the value from the calculator
  defw rom_find_int2       ;2618; stack.
  ld   a,c                 ;261A;
  ld   (ufia1),a           ;261B; Store it in UFIA1.
  pop  af                  ;261E;
  ret                      ;261F;

; ----------------------------------------------
; THE 'EVALUATE 2ND FILENAME' SUBROUTINE

; This routine evaluates the second filename of a BASIC command. Because
; 'EXP_F_NAME' stores the filename in UFIA1, both UFIAS are swapped first,
; then 'EXP_F_NAME' is called and an exit is made via 'SWAP_UFIAS' to get the
; UFIA's in the right place again.

expt_2fnam:
  call swap_ufias          ;2620; Swap UFIA1 and 2.
  call expt_fname          ;2623; Evaluate filename.
                                ; Exit via 'SWAP_UFIAS'.
; ----------------------------------------------
; THE 'SWAP UFIAS' SUBROUTINE

; This subroutine swaps the contents of UFIA1 and UFIA2 in DFCA.

swap_ufias:
  push af                  ;2626;
  push bc                  ;2627;
  push de                  ;2628;
  push hl                  ;2629;
  ld   b,24                ;262A; An UFIA is 24 bytes long.
  ld   de,ufia1            ;262C; Start of UFIA1.
  ld   hl,ufia2            ;262F; Start of UFIA2.
swap_loop:
  ld   a,(de)              ;2632; Exchange the contents.
  ld   c,(hl)              ;2633;
  ex   de,hl               ;2634;
  ld   (de),a              ;2635;
  ld   (hl),c              ;2636;
  inc  de                  ;2637;
  inc  hl                  ;2638;
  djnz swap_loop           ;2639; Repeat for all 24 bytes.
  pop  hl                  ;263B;
  pop  de                  ;263C;
  pop  bc                  ;263D;
  pop  af                  ;263E;
  ret                      ;263F;

; ----------------------------------------------
; THE 'EVALUATE A FILENAME' SUBROUTINE

; A string expression is evaluated and, provided that the length is within the
; range 1..10 characters, is stored in UFIA1.

expt_fname:
  call expt_str            ;2640; Evaluate the string.
  ret  z                   ;2643; Return if checking syntax.
  push af                  ;2644;
  ld   a,c                 ;2645;
  or   b                   ;2646;
  jp   z,rep_8             ;2647; Give error with null string.
  ld   hl,10               ;264A;
  sbc  hl,bc               ;264D;
  jp   c,rep_8             ;264F; Give error with string length > 10.
  ld   hl,ufia1.nstr1      ;2652; Clear the filename and the directory
  ld   a,11                ;2655; description of UFIA1.
clr_fname:
  ld   (hl),32             ;2657;
  inc  hl                  ;2659;
  dec  a                   ;265A;
  jr   nz,clr_fname        ;265B; Repeat for all 11 bytes.
  ld   hl,ufia1.nstr2      ;265D; Copy the filename into UFIA1.
  ex   de,hl               ;2660;
  ldir                     ;2661;
  pop  af                  ;2663;
  ret                      ;2664;

; ----------------------------------------------
; THE 'EVALUATE PARAMETERS' SUBROUTINE

; This very important subroutine is called to evaluate the syntax of the +D
; 'SAVE', 'LOAD', 'MERGE' and 'VERIFY' commands. The routine is entered with
; CH_ADD pointing to the command; on exit during runtime UFIA1 is filled with
; the proper values.

expt_parms:
  rst  next_c              ;2665; Get next character from BASIC line.
  cp   " "                 ;2666; Give an error with character codes
  jp   c,rep_0             ;2668; below 32, i.e. colour codes, etc.
  cp   token.screen_dollar ;266B; 'SCREEN$'
  jp   z,dump_scr          ;266D; Jump with 'SCREEN$'.
  ld   (ufia1.lstr1),a     ;2670; Otherwise store it in DEV_TYPE1.
  cp   "@"                 ;2673;
  jr   nz,not_at_sign      ;2675; Jump if not a '@'.

; Now deal with @.

  call expt_devn           ;2677; Evaluate drive number.
  call separator           ;267A;
  jp   nz,rep_2            ;267D; Give error if no separator was found.
  rst  calbas              ;2680; Call 'EXPT_1NUM' to evaluate the track
  defw rom_expt_1num       ;2681; number.
  call separator           ;2683; Test for another separator and give an
  jp   nz,rep_2            ;2686; error if none found.
  rst  calbas              ;2689; Evaluate sector number.
  defw rom_expt_1num       ;268A;
  call separator           ;268C; Again a separator has to be found.
  jp   nz,rep_2            ;268F;
  rst  calbas              ;2692; Evaluate address.
  defw rom_expt_1num       ;2693;
  call st_end_ram          ;2695; Confirm end of statement, and exit
                                ; during syntax checking.
  rst  calbas              ;2698; Fetch the address from the calculator
  defw rom_find_int2       ;2699; stack.
  ld   (ufia1.hd0f),bc     ;269B; Store it in LENGTH1_2
  rst  calbas              ;269F; Fetch sector.
  defw rom_find_int2       ;26A0;
  ld   (ufia1.hd0d),bc     ;26A2; Store it in FILE_ADDR1
  rst  calbas              ;26A6; Fetch track.
  defw rom_find_int2       ;26A7;
  ; XXX FIXME -- the original HTML has a typo in the previous ROM label
  ld   (ufia1.hd0b),bc     ;26A9; Store it in LENGTH1_1
  ret                      ;26AD; Exit.

not_at_sign:
  cp   "*"                 ;26AE; Call 'MD_SYNTAX' if it was a "*".
  call z,md_syntax         ;26B0;
  call expt_devn           ;26B3; Fetch device or program number.
  call separator           ;26B6; Test for a separator.
  push af                  ;26B9;
  rst  syntax_z            ;26BA;
  jr   z,filename          ;26BB; Jump if syntax checking.
  ld   a,(ufia1.lstr1)     ;26BD; Fetch device descriptor.
  and  $DF                 ;26C0; Only capitals.
  cp   "D"                 ;26C2;
  jr   z,not_at_sign1      ;26C4; Jump if device is disk.
  cp   "M"                 ;26C6;
  jr   z,not_at_sign1      ;26C8; Or disk with Microdrive syntax.
  cp   "P"                 ;26CA;
  jr   z,params            ;26CC; Jump with program.
  jp   nz,rep_10           ;26CE; Give error with unknown device.
not_at_sign1:
  pop  af                  ;26D1; Give error if no separator or quote
  jp   nz,rep_0            ;26D2; found with devices "D" and "M".
  push af                  ;26D5; Balance 'POP AF' below.
filename:
  pop  af                  ;26D6;
  call z,expt_fname        ;26D7; Evaluate filename if necessary.
  push af                  ;26DA; Balance next instruction.
params:
  pop  af                  ;26DB;
  cp   13                  ;26DC;
  jp   z,no_params         ;26DE; Jump with ENTER.
  cp   ":"                 ;26E1;
  jp   z,no_params         ;26E3; Jump with colon.
  cp   token.to            ;26E6;
  jp   z,to                ;26E8; Jump with 'TO'.
  cp   token.screen_dollar ;26EB;
  jp   z,screen_dollar     ;26ED; Jump with 'SCREEN$'.
  cp   token.code          ;26F0;
  jp   z,code              ;26F2; Jump with 'CODE'.
  cp   token.data          ;26F5;
  jp   z,data              ;26F7; Jump with 'DATA'.
  cp   token.line          ;26FA;
  jp   z,line              ;26FC; Jump with 'LINE'.
  and  $DF                 ;26FF; Only capitals.
  cp   "S"                 ;2701;
  jr   nz,not_s            ;2703; Jump with other than 'S'.
  rst  next_c              ;2705; Next character.
  call st_end_ram          ;2706; Confirm end of statement and exit
                                ; during syntax checking.
  ld   a,5                 ;2709; Signal '48K Snapshot'.
  ld   (ufia1.nstr1),a     ;270B;
  ret                      ;270E; Finished.

not_s:
  cp   "K"                 ;270F;
  jr   nz,not_k            ;2711; Jump with other than 'K'.
  rst  next_c              ;2713; Next character.
  call st_end_ram          ;2714; Confirm end of statement and exit
                                ; during syntax checking.
  ld   a,9                 ;2717; Signal '128K Snapshot'.
  ld   (ufia1.nstr1),a     ;2719;
  ret                      ;271C; Finished.

not_k:
  cp   "X"                 ;271D;
  jp   nz,rep_0            ;271F; Give error with other than 'X'.
  rst  next_c              ;2722; Next character.
  call separator           ;2723; Jump if a separator found, there is
  jr   z,xfile_1           ;2726; more.
  call test_5              ;2728; There must follow a address if SAVEing.
  jp   nz,rep_2            ;272B; Give error if SAVEing.
  call st_end_ram          ;272E; Confirm end of statement and exit
                                ; during syntax checking.
  ld   bc,$3BD6            ;2731; Load address of execute file.
  jr   xfile_2             ;2734; Jump forward.

; A separator has been found, so there should follow an address.

xfile_1:
  rst  calbas              ;2736; Evaluate address.
  defw rom_expt_1num       ;2737;
  call st_end_ram          ;2739; Confirm end of statement and exit
                                ; during syntax checking.
  rst  calbas              ;273C; Fetch the address.
  defw rom_find_int2       ;273D;
xfile_2:
  ld   (ufia1.hd0d),bc     ;273F; Store it in FILE_ADDR1
  ld   bc,510              ;2743; Length of execute file on double density disks.
  ld   a,(control_port_status)  ;2746;
  and  $04                 ;2749;
  jr   z,xfile_3           ;274B; Jump if double density selected.
  ld   bc,254              ;274D; Otherwise this is the length of the
                                ; execute file.
xfile_3:
  ld   (ufia1.hd0b),bc     ;2750; Store length in LENGTH1_1.
  ld   a,3                 ;2754; File type is 'CODE'.
  ld   (ufia1.hd00),a      ;2756; Store it in FILE_TYPE1.
  ld   a,11                ;2759; Signal 'Execute file'.
  ld   (ufia1.nstr1),a     ;275B; Store in DIR_DESCR1
  ret                      ;275E; Finished.

; Now deal with LINE. The +D allows LOAD, VERIFY and MERGE .. LINE to be
; entered as a command but the LINE is completely ignored.

line:
  rst  next_c              ;275F; Advance CH_ADD.
  rst  calbas              ;2760; Evaluate autostart line number by
  defw rom_expt_1num       ;2761; calling 'EXPT_1NUM' in the 'main' ROM.
  call st_end_ram          ;2763; Confirm end of statement, and exit
                                ; during syntax checking.
  rst  calbas              ;2766; Fetch the autostart line number.
  defw rom_find_int2       ;2767;
  ld   (ufia1.hd11),bc     ;2769; Store it in AUTOSTART1.
  jr   prog                ;276D;

; If there are no parameters, as with a BASIC program, the syntax checking
; ends here.

no_params:
  call st_end_ram          ;276F; Confirm end of statement, exit when
                                ; syntax checking.
prog:
  ld   a,(ufia1.lstr1)     ;2772;
  and  $DF                 ;2775; Only capitals.
  cp   "P"                 ;2777; Jump if the device wasn't "P", i.e. no
  jr   nz,prog_1           ;2779; program number was specified.
  call test_5              ;277B; 'SAVE pn' is not supported, so give an
  ret  z                   ;277E; error if saving, otherwise return.
  jp   rep_0               ;277F;

prog_1:
  xor  a                   ;2782; File type is 'BASIC'.
  ld   (ufia1.hd00),a      ;2783;
  ld   a,1                 ;2786; Signal 'BASIC file'.
  ld   (ufia1.nstr1),a     ;2788;
  ld   hl,(23641)          ;278B; Fetch (E_LINE), the first location past
                                ; the variables area.
  ld   de,(23635)          ;278E; Fetch (PROG), the 'start' of the BASIC
  ld   (ufia1.hd0d),de     ;2792; program and store it in FILE_ADDR1
  scf                      ;2796; Calculate ((E_LINE)-(PROG)-1), i.e.  the
  sbc  hl,de               ;2797; length of the program and its
  ld   (ufia1.hd0b),hl     ;2799; variables. Store it in LENGTH1_1.
  ld   hl,(23627)          ;279C; Fetch (VARS) and calculate
  sbc  hl,de               ;279F; (VARS)-(PROG), i.e. the length of the
                                ; program without its variables.
  ld   (ufia1.hd0f),hl     ;27A1; Store it into LENGTH1_2.
  ret                      ;27A4; Finished.

; If the token is SCREEN$, the parameters are entered directly into the file
; header.

screen_dollar:
  rst  next_c              ;27A5; Get the next character.
  call st_end_ram          ;27A6; Confirm end of statement and exit
                                ; during syntax checking.
  ld   hl,6912             ;27A9; The size of the display file is stored
  ld   (ufia1.hd0b),hl     ;27AC; into LENGTH1_1.
  ld   hl,16384            ;27AF; The startaddress is stored into
  ld   (ufia1.hd0d),hl     ;27B2; FILE_ADDR1
  ld   a,3                 ;27B5; File type is 'CODE'.
  ld   (ufia1.hd00),a      ;27B7;
  ld   a,7                 ;27BA; Signal 'SCREEN$'.
  ld   (ufia1.nstr1),a     ;27BC;
  ret                      ;27BF;

; Now deal with CODE, three parameters are needed: "start", "length" and
; "execute address". With LOAD there may be none, one, two or three
; parameters, but with SAVE at least two parameters must be present.

code:
  rst  next_c              ;27C0; Update CH_ADD.
  cp   13                  ;27C1; If there are no further parameters,
  jr   z,code_1            ;27C3; jump to use '0' as default value.
  cp   ":"                 ;27C5; Jump if there are parameters to be
  jr   nz,code_2           ;27C7; evaluated (i.e. the next character is
                                ; not a colon).
code_1:
  call test_5              ;27C9; 'SAVE .. CODE' has to be followed by at
  jp   nz,rep_2            ;27CC; least two numbers, so give an error if
                                ; none present.
  rst  calbas              ;27CF; A call to the 'main' ROM routine
  defw rom_use_zero        ;27D0; 'USE_ZERO' is made to use a value of
  jr   code_3              ;27D2; zero as default.

; It's likely that an address follows.

code_2:
  rst  calbas              ;27D4; Use the 'main' ROM routine to evaluate
  defw rom_expt_1num       ;27D5; the first parameter.
  call separator           ;27D7;
  jr   z,code_4            ;27DA; Jump if a separator is present.
code_3:
  call test_5              ;27DC; Give an error if there isn't a second
  jp   nz,rep_2            ;27DF; number with 'SAVE .. CODE'.
  rst  calbas              ;27E2; Otherwise use zero as default.
  defw rom_use_zero        ;27E3;
  jr   code_5              ;27E5;

; The length seems to be present also.

code_4:
  rst  calbas              ;27E7; Evaluate the second parameter.
  defw rom_expt_1num       ;27E8;
  call separator           ;27EA; Jump if a second separator is found.
  jr   z,code_6            ;27ED;
code_5:
  rst  calbas              ;27EF; Otherwise zero is default.
  defw rom_use_zero        ;27F0;
  jr   code_7              ;27F2;

; There's even an execute address.

code_6:
  rst  calbas              ;27F4; Evaluate the third parameter.
  defw rom_expt_1num       ;27F5;
code_7:
  call st_end_ram          ;27F7; Confirm end of statement and exit
                                ; during syntax checking.
  rst  calbas              ;27FA; Fetch the "autoexecute" address from
  defw rom_find_int2       ;27FB; the calculator stack and store it into
  ld   (ufia1.hd11),bc     ;27FD; AUTOSTART1
  rst  calbas              ;2801; Fetch the "length".
  defw rom_find_int2       ;2802;
  ld   (ufia1.hd0b),bc     ;2804; Store it into LENGTH1_1
  rst  calbas              ;2808; Fetch the "start".
  defw rom_find_int2       ;2809;
  ld   (ufia1.hd0d),bc     ;280B; Store it into FILE_ADDR1
  ld   a,3                 ;280E; File type is 'CODE'.
  ld   (ufia1.hd00),a      ;2811;
  ld   a,4                 ;2814; Signal 'CODE file'.
  ld   (ufia1.nstr1),a     ;2816;
  ret                      ;2819; Finished.

; Finally the routine to evaluate DATA parameters.

data:
  call test_6              ;281A; Give an error if attempting to MERGE an
  jp   nz,rep_14           ;281D; array.
  rst  next_c              ;2820; Next character.
  rst  calbas              ;2821; Call LOOK_VARS to look for the array
  defw rom_look_vars       ;2822; name.
  set  7,c                 ;2824;
  jr   nc,data_1           ;2826; Jump if handling an existing array or
                                ; if syntax checking.
  ld   hl,$0000            ;2828; Signal 'using a new array'.
  call test_4              ;282B;
  jr   nz,data_3           ;282E; Jump if LOADing the array.
  jp   rep_11              ;2830; Otherwise give error 'Variable not
                                ; found'.
data_1:
  jp   nz,rep_0            ;2833; Give error if not an array variable.

; NOTE: This test fails to exclude simple strings, but the 'bug' (present in
; the 'main' ROM) is corrected at $283E.

  rst  syntax_z            ;2836;
  jr   z,data_5            ;2837; Jump if syntax is being checked.
  call test_5              ;2839;
  jr   z,data_2            ;283C; Jump if LOADing.
  bit  7,(hl)              ;283E; Give an error if trying to SAVE a
  jp   z,rep_0             ;2840; simple string.
data_2:
  inc  hl                  ;2843; Point to the 'length' of the array.
  ld   a,(hl)              ;2844; Store the length into LENGTH1_1.
  ld   (ufia1.hd0b),a      ;2845;
  inc  hl                  ;2848;
  ld   a,(hl)              ;2849;
  ld   ($3E12),a           ;284A;
  inc  hl                  ;284D; Advance to the start of the array.
data_3:
  ld   a,c                 ;284E; Store array name into LSB of LENGTH1_2.
  ld   (ufia1.hd0f),a      ;284F;
  ld   a,1                 ;2852; File type is 'NUM ARRAY'.
  bit  6,c                 ;2854;
  jr   z,data_4            ;2856; Jump if really a numeric array.
  inc  a                   ;2858; File type is 'STR ARRAY'.
data_4:
  ld   (ufia1.hd00),a      ;2859; Store file type into FILE_TYPE1.
  inc  a                   ;285C; Signal: (A=2) 'Numeric array',
  ld   (ufia1.nstr1),a     ;285D; (A=3) 'String array'.
data_5:
  ex   de,hl               ;2860; DE holds 'start' of the array (or $0000
                                ; with a 'new' array to be LOADed).
  rst  next_c              ;2861; Next character.
  cp   ")"                 ;2862; Check that the ')' does exist.
  jp   nz,rep_2            ;2864; Report an error if not.
  rst  next_c              ;2867; Next character.
  call st_end_ram          ;2868; Confirm end of statement and exit
                                ; during syntax checking.
  ld   (ufia1.hd0d),de     ;286B; Store "start" of the array into
  ret                      ;286F; FILE_ADDR1 and exit.


; ===============================================================
; The BASIC command execution routines II

; ----------------------------------------------
; THE 'GET TRACK AND SECTOR' SUBROUTINE

; This routine loads DE with track and sector number from the file header,
; where they were stored by the 'EXPT_PARMS' subroutine. Used with LOAD/SAVE
; @.

get_tr_and_se:
  ld   a,(ufia1.hd0b)      ;2870; Get track from LSB of LENGTH1_1.
  ld   d,a                 ;2873;
  ld   a,(ufia1.hd0d)      ;2874; Get sector from LSB of FILE_ADDR1.
  ld   e,a                 ;2877;
  ret                      ;2878;

; ----------------------------------------------
; THE 'SAVE HEADER 1' SUBROUTINE

; This subroutine SAVEs the 9 bytes header from UFIA 1 to the file and to the
; catalogue entry which is build up in the DFCA.

save_head1:
  ld   hl,ufia1.hd00       ;2879; Start of header 1.
  ld   de,$3BA9            ;287C; Address of header area of a catalogue
                                ; entry
  ld   b,9                 ;287F; The headers length.
save_h11:
  ld   a,(hl)              ;2881;
  ld   (de),a              ;2882;
  call sbyt                ;2883; Save the byte to the file.
  inc  hl                  ;2886;
  inc  de                  ;2887;
  djnz save_h11            ;2888; Repeat for all nine bytes.
  ret                      ;288A; Finished.

; ----------------------------------------------
; THE 'SAVE' COMMAND SYNTAX ROUTINE

; This routine checks that the SAVE command has the appropriate syntax.

save:
  ld   ix,dfca             ;288B;
  call sign_5              ;288F; Signal 'SAVEing'.
  call expt_parms          ;2892; Evaluate & store all parameters.
  call test_drive.ufia1    ;2895; See if the drive is defined.
  ld   a,(ufia1.lstr1)     ;2898;
  cp   "@"                 ;289B;
  jr   nz,save_run         ;289D; Jump if the command wasn't 'SAVE @'.
  ld   ix,(ufia1.hd0f)     ;289F; Get address where sector is to be saved
  call get_tr_and_se       ;28A3; from. Get track and sector number.
  ld   a,(ufia1.dstr1)     ;28A6; Get drive number.
  call hwsad               ;28A9; Write the sector.
  jp   the_end             ;28AC; Finished.

; ----------------------------------------------
; THE 'SAVE A FILE' ROUTINE

; This routine SAVEs the specified file on the specified drive.

save_run:
  call ofsm_2              ;28AF; Open the file for 'SAVE'.
  jp   nz,erase_exit       ;28B2; Exit if the file isn't to be
                                ; overwritten.
  ld   a,(ufia1.nstr1)     ;28B5;
  cp   11                  ;28B8; Pass the header to the file unless it's
  call nz,save_head1       ;28BA; an 'execute' file.
  ld   hl,(ufia1.hd0d)     ;28BD; Fetch the start address.
  ld   de,(ufia1.hd0b)     ;28C0; Fetch the length.
  call hsvbk_2             ;28C4; Save the block.
  call cfsm                ;28C7; Close the file.
  jp   erase_exit          ;28CA; Exit via 'ERASE_EXIT'.

; ----------------------------------------------
; THE 'LOAD HEADER INTO UFIA 2' SUBROUTINE

; This subroutine LOADs a 9 bytes header into UFIA 2.

load_head2:
  ld   hl,ufia2.hd00       ;28CD; Start of HEADER 2.
  ld   b,9                 ;28D0; Length of a header.
load_h21:
  call lbyt                ;28D2; Load a byte.
  ld   (hl),a              ;28D5; Store it into UFIA 2.
  inc  hl                  ;28D6;
  djnz load_h21            ;28D7; Repeat for all header bytes.
  ret                      ;28D9;

; ----------------------------------------------
; THE 'LOAD' COMMAND SYNTAX ROUTINE

; The 'LOAD' flag is set and the routine continues into the
; 'LOAD_VERIFY_MERGE' routine below.

load:
  call sign_4              ;28DA; Signal 'LOADing'.
  jr   ld_vf_mr            ;28DD;

; ----------------------------------------------
; THE 'VERIFY' COMMAND SYNTAX ROUTINE

; The 'VERIFY' flag is set and again the 'LOAD_VERIFY_MERGE' routine handles
; the rest.

verify:
  call sign_7              ;28DF; Signal 'VERIFYing'.
  jr   ld_vf_mr            ;28E2;

; ----------------------------------------------
; THE 'MERGE' COMMAND SYNTAX ROUTINE

; The 'MERGE' flag is set and 'LOAD_VERIFY_MERGE' continues the syntax
; checking.

merge:
  call sign_6              ;28E4; Signal 'MERGEing'.

; ----------------------------------------------
; THE 'LOAD_VERIFY_MERGE' COMMAND ROUTINE

; This routine checks the syntax of the LOAD, VERIFY and MERGE commands and
; executes it.

ld_vf_mr:
  ld   ix,dfca             ;28E7;
  call expt_parms          ;28EB; Evaluate & store all parameters.
ld_vf_mr1:
  call test_drive.ufia1    ;28EE; See if the drive is defined.
  ld   a,(ufia1.lstr1)     ;28F1;
  cp   "@"                 ;28F4;
  jr   nz,ld_etc_run       ;28F6; Jump if it wasn't a '@' command.
  ld   ix,(ufia1.hd0f)     ;28F8; Get address where sector is to be
  call get_tr_and_se       ;28FC; loaded. Get track and sector number.
  ld   a,(ufia1.dstr1)     ;28FF; Get drive number.
  call hrsad               ;2902; Load the sector.
  jp   the_end             ;2905; Finished.

; The routine continues here when a file is to be LOADed from disk.

ld_etc_run:
  call hgfle_2             ;2908; Open the file for loading.
  ld   a,(ufia1.nstr1)     ;290B;
  cp   5                   ;290E;
  jr   nz,ld_etc_r1        ;2910; Jump if it isn't a 'Snapshot 48K'.
  ld   sp,$3FEA            ;2912; Use internal stack.
  ld   hl,16384            ;2915; Start address and length of a 48K Snap.
  ld   de,49152            ;2918;
  call load_file           ;291B; Load the file.
  jp   snap_exit           ;291E; Exit via 'SNAP_EXIT'.

ld_etc_r1:
  cp   9                   ;2921;
  jr   nz,ld_etc_r3        ;2923; Jump if it isn't a 'Snapshot 128K'.
  ld   sp,$3FEA            ;2925; Use internal stack.
  call lbyt                ;2928; Get the page configuration byte.
  push af                  ;292B;
  and  $F8                 ;292C; Keep the RAM page bits only.
  ld   b,$08               ;292E; LOAD the eight RAM-pages.
ld_etc_r2:
  push af                  ;2930;
  push bc                  ;2931;
  call rampage_a           ;2932; Page in RAM bank.
  ld   hl,49152            ;2935; Start address and length of each RAM
  ld   de,16384            ;2938; bank.
  call load_file           ;293B; 'LOAD DE bytes to HL'.
  pop  bc                  ;293E;
  pop  af                  ;293F;
  inc  a                   ;2940; Next RAM bank.
  djnz ld_etc_r2           ;2941; Repeat for each RAM bank.
  pop  af                  ;2943; Retrieve page configuration.
  call rampage_a           ;2944; Page in the right RAM, ROM and SCR$
  jp   snap_exit           ;2947; bank, exit via 'SNAP_EXIT'.

ld_etc_r3:
  cp   11                  ;294A;
  jr   nz,ld_etc_r4        ;294C; Jump if it isn't a 'Execute' file.
  call $3BD6               ;294E; Execute (this is the address of the
  jp   the_end             ;2951; disk buffer). Finished.

ld_etc_r4:
  call load_head2          ;2954; Load the header into UFIA2.
  ld   a,(ufia1.hd00)      ;2957; Fetch type of program to be LOADed.
  ld   b,a                 ;295A;
  ld   a,(ufia2.hd00)      ;295B; Fetch type of program found.
  cp   b                   ;295E;
  jp   nz,rep_8            ;295F; Give an error if they aren't equal.

; NOTE: The error 'Invalid FILE NAME' is given, maybe MGT have made a typing
; error. 'Wrong FILE type' is the right message.

  cp   3                   ;2962;
  jr   z,ld_etc_r5         ;2964; Jump if it's a 'CODE' file.
  jp   nc,rep_8            ;2966; Give error if file type >= 4.
  call test_6              ;2969;
  jr   nz,merge_ctrl       ;296C; Jump if 'MERGEing'.
  call test_7              ;296E; Jump if not 'VERIFYing' (i.e. doing a
  jp   z,load_ctrl         ;2971; LOAD).

; Now deal with loading of all files with type 3, like 'CODE' and 'SCREEN$',
; or verifying of all file types.

ld_etc_r5:
  call test_6              ;2974;
  jp   nz,rep_14           ;2977; Give error if 'MERGE .. CODE' was used.
  ld   hl,(ufia1.hd0b)     ;297A; Fetch length of requested file.
  ld   de,(ufia2.hd0b)     ;297D; Fetch length of file found.
  ld   a,h                 ;2981;
  or   l                   ;2982;
  jr   z,ld_etc_r6         ;2983; Jump if length unspecified.
  sbc  hl,de               ;2985; Jump if file to be LOADed is shorter
  jr   nc,ld_etc_r6        ;2987; than or of equal length as the
                                ; requested file.
  call test_4              ;2989;
  jp   z,rep_12            ;298C; 'VERIFY failed' if not LOADing.
  jp   rep_15              ;298F; 'CODE error' otherwise.

ld_etc_r6:
  ld   hl,(ufia1.hd0d)     ;2992; Fetch start address from FILE_ADDR1
  ld   a,h                 ;2995;
  or   l                   ;2996;
  jr   nz,ld_etc_r7        ;2997; Jump if a start address was specified.
  ld   hl,(ufia2.hd0d)     ;2999; Otherwise use the start address of the
                                ; found file.
ld_etc_r7:
  ld   a,(ufia2.hd00)      ;299C; But if the file is a BASIC program the
  and  a                   ;299F; start address is held in (PROG).
  jr   nz,ld_etc_r8        ;29A0;
  ld   hl,(23635)          ;29A2; Fetch 'start' from (PROG).
ld_etc_r8:
  call lv_any              ;29A5; Load the file.
  call test_7              ;29A8;
  jp   nz,the_end          ;29AB; Exit when 'VERIFYing'.
  ld   hl,(ufia1.hd11)     ;29AE; Fetch execute address.
  call exec_code           ;29B1; Use it if it was specified.
  ld   hl,(ufia2.hd11)     ;29B4; Otherwise use the files execute
  call exec_code           ;29B7; address.
  jp   the_end             ;29BA; But if it hasn't one either, exit here.

; ----------------------------------------------
; THE 'EXECUTE CODE FILE' SUBROUTINE

; This routine jumps to the address in the HL register pair (if it is valid)
; after pushing the addresses of 'STMT_R_1' and 'STACK_BC'.

exec_code:
  ld   a,h                 ;29BD;
  or   l                   ;29BE;
  ret  z                   ;29BF; Return if the execute address is zero.
  ld   a,h                 ;29C0;
  cp   $FF                 ;29C1;
  jr   nz,exec_c1          ;29C3;
  ld   a,l                 ;29C5; Also return when the execute address is
  cp   $FF                 ;29C6; $FFFF.
  ret  z                   ;29C8;
exec_c1:
  ld   sp,(23613)          ;29C9; Clear the stack. (ERR_SP)
  ld   (iy+0),$FF          ;29CD; Clear the error.
  call bord_rest           ;29D1; Restore the border colour.
  ld   bc,rom_stmt_r_1     ;29D4; Return to 'STMT_R_1' in the 'main' ROM
  push bc                  ;29D7; when finished.
  ld   bc,rom_stack_bc     ;29D8; Return to 'STMT_R_1' via 'STACK_BC'
  push bc                  ;29DB; also in the 'main' ROM.
  jp   unpage_hl           ;29DC; Jump to the execute address while
                                ; unpaging the +D.

; ----------------------------------------------
; THE 'MERGE CONTROL' ROUTINE

; This routine handles the MERGEing of a (BASIC) file. No test is made if the
; file is an array when using the MERGE 'p'n syntax (see NOTE at 'LOAD
; CONTROL').

merge_ctrl:
  ld   bc,(ufia2.hd0b)     ;29DF; Fetch the length of the program to be
  push bc                  ;29E3; MERGEd.
  inc  bc                  ;29E4; Extra location for the 'end marker'.
  rst  calbas              ;29E5; Call 'BC_SPACES' in the 'main' ROM to
  defw rom_bc_spaces       ;29E6; make the required room in workspace.
  ld   (hl),128            ;29E8; Mark the end.
  ex   de,hl               ;29EA; Move start pointer to HL.
  pop  de                  ;29EB; Length to DE.
  push hl                  ;29EC;
  call lv_any              ;29ED; Load the file.
  pop  hl                  ;29F0; Fetch 'start' of new program.
  ld   de,(23635)          ;29F1; Fetch 'start' of old program (PROG).
  rst  calbas              ;29F5; Do the MERGEing by calling the 'main'
  defw rom_me_new_lp       ;29F6; ROM 'MERGE' routine.
  jp   the_end             ;29F8; Finished.

; ----------------------------------------------
; THE 'LOAD CONTROL' ROUTINE

; This routine handles the LOADing of a BASIC program or an array.  NOTE: The
; Spectrum will crash when trying to LOAD or MERGE 'p' an array. The problem
; starts in the 'HGFLE_2' ('OPEN A FILE FOR LOAD') subroutine in ROM ($0BCF)
; which is called from the 'LD_ETC_RUN' routine at $2908. Normally UFIA1 holds
; the parameters of the existing array (if present), and UFIA2 holds the
; parameters of the array to be loaded. But when the 'p' syntax is used, the
; 'HGFLE_2' routine makes the contents of UFIA1 equal to UFIA2. The reclaiming
; at address $2A32 then fails, trying to reclaim something which isn't there.

load_ctrl:
  ld   de,(ufia2.hd0b)     ;29FB; Fetch 'new' length.
  ld   hl,(ufia1.hd0d)     ;29FF; Fetch 'old' start (=0 when loading a
  push hl                  ;2A02; 'new' array').
  ld   a,h                 ;2A03;
  or   l                   ;2A04;
  jr   nz,load_c1          ;2A05; Jump if not a 'new' array.
  inc  de                  ;2A07; Increment 'length' by 3, i.e. allows
  inc  de                  ;2A08; for the insertion of array name and
  inc  de                  ;2A09; two-byte length.
  ex   de,hl               ;2A0A; Move 'length' to HL.
  jr   load_c2             ;2A0B; Jump forward.

; The array to be loaded replaces an existing array.

load_c1:
  ld   hl,(ufia1.hd0b)     ;2A0D; Fetch 'old' length (i.e. length of
                                ; existing program or array) from UFIA1.
  ex   de,hl               ;2A10; Move 'new' length to HL.
  scf                      ;2A11; Jump if the program or array to be
  sbc  hl,de               ;2A12; loaded isn't longer than the existing
  jr   c,load_c3           ;2A14; one.
load_c2:
  ld   de,5                ;2A16; Otherwise a check must be made to
  add  hl,de               ;2A19; ensure that there is sufficient space
  ld   b,h                 ;2A1A; in memory for the program (or array) to
  ld   c,l                 ;2A1B; be loaded.
  rst  calbas              ;2A1C; Make the check by calling the 'main'
  defw rom_test_room       ;2A1D; ROM 'TEST_ROOM' subroutine.
load_c3:
  pop  hl                  ;2A1F; Restore 'old' start (=0 when handling
  ld   a,(ufia2.hd00)      ;2A20; a 'new' array).
  and  a                   ;2A23;
  jr   z,ld_prog           ;2A24; Jump if it's a BASIC program.
  ld   a,h                 ;2A26;
  or   l                   ;2A27; Jump unless an 'old' array is to be
  jr   z,load_c4           ;2A28; erased before loading the 'new' one.
  dec  hl                  ;2A2A; Points to high byte of 'array length'.
  ld   b,(hl)              ;2A2B; Fetch the 'length'.
  dec  hl                  ;2A2C;
  ld   c,(hl)              ;2A2D;
  dec  hl                  ;2A2E; Now points to the 'array name'.
  inc  bc                  ;2A2F; Include 'length' and 'name' in the
  inc  bc                  ;2A30; array length.
  inc  bc                  ;2A31;
  rst  calbas              ;2A32; Call 'RECLAIM_2' in the 'main' ROM to
  defw rom_reclaim_2       ;2A33; delete the array.
load_c4:
  ld   hl,(23641)          ;2A35; (E_LINE) points to the end of variables
  dec  hl                  ;2A38; area+1.
  ld   bc,(ufia2.hd0b)     ;2A39; Fetch length of array to be loaded.
  push bc                  ;2A3D;
  inc  bc                  ;2A3E; Include in the length one byte for the
  inc  bc                  ;2A3F; 'array name' and two bytes for the
  inc  bc                  ;2A40; 'array length'.
  ld   a,(ufia1.hd0f)      ;2A41; Fetch the array name from 'LENGTH1_2'.
  push af                  ;2A44;
  rst  calbas              ;2A45; Call 'MAKE_ROOM' to create the space
  defw rom_make_room       ;2A46; for the array.
  inc  hl                  ;2A48; Point to first 'new' location inserted.
  pop  af                  ;2A49;
  ld   (hl),a              ;2A4A; Store array name into first location.
  pop  de                  ;2A4B;
  inc  hl                  ;2A4C; Store array length into the following
  ld   (hl),e              ;2A4D; two locations.
  inc  hl                  ;2A4E;
  ld   (hl),d              ;2A4F;
  inc  hl                  ;2A50;
  call lv_any              ;2A51; Load the file.
  jp   the_end             ;2A54; Finished.

; Now deal with the LOADing of a BASIC program and its variables.

ld_prog:
  ld   de,(23635)          ;2A57; Fetch start of existing program.  (PROG)
  ld   hl,(23641)          ;2A5B; Fetch end of existing program. I.e.
  dec  hl                  ;2A5E; (E_LINE)-1.
  rst  calbas              ;2A5F; Delete the program by calling
  defw rom_reclaim_1       ;2A60; 'RECLAIM_1' in the 'main' ROM.
  ld   bc,(ufia2.hd0b)     ;2A62; Fetch length of program and variables.
  ld   hl,(23635)          ;2A66; Fetch (PROG), start of a BASIC program.
  rst  calbas              ;2A69; Create the required space by calling
  defw rom_make_room       ;2A6A; 'MAKE_ROOM'.
  inc  hl                  ;2A6C; Point to the first location.
  ld   bc,(ufia2.hd0f)     ;2A6D; Fetch length without variables.
  add  hl,bc               ;2A71; Calculate and store the start of the
  ld   (23627),hl          ;2A72; variables area.
  ld   a,($3E31)           ;2A75; When no autostart is known this
  ld   h,a                 ;2A78; ('AUTOSTART2-hi') holds $FF.
  and  $C0                 ;2A79;
  jr   nz,ld_prog1         ;2A7B; Jump with no autostart.
  ld   a,(ufia2.hd11)      ;2A7D; Otherwise store the autostart line
  ld   l,a                 ;2A80; number into 'NEWPPC' and clear 'NSPPC'.
  ld   (23618),hl          ;2A81; These hold the line and the statement
  ld   (iy+10),$00         ;2A84; to be executed respectively.
ld_prog1:
  ld   hl,(23635)          ;2A88; Fetch the start of the BASIC program.
  ld   de,(ufia2.hd0b)     ;2A8B; Fetch the length + variables.
  dec  hl                  ;2A8F; Reset the DATA pointer 'DATADD' to the
  ld   (23639),hl          ;2A90; beginning of the program.
  inc  hl                  ;2A93; Balance the 'DEC HL'.
  call lv_any              ;2A94; Load the file.
  jp   the_end             ;2A97; Finished.

; ----------------------------------------------
; THE 'LOAD OR VERIFY' SUBROUTINE

; This subroutine is used to LOAD or VERIFY (signalled by FLAGS3) a block of
; bytes. It must be entered with HL and DE holding 'start' and 'length'.

lv_any:
  ld   a,d                 ;2A9A;
  or   e                   ;2A9B;
  ret  z                   ;2A9C; Return if 'length' is zero.
  call test_7              ;2A9D;
  jr   nz,lv_any3          ;2AA0; Jump if 'VERIFYing'.
  jp   load_file           ;2AA2; Otherwise load the file.

lv_any1:
  cp   (hl)                ;2AA5; The actual VERIFY, i.e. compare the
                                ; fetched byte with that held in memory.
  jp   nz,rep_12           ;2AA6; Give an error if they don't match.
lv_any2:
  inc  hl                  ;2AA9; Next memory address.
  dec  de                  ;2AAA; One byte less to go.
  ld   a,d                 ;2AAB;
  or   e                   ;2AAC;
  ret  z                   ;2AAD; Exit if no more bytes left.
lv_any3:
  call lbyt                ;2AAE; Load one byte.
  call test_7              ;2AB1;
  jr   nz,lv_any1          ;2AB4; Jump if VERIFYing.
  ld   (hl),a              ;2AB6; Otherwise store the byte.
  jr   lv_any2             ;2AB7; Repeat for all bytes.

; ----------------------------------------------
; THE 'FORMAT' COMMAND SYNTAX ROUTINE

; This routine tests if the command has the appropriate syntax.

format:
  rst  next_c              ;2AB9; Advance CH_ADD to next character.
  and  $DF                 ;2ABA; Only capitals.
  cp   "D"                 ;2ABC;
  jp   nz,rep_0            ;2ABE; Give an error if not a "D".
  rst  next_c              ;2AC1; Next character.
  call expt_devn2          ;2AC2; Evaluate the drive number.
  cp   token.to            ;2AC5; Jump if the current character isn't
  jr   nz,format_1         ;2AC7; 'TO'.
  call swap_ufias          ;2AC9; Exchange UFIA1 and UFIA2.
  rst  next_c              ;2ACC; Update CH_ADD.
  call expt_devn2          ;2ACD; Evaluate 2nd drive number.
  call swap_ufias          ;2AD0; Exchange UFIA's again.
format_1:
  call st_end_ram          ;2AD3; Confirm end of statement and exit when
                                ; syntax checking.
  call test_drive.ufia1    ;2AD6; Check if the drive is defined.
  rst  calbas              ;2AD9;
  defw rom_cls_lower       ;2ADA; Clear lower screen area.
  set  5,(iy+2)            ;2ADC; Signal 'lower screen has to be
                                ; cleared'.
  call mesg_2              ;2AE0; Print 'Are you SURE ? (y/n)' message.
  call test_y              ;2AE3; Wait for a key, Zero set means 'Y'
  jp   nz,the_end          ;2AE6; pressed. Finished when not sure.
  call format_run          ;2AE9; Otherwise FORMAT the disk.
  jp   the_end             ;2AEC; Finished.


; ===============================================================
; The stream handling routines

; ----------------------------------------------
; THE 'EVALUATE STREAM NUMBER' SUBROUTINE

; A single numeric expression is evaluated and the result, in the range 0..15
; is stored into 'STRM_NUM1'.

expt_stream_nr:
  rst  next_c              ;2AEF; Advance CH_ADD.
expt_stream_nr1:
  rst  calbas              ;2AF0; Evaluate stream number.
  defw rom_expt_1num       ;2AF1;
  rst  syntax_z            ;2AF3; Return if syntax is being checked.
  ret  z                   ;2AF4;
  push af                  ;2AF5;
  rst  calbas              ;2AF6; Fetch the number.
  defw rom_find_int1       ;2AF7;
  cp   16                  ;2AF9; Give an error if it isn't in the range
  jp   nc,rep_9            ;2AFB; 0..15. ('Invalid station' ?)
  ld   (ufia1.sstr1),a     ;2AFE; Store stream number into 'STRM_NUM1'.
  pop  af                  ;2B01;
  ret                      ;2B02;

; ----------------------------------------------
; THE 'MOVE' COMMAND SYNTAX ROUTINE

; A 'MOVE' command requires two sets of parameters, for the 'input' channel,
; and for the 'output' channel. These parameters are stored into the UFIA's.

move:
  call expt_exp1           ;2B03; Evaluate stream or channel expression.
  cp   token.to            ;2B06; The keyword 'TO' must be present,
  jp   nz,rep_0            ;2B08; give an error if 'TO' is missing.
  call swap_ufias          ;2B0B; Exchange the UFIA's.
  call expt_exp1           ;2B0E; Evaluate second stream or channel
                                ; expression.
  call swap_ufias          ;2B11; Exchange the UFIA's again.
  call st_end_ram          ;2B14; Confirm end of statement and exit
                                ; during syntax check.

; The actual 'MOVE' command reads a byte from the source channel or stream,
; and then writes it to the destination channel or stream. This is repeated
; until the first channel or stream reports 'End Of File'. 'SIGN_2' is called
; to signal to the 'D_INPUT' routine at $2EDC that the 'END of file' error
; isn't to be generated.

  call sign_2              ;2B17; See above.
  ld   a,token.in          ;2B1A; This is the keyword 'IN', it is used to
  ld   (ufia1.fstr1),a     ;2B1C; signal 'READ channel'.
  call op_move             ;2B1F; Open the source channel/stream.
  ld   hl,(23631)          ;2B22; Save (CHANS).
  push hl                  ;2B25;
  ld   a,(ufia1.fstr1)     ;2B26; Save 'DIR_DESCR1' into 'DIR_DESCR2'.
  ; XXX FIXME -- Check if the original ROM is:
  ; ld   a,(ufia1.nstr1)     ;2B26; Save 'DIR_DESCR1' into 'DIR_DESCR2'.
  ld   (ufia2.nstr1),a     ;2B29;

  call swap_ufias          ;2B2C; Exchange the UFIA's.
  ld   a,token.out         ;2B2F; This is the keyword 'OUT'.
  ld   (ufia1.fstr1),a     ;2B31; Signal 'WRITE channel'.
  ld   ix,dfca             ;2B34;
  call op_move             ;2B38; Open the destination channel/stream.
  jr   nc,move_run1        ;2B3B; Jump if opening was successfull. I.e.
                                ; file was 'new' or 'old' file was
                                ; overwritten.
  ld   ix,(ufia2.nstr1)    ;2B3D; Otherwise reclaim first channel (Second
  call recl_chan           ;2B41; wasn't opened so nothing to reclaim).
  pop  hl                  ;2B44; Drop (CHANS) address.
  pop  hl                  ;2B45; ?? Drop what?
  jp   the_end             ;2B46; Finished.

move_run1:
  call swap_ufias          ;2B49; Exchange UFIA's again.

; To my knowledge the instructions at $2B22, $2B25, $2B44 and from $2B4C to
; $2B58 aren't needed with the +D. With IF1 the Microdrive maps are situated
; between 23734 (end of Spectrum system variables) and (CHANS). The
; consequence of opening a new channel could be the creating of a new map.
; I.e. the channel information could move up and then the source channels
; address is to be recalculated. With the +D, however, nothing is situated
; between 23734 and (CHANS).

  pop  de                  ;2B4C; Retrieve 'old' (CHANS).
  ld   hl,(23631)          ;2B4D; Fetch 'new' (CHANS).
  or   a                   ;2B50; Calculate the space which was inserted
  sbc  hl,de               ;2B51; under (CHANS).
  ld   de,(ufia1.nstr1)    ;2B53; Adjust first channels address.
  add  hl,de               ;2B57;
  ld   (ufia1.nstr1),hl    ;2B58;
move_run2:
  ld   hl,(ufia1.nstr1)    ;2B5B; Make 'current' the first channel.
  ld   (23633),hl          ;2B5E; (CURCHL)
move_run3:
  rst  calbas              ;2B61; Call 'INPUT_A' in the 'main' ROM to
  defw rom_input_ad        ;2B62; read a byte.
  ; XXX FIXME -- the original HTML has a typo in the previous label
  jr   c,move_run4         ;2B64; Jump with acceptable codes.
  jr   z,move_run3         ;2B66; Repeat if no byte read.
  jr   move_run5           ;2B68; Jump if EOF has been reached.

; An acceptable code has been found.

move_run4:
  ld   hl,(ufia2.nstr1)    ;2B6A; Make 'current' the 2nd channel.
  ld   (23633),hl          ;2B6D; (CURCHL)
  rst  calbas              ;2B70; Use 'main' ROM 'PRINT_A_2' to send the
  defw rom_print_a_2       ;2B71; byte to the 2nd channel.
  jr   move_run2           ;2B73; Repeat until EOF.

; EOF has been reached.

move_run5:
  xor  a                   ;2B75; Clear FLAGS3.
  ld   (flags3),a          ;2B76;
  ld   hl,(23631)          ;2B79; Store current (CHANS).
  push hl                  ;2B7C;
  call swap_ufias          ;2B7D; Exchange the UFIA's.
  call cl_move             ;2B80; Close the destination channel.
  call swap_ufias          ;2B83; Exchange the UFIA's again.

; Again the instructions at address $2B79, $2B7C and from $2B86 to $2B92
; aren't needed with the +D.

  pop  de                  ;2B86; Restore initial address of CHANS.
  ld   hl,(23631)          ;2B87; Fetch current (CHANS).
  or   a                   ;2B8A; Calculate the amount of bytes reclaimed
  sbc  hl,de               ;2B8B; after the deletion of the second
  channel.
  ld   de,(ufia1.nstr1)    ;2B8D; Calculate the new start address of the
  add  hl,de               ;2B91; first channel.
  ld   (ufia1.nstr1),hl    ;2B92; And store it.
  call cl_move             ;2B95; Close the source channel.
  call recl_temp           ;2B98; Reclaim temporary channels.
  jp   the_end             ;2B9B; Finished.

; ----------------------------------------------
; THE 'RECLAIM CHANNEL' SUBROUTINE

; This subroutine is used to reclaim the channel pointed to by IX.

recl_chan:
  ld   c,(ix+9)            ;2B9E; Fetch channel length.
  ld   b,(ix+10)           ;2BA1;
  push bc                  ;2BA4;
  push ix                  ;2BA5; Channel start to HL.
  pop  hl                  ;2BA7;
  rst  calbas              ;2BA8; Call 'RECLAIM_2' in the 'main' ROM to
  defw rom_reclaim_2       ;2BA9; reclaim the channel.
  pop  bc                  ;2BAB;
  ret                      ;2BAC;

; ----------------------------------------------
; THE 'EVALUATE STRM. OR EXPR.' SUBROUTINE

; This subroutine is used to check the syntax of the 'MOVE' command. If the
; 'current' character is a hash sign (#), then a stream number is evaluated.
; Otherwise a device expression is evaluated.

expt_exp1:
  rst  next_c              ;2BAD; Advance CH_ADD.
  cp   "#"                 ;2BAE; Jump to 'EXPT_#_NR' to evaluate stream
  jp   z,expt_stream_nr    ;2BB0; number if character is a '#'.
expt_exp2:
  ld   (ufia1.lstr1),a     ;2BB3; Otherwise store device letter.
  and  $DF                 ;2BB6; Only capitals.
  cp   "D"                 ;2BB8; If device letter isn't "D" then
  call nz,md_syn1          ;2BBA; evaluate microdrive syntax.
  call expt_devn           ;2BBD; Evaluate device number.
  call separator           ;2BC0; If there is a separator exit via
  jp   z,expt_fname        ;2BC3; 'EXP_F_NAME' to evaluate a filename.
  rst  syntax_z            ;2BC6;
  ret  z                   ;2BC7; Return if checking syntax.
  push af                  ;2BC8;
  ld   a,(ufia1.lstr1)     ;2BC9; Fetch device letter.
  and  $DF                 ;2BCC; Only capitals.
  cp   "D"                 ;2BCE; If the device is "D" or "M" then there
  jp   z,rep_2             ;2BD0; must be a name present. Give an error
  cp   "M"                 ;2BD3; if no name specified.
  jp   z,rep_2             ;2BD5;
  pop  af                  ;2BD8;
  ret                      ;2BD9;

; ----------------------------------------------
; THE 'USE STREAM OR CHANNEL' SUBROUTINE

; This subroutine is used from the 'MOVE' command routine above to fetch the
; start address of the channel attached to a stream, or to open a channel and
; fetch its start address.

op_move:
  ld   a,(ufia1.sstr1)     ;2BDA; Fetch stream number.
  inc  a                   ;2BDD; Jump to open a temporary channel, i.e.
  jr   z,op_move1          ;2BDE; if the stream was nonexistent.
  dec  a                   ;2BE0;
  rst  calbas              ;2BE1; Open the channel attached to stream A.
  defw rom_chan_open       ;2BE2;
  ld   hl,(23633)          ;2BE4; Store the channels address (CURCHL)
  ld   (ufia1.nstr1),hl    ;2BE7; into UFIA1.
  ret                      ;2BEA; Return.

op_move1:
  ld   a,(ufia1.lstr1)     ;2BEB; Fetch device letter.
  and  $DF                 ;2BEE; Capitals only.
  cp   "M"                 ;2BF0;
  jr   z,op_move2          ;2BF2; Jump if it's a "M".
  cp   "D"                 ;2BF4;
  jr   nz,op_move3         ;2BF6; Jump if it isn't a "D".
op_move2:
  call test_drive.ufia1    ;2BF8; Check if the drive is defined.
  call op_temp_d           ;2BFB; Open a temporary "D" channel.
  ld   a,(ufia1.nstr1)     ;2BFE; Save 'DIR_DESCR1' into 'PROG_NUM1'.
  ld   (ufia1.fstr1),a     ;2C01;
  ld   (ufia1.nstr1),ix    ;2C04; Store channels address.
  ret                      ;2C08;

op_move3:
  cp   "N"                 ;2C09;
  jp   nz,rep_0            ;2C0B; Give an error if device isn't "N".
  call sign_3              ;2C0E; Otherwise signal 'using network'.
  ret                      ;2C11;

; ----------------------------------------------
; THE 'CLOSE "MOVE" CHANNEL' SUBROUTINE

; This is the opposite subroutine of the preceeding one, and is used to CLOSE
; the channel used by the 'MOVE' command routine. If 'STRM_NUM1' denotes that
; a stream was used, nothing is done.

cl_move:
  ld   a,(ufia1.sstr1)     ;2C12; Fetch stream number.
  inc  a                   ;2C15;
  ret  nz                  ;2C16; Return if a stream has been used.
  ld   a,(ufia1.lstr1)     ;2C17; Otherwise fetch device letter.
  and  $DF                 ;2C1A; Only capitals.
  cp   "N"                 ;2C1C;
  jr   z,cl_move1          ;2C1E; Jump if it was "N".
  ld   ix,(ufia1.nstr1)    ;2C20; Fetch channel address.
  jp   close_chan          ;2C24; Close the channel and exit.
cl_move1:
  ret                      ;2C27;

; ----------------------------------------------
; THE 'RECLAIM TEMP. CHANNELS' SUBROUTINE

; This subroutine is called to reclaim from the CHANS all 'temporary' channels
; (i.e. with bit 7 of the channel specifier set).

recl_temp:
  ld   ix,(23631)          ;2C28; Point to the start of the channel area.
  ld   de,20               ;2C2C; IX now points to the first
  add  ix,de               ;2C2F; 'non-standard' channel.
recl_t1:
  ld   a,(ix+0)            ;2C31;
  cp   128                 ;2C34; Return if the end marker was found,
  ret  z                   ;2C36; i.e. there are no more channels.
  ld   a,(ix+4)            ;2C37; Fetch channel specifier.
  cp   "D"+128             ;2C3A;
  jr   nz,recl_t2          ;2C3C; Jump if not a temporary "D" channel.
  call close_chan          ;2C3E;
  jr   recl_temp           ;2C41;

; Permanent "D" channels mustn't be closed, except when 'CLEAR #' was given.

recl_t2:
  call test_1              ;2C43;
  jr   z,recl_t3           ;2C46; Jump if not 'CLEAR # executing'.
  call recl_chan           ;2C48; Otherwise reclaim the channel.
  jr   recl_temp           ;2C4B;

; Skip this channel.

recl_t3:
  ld   e,(ix+9)            ;2C4D; Fetch channel length.
  ld   d,(ix+10)           ;2C50;
  add  ix,de               ;2C53; Point to the next channel.
  jr   recl_t1             ;2C55; Repeat for all channels.

; ----------------------------------------------
; THE 'CLOSE CHANNEL' SUBROUTINE

; This subroutine closes the channel pointed to by IX.

close_chan:
  push ix                  ;2C57;
  pop  hl                  ;2C59;
  ld   de,(23631)          ;2C5A; (CHANS).
  or   a                   ;2C5E;
  sbc  hl,de               ;2C5F; Calculate channel offset.
  inc  hl                  ;2C61;
  ld   ($3DED),hl          ;2C62; The channel is CLOSEd by jumping into
  jp   close_0             ;2C65; the 'CLOSE' routine

; ----------------------------------------------
; THE 'OPEN' COMMAND SYNTAX ROUTINE

; This routine deals with the 'OPEN #' command concerning +D channels,
; Spectrum channels are handled by the 'main' ROM.

open:
  call expt_stream_nr      ;2C68; Evaluate stream number.
  call separator           ;2C6B;
  jp   nz,rep_0            ;2C6E; Give an error if no separator found.
  call expt_exp2           ;2C71; Evaluate channel specifier.
  cp   13                  ;2C74;
  jr   z,open_2            ;2C76; Jump if no more parameters.
  cp   token.in            ;2C78;
  jr   z,open_1            ;2C7A; Jump if 'IN' specified.
  cp   token.out           ;2C7C;
  jp   nz,rep_2            ;2C7E; Give error if no 'OUT' specified.
open_1:
  ld   (ufia1.fstr1),a     ;2C81; Store the channel type (IN or OUT) in
                                ; 'PROG_NUM1'.
  rst  next_c              ;2C84; Advance CH_ADD.
open_2:
  call st_end_ram          ;2C85; Confirm end of statement and exit
                                ; during syntax checking.
  ld   a,(ufia1.sstr1)     ;2C88; Fetch stream number.
  rst  calbas              ;2C8B; Call 'main' ROM 'STR_DATA1' routine; on
  defw rom_str_data1       ;2C8C; exit, BC holds 'stream data'.
  ld   hl,17               ;2C8E;
  and  a                   ;2C91;
  sbc  hl,bc               ;2C92; Give an error if the current stream was
  jp   c,rep_30            ;2C94; already used by the +D.
  ld   a,(ufia1.lstr1)     ;2C97; Fetch channel specifier.
  and  $DF                 ;2C9A; Only capitals.
  cp   "D"                 ;2C9C;
  jr   z,open_3            ;2C9E; Jump if opening a "D" channel.
  cp   "M"                 ;2CA0; Give an error if not opening a "M"
  jp   nz,rep_0            ;2CA2; channel.
open_3:
  call test_drive.ufia1    ;2CA5; See if the drive is defined.
  ld   a,$0A               ;2CA8; Signal 'OPENTYPE file'.
  ld   (ufia1.nstr1),a     ;2CAA;
  call open_chan           ;2CAD; Open the channel.
  jp   the_end             ;2CB0; Finished.

; ----------------------------------------------
; THE 'OPEN "D" CHANNEL' SUBROUTINE

; This is the actual OPEN routine referred to the "D" channel.

open_chan:
  ld   a,(ufia1.sstr1)     ;2CB3; Fetch stream number.
  add  a,a                 ;2CB6; The streams area entries are two bytes
                                ; each.
  ld   hl,23574            ;2CB7; Address of data for stream 0.
  ld   e,a                 ;2CBA;
  ld   d,0                 ;2CBB;
  add  hl,de               ;2CBD; Index into STRMS area.
  push hl                  ;2CBE;
  call op_temp_d           ;2CBF; Open a temporary "D" channel. On return
  pop  de                  ;2CC2; HL holds new channel offset.
  ret  c                   ;2CC3; Return when an error occurred.
  bit  0,(ix+12)           ;2CC4;
  jr   z,make_perm         ;2CC8; Jump if this is a 'read' file.
  in   a,(227)             ;2CCA; Read Floppy Disk Controller status.
  bit  6,a                 ;2CCC; Test the 'write protect' bit.
  jr   z,make_perm         ;2CCE; Jump if disk isn't write protected.

; NOTE: This doesn't work, the write protect bit of the FDC's status register
; is not adjusted with read commands. So the jump is always made.

  call recl_chan           ;2CD0; Otherwise reclaim the channel.
  jp   rep_23              ;2CD3; And give an error.
make_perm:
  res  7,(ix+4)            ;2CD6; Make the channel permanent by resetting
                                ; bit 7 of the channel specifier.
  ex   de,hl               ;2CDA; DE holds new channel offset.
  ld   (hl),e              ;2CDB; Store it into the STRMS area.
  inc  hl                  ;2CDC;
  ld   (hl),d              ;2CDD;
  ret                      ;2CDE; Finished.

; ----------------------------------------------
; THE 'OPEN TEMP. "D" CHANNEL' SUBROUTINE

; This subroutine is used to open a temporary "D" channel in the CHANS area.

op_temp_d:
  ld   ix,(23631)          ;2CDF; Start of channel area (CHANS).
  ld   de,20               ;2CE3; Point to the first 'non-standard'
  add  ix,de               ;2CE6; channel.
op_temp1:
  ld   a,(ix+0)            ;2CE8;
  cp   128                 ;2CEB;
  jr   z,op_temp4          ;2CED; Jump if end of CHANS area is reached.
  ld   a,(ix+4)            ;2CEF; Otherwise fetch channel specifier.
  and  $5F                 ;2CF2; Clear bit 7 and make capital.
  cp   "D"                 ;2CF4;
  jr   nz,op_temp3         ;2CF6; Jump if this isn't a "D" channel.
  ld   a,(ufia1.dstr1)     ;2CF8; Fetch drive number.
  cp   (ix+11)             ;2CFB; Jump if this channel uses a different
  jr   nz,op_temp3         ;2CFE; drive.
  push ix                  ;2D00;
  pop  hl                  ;2D02; Start of channel to HL.
  ld   de,20               ;2D03; Filename offset.
  add  hl,de               ;2D06;
  ex   de,hl               ;2D07; DE points to the name of this channel.
  ld   hl,ufia1.nstr2      ;2D08; HL points to the name of the channel to
  ld   b,10                ;2D0B; be opened.
op_temp2:
  ld   a,(de)              ;2D0D;
  xor  (hl)                ;2D0E;
  and  $DF                 ;2D0F; Capitalize.
  jr   nz,op_temp3         ;2D11; Jump if not the same file.
  inc  hl                  ;2D13;
  inc  de                  ;2D14;
  djnz op_temp2            ;2D15; Repeat for all 10 characters.
  jp   rep_31              ;2D17; Give an error if the channel already
                                ; exists.
op_temp3:
  ld   e,(ix+9)            ;2D1A; Fetch the length of the channel.
  ld   d,(ix+10)           ;2D1D;
  add  ix,de               ;2D20; Point to the next channel.
  jr   op_temp1            ;2D22; Repeat for all channels.

; The channel wasn't already present in memory so it can be opened.

op_temp4:
  push ix                  ;2D24;
  ld   a,%0001000          ;2D26; Scan the CATalogue for a matching
  call scan_cat            ;2D28; filename.
  ld   a,(ufia1.fstr1)     ;2D2B; Get channel type (read/write).
  jp   nz,op_temp5         ;2D2E; Jump if file not found.
  cp   token.out           ;2D31;
  jp   z,op_t_patch        ;2D33; Jump if OUTput channel.
  ld   bc,551              ;2D36; Length of INput channel.
  call chan_spc            ;2D39; Create the room for the channel.
  call rpt_hl              ;2D3C; Make HL point to the CAT entry.
  pop  ix                  ;2D3F;
  call test_drive.ufia1    ;2D41; See if the drive is defined.
  nop                      ;2D44;
  nop                      ;2D45;
  nop                      ;2D46;
  ld   a,0                 ;2D47; Signal 'READing'.
  ld   (ix+12),a           ;2D49;
  ld   bc,39               ;2D4C; Offset of buffer from start of channel.
  ld   (ix+15),c           ;2D4F;
  ld   (ix+16),b           ;2D52;
  push hl                  ;2D55; HL points to the CATalogue entry.
  push ix                  ;2D56; IX points to the start of the channel.
  pop  hl                  ;2D58;
  ld   de,19               ;2D59; Offset of directory description.
  add  hl,de               ;2D5C;
  ex   de,hl               ;2D5D;
  pop  hl                  ;2D5E; Pointer to CAT entry.
  ld   bc,11               ;2D5F; Move the directory description and the
  ld   a,(hl)              ;2D62; filename to the channel.
  ld   (ufia1.nstr1),a     ;2D63; Store dir. descr. in UFIA1.
  ldir                     ;2D66;
  inc  hl                  ;2D68; Skip length in sectors, i.e. point to
  inc  hl                  ;2D69; track and sector bytes.
  ld   b,(hl)              ;2D6A; Fetch first track and sector.
  inc  hl                  ;2D6B;
  ld   c,(hl)              ;2D6C;
  push bc                  ;2D6D;
  ld   bc,196              ;2D6E;
  add  hl,bc               ;2D71; HL points to file header - 1 in CAT
  ld   a,(hl)              ;2D72; entry. That is the MSB of the file
  ld   (ix+18),a           ;2D73; length (number of 64K blocks).
  inc  hl                  ;2D76;
  ld   bc,9                ;2D77;
  ldir                     ;2D7A; Copy the file header to the channel.
  ld   de,$3FEA            ;2D7C;
  ld   bc,22               ;2D7F; Copy the SNAP registers (?).
  ldir                     ;2D82;
  pop  de                  ;2D84; Get track and sector in DE.
  call rsad                ;2D85; Load the sector at DE.
  jr   op_temp8            ;2D88;

; The file was not found, so if the channel isn't for OUTput give an error.

op_temp5:
  cp   token.in            ;2D8A;
  jp   z,rep_26            ;2D8C; Give error if it is an INput channel.
op_temp6:
  ld   bc,787              ;2D8F; Length of OUTput channel.
  call chan_spc            ;2D92; Create the room for the channel.
  pop  ix                  ;2D95;
  call test_drive.ufia1    ;2D97; See if the drive is defined.
  nop                      ;2D9A;
  nop                      ;2D9B;
  nop                      ;2D9C;
  ld   a,1                 ;2D9D; Signal 'WRITEing'.
  ld   (ix+12),a           ;2D9F;
  ld   bc,275              ;2DA2; Offset of databuffer from the start of
  ld   (ix+15),c           ;2DA5; the channel.
  ld   (ix+16),b           ;2DA8;
  call ofsm_2              ;2DAB; Open the file.
  jr   z,op_temp7          ;2DAE; Jump if file doesn't exist (anymore).
  ld   bc,787              ;2DB0; Length of an OUTput channel.
  push ix                  ;2DB3; Start of the channel to HL.
  pop  hl                  ;2DB5;
  rst  calbas              ;2DB6; Reclaim the channel.
  defw rom_reclaim_2       ;2DB7;
  scf                      ;2DB9; Signal 'error'.
  ret                      ;2DBA; Finished.

op_temp7:
  jp   op_temp8            ;2DBB; Jump forward.

; Before the routine continues there are first some 'leftovers' from a earlier
; system version.

  jr   z,op_temp8          ;2DBE;
  push ix                  ;2DC0;
  pop  hl                  ;2DC2;
  ld   de,230              ;2DC3;
  add  hl,de               ;2DC6;
  ex   de,hl               ;2DC7;
  ld   hl,(ufia2.nstr1)    ;2DC8;
  ld   bc,30               ;2DCB;
  add  hl,bc               ;2DCE;
  ld   bc,9                ;2DCF;
  ldir                     ;2DD2;
  ld   hl,$3FEA            ;2DD4;
  ld   bc,20               ;2DD7;
  ldir                     ;2DDA;

; Now continue with the 'OPEN a temporary "D" channel' routine.

op_temp8:
  push ix                  ;2DDC;
  pop  de                  ;2DDE; Start of channel to DE.
  ld   hl,d_ch_data        ;2DDF; Start of the "D" channel data.
  ld   bc,11               ;2DE2; Copy the 11 bytes channel data to the
  ldir                     ;2DE5; channel area.
  push ix                  ;2DE7; Start of channel to HL.
  pop  hl                  ;2DE9;
  ld   de,(23631)          ;2DEA; HL-(CHANS)+1 gives the required 'stream
  or   a                   ;2DEE; offset'.
  sbc  hl,de               ;2DEF;
  inc  hl                  ;2DF1;
  ret                      ;2DF2; Finished.

; ----------------------------------------------
; THE 'MAKE ROOM FOR CHANNEL' SUBROUTINE

; This small subroutine creates room for a channel at the end of the CHANS
; area (i.e. just before the BASIC program).

chan_spc:
  ld   ($2E14),bc          ;2DF3; Store the length of the channel into
                                ; the "D" channel data table.
  ld   hl,(23635)          ;2DF7; Fetch the start address of the channel
  dec  hl                  ;2DFA; ((PROG)-1).
  push hl                  ;2DFB;
  push bc                  ;2DFC;
  rst  calbas              ;2DFD; Create the required space by calling
  defw rom_make_room       ;2DFE; 'main' ROM 'MAKE_ROOM'.
  pop  bc                  ;2E00;
  pop  hl                  ;2E01; Clear the created space.
chan_spc1:
  ld   (hl),0              ;2E02;
  inc  hl                  ;2E04;
  dec  bc                  ;2E05;
  ld   a,b                 ;2E06;
  or   c                   ;2E07;
  jr   nz,chan_spc1        ;2E08;
  ret                      ;2E0A;

; ----------------------------------------------
; THE '"D" CHANNEL DATA' TABLE

; The '11' bytes that compose the initial part of a "D" channel are as
; follows:

d_ch_data:
  defw $0008               ;2E0B; Main ROM 'output' routine.
  defw $0008               ;2E0D; Main ROM 'input' routine.
  defb "D"+128             ;2E0F; Channel specifier.
  defw dchan_out           ;2E10; +D system 'output' routine.
  defw d_input             ;2E12; +D system 'input' routine.
  defw $0000               ;2E14; Length of a channel.

; ----------------------------------------------
; THE 'CLOSE #' COMMAND SYNTAX ROUTINE

; Unlike the Interface 1 and the Opus Discovery, the +D doesn't page-in in the
; middle of the 'main' ROM 'CLOSE' routine. But because the 'main' ROM routine
; can't cope with +D channels a 'CLOSE' for those channels has to be
; available. In order to fail the normal syntax, 'CLOSE #*s' has to be used.
; The 'CLOSE #*' command closes all streams.

close:
  rst  next_c              ;2E16; Next character.
  cp   "*"                 ;2E17;
  jp   nz,rep_0            ;2E19; Give an error if it isn't a '*'.
  rst  next_c              ;2E1C; Next character.
  cp   13                  ;2E1D;
  jr   z,close_all         ;2E1F; Jump if statement ended with ENTER.
  cp   ":"                 ;2E21;
  jr   z,close_all         ;2E23; Also if statement ended with a ':'.
  call expt_stream_nr1     ;2E25; Evaluate stream number.
  call st_end_ram          ;2E28; Confirm end of statement and exit when
                                ; syntax checking.
  ld   a,(ufia1.sstr1)     ;2E2B; Fetch stream number.
  call close_strm          ;2E2E; Close the stream.
  jp   the_end             ;2E31; Finished.

close_all:
  call st_end_ram          ;2E34; Confirm end of statement and exit if
  jr   clear_1             ;2E37; syntax checking. Jump into the CLEAR#
                                ; routine.

; ----------------------------------------------
; THE 'CLEAR #' COMMAND ROUTINE

; All streams are closed in turn, with bit 1 of FLAGS3 set to signal that the
; remaining buffer contents are to be erased (with the 'CLOSE #*' command all
; buffers are emptied, i.e. their contents are sent to the corresponding
; device).

clear:
  rst  next_c              ;2E39; Advance CH_ADD.
  cp   "#"                 ;2E3A;
  jp   nz,rep_0            ;2E3C; Give an error if it isn't a '#'.
  rst  next_c              ;2E3F;
  call st_end_ram          ;2E40; Confirm end of statement and exit
                                ; during syntax checking.
  call sign_1              ;2E43; Signal 'CLEAR #'.
clear_1:
  xor  a                   ;2E46; Start with stream 0.
clear_2:
  push af                  ;2E47;
  call close_strm          ;2E48; Close this stream.
  pop  af                  ;2E4B;
  inc  a                   ;2E4C; Next stream.
  cp   16                  ;2E4D; Repeat until all streams 0..15 have
  jr   c,clear_2           ;2E4F; been CLOSEd.
  call recl_temp           ;2E51; Reclaim temporary channels.
  xor  a                   ;2E54;
  ld   (mapused),a         ;2E55; Clear 'MAP_USED' (=POKE @7663,0).
  ld   (flags3),a          ;2E58; Clear FLAGS3.
  jp   the_end             ;2E5B; Finished.

; ----------------------------------------------
; THE 'CLOSE A STREAM' SUBROUTINE

; Any stream 0 to 15 may be CLOSEd by loading the stream number into A and
; then calling this subroutine. The unsent bytes in 'OUTput' files are sent or
; lost depending upon whether bit 1 of FLAGS3 is reset or set. First a call to
; 'STR_DATA1' in the 'main' ROM is made to fetch into BC the 'stream data' for
; the given stream, and to make HL point to the first of the two data bytes.

close_strm:
  rst  calbas              ;2E5E; Call 'STR_DATA1'.
  defw rom_str_data1       ;2E5F;
  ld   a,c                 ;2E61;
  or   b                   ;2E62; Return if the stream is already CLOSEd
  ret  z                   ;2E63; (i.e. stream data = 0).
  ld   ($3DED),bc          ;2E64; Store stream data.
  push hl                  ;2E68;
  ld   hl,(23631)          ;2E69; Make HL point to the start of the
  dec  hl                  ;2E6C; channel attached to the stream to be
  add  hl,bc               ;2E6D; CLOSEd ((CHANS)+'stream data').
  ex   (sp),hl             ;2E6E; HL now holds the address of the stream
                                ; data.
  rst  calbas              ;2E6F; A call in the middle of the 'main' ROM
  defw rom_close_0_16EB    ;2E70; 'CLOSE' routine is made to update STRMS
                                ; contents.
  pop  ix                  ;2E72; IX points to the start of the channel
  ld   a,b                 ;2E74; to be removed.
  or   c                   ;2E75;
  ret  nz                  ;2E76; Exit if the stream is one of 0 to 3.

; NOTE: Because this test tests for streams a disk channel attached to one of
; the streams 0..3 can never be CLOSEd. If the test was made for 'standard'
; channels it had been possible to use streams 0..3 with "D" channels.

  ld   a,(ix+4)            ;2E77; Fetch channel specifier.
  and  $5F                 ;2E7A; Clear bit 7 (temporary) and make
                                ; capital.
  cp   "D"                 ;2E7C;
  jr   nz,close_1          ;2E7E; Jump if it isn't a "D" channel.
close_0:
  bit  0,(ix+12)           ;2E80;
  jr   z,close_1           ;2E84; Jump if it is an 'INput' channel.
  call test_1              ;2E86; Jump if doing a 'CLEAR #', i.e. just
  jr   nz,close_1          ;2E89; remove the channel.
  call cl_patch            ;2E8B; Empty the buffer.
close_1:
  call recl_chan           ;2E8E; Reclaim the channel.

; Now all data refering to the stream attached to the channels moved down are
; updated.

  xor  a                   ;2E91; Start with stream 0.
  ld   hl,23574            ;2E92; Address of data for stream 0.
close_2:
  ld   (dfca.addr),hl      ;2E95; Use 'FILE_ADDR' as a temporary storage.
  ld   e,(hl)              ;2E98; Fetch stream data.
  inc  hl                  ;2E99;
  ld   d,(hl)              ;2E9A;
  ld   hl,($3DED)          ;2E9B; Fetch stream data for CLOSEd stream.
  and  a                   ;2E9E; Jump if the stream data found is lower
  sbc  hl,de               ;2E9F; than that of the CLOSEd stream (i.e.
  jr   nc,close_3          ;2EA1; channel has not been moved).
  ex   de,hl               ;2EA3; Fetched stream data to HL.
  and  a                   ;2EA4;
  sbc  hl,bc               ;2EA5; Calculate the new stream data.
  ex   de,hl               ;2EA7; New stream data to DE.
  ld   hl,(dfca.addr)      ;2EA8; Restore stream data address.
  ld   (hl),e              ;2EAB; Store new stream data.
  inc  hl                  ;2EAC;
  ld   (hl),d              ;2EAD;
close_3:
  ld   hl,(dfca.addr)      ;2EAE; Make HL point to next stream data.
  inc  hl                  ;2EB1;
  inc  hl                  ;2EB2;
  inc  a                   ;2EB3; Increment stream number.
  cp   16                  ;2EB4;
  jr   c,close_2           ;2EB6; Repeat for all streams 0..15.
  ret                      ;2EB8; Finished.

; ----------------------------------------------
; THE 'CLS #' COMMAND ROUTINE

; The 'CLS #' command resets during runtime the Spectrum system variables
; ATTR_P, ATTR_T, MASK_P, MASK_T, P_FLAG and BORDCR. I.e. all these variables
; are filled with their 'initial' values (paper 7, ink 0, flash 0 and bright
; 0).

cls:
  rst  next_c              ;2EB9; Next character.
  cp   "#"                 ;2EBA;
  jp   nz,rep_0            ;2EBC; Give error if it isn't a '#'.
  rst  next_c              ;2EBF; Next character.
  call st_end_ram          ;2EC0; Confirm end of statement and exit
                                ; during syntax checking.
  ld   hl,56               ;2EC3; The 'initial' attribute value.
  ld   (23693),hl          ;2EC6; Store 56 into ATTR_P, clear MASK_P.
  ld   (23695),hl          ;2EC9; Store 56 into ATTR_T, clear MASK_T.
  ld   (iy+14),l           ;2ECC; Store 56 also for lower screen
                                ; attribute.
  ld   (iy+87),h           ;2ECF; Clear P_FLAG.
  ld   a,7                 ;2ED2; Set white border.
  out  (254),a             ;2ED4;
  rst  calbas              ;2ED6; Call 'main' ROM 'CLS' routine.
  defw rom_cls             ;2ED7;
  jp   the_end             ;2ED9; Finished.

; ----------------------------------------------
; THE '"D" CHANNEL INPUT' ROUTINE

; This is a peculiar routine, although the +D supports only one type of
; channel (the "D" channel), this routine can handle all kinds of channels by
; loading HL with the address of the 'service' input routine and entering at
; address $2EE3. From that address on it's largely the same as the Interface 1
; 'CALL_INP' routine, which routine handles all the IF1's channels.

d_input:
  ld   ix,(23633)          ;2EDC; IX points to the start of the current
                                ; channel (CURCHL).
  ld   hl,dchan_in         ;2EE0; Address of "D" input service routine.
  res  3,(iy+2)            ;2EE3; Signal 'the mode is to be considered as
                                ; being unchanged'.
  push hl                  ;2EE7; Store address of service routine.
  ld   hl,(23613)          ;2EE8; HL points to error address (ERR_SP).
  ld   e,(hl)              ;2EEB; Fetch the error address.
  inc  hl                  ;2EEC;
  ld   d,(hl)              ;2EED;
  and  a                   ;2EEE;
  ld   hl,rom_ed_error     ;2EEF; If the error address is 'ED_ERROR'
  sbc  hl,de               ;2EF2; ('main' ROM) then an INPUT command was
  jr   nz,d_inkey_dollar   ;2EF4; used. Jump if unequal to 'ED_ERROR'.

; Now deal with an 'INPUT #' command referred to a "D" channel.

  pop  hl                  ;2EF6; Restore address of service routine.
  ld   sp,(23613)          ;2EF7; Clear the machine stack (ERR_SP).
  pop  de                  ;2EFB; Remove 'ED_ERROR'.
  pop  de                  ;2EFC;
  ld   (23613),de          ;2EFD; Restore the old value of ERR_SP.
d_input1:
  push hl                  ;2F01; Store address of service routine.
  ld   de,d_inp_end        ;2F02; Return address is 'D_INP_END' below.
  push de                  ;2F05;
  jp   (hl)                ;2F06; Jump to the service routine.

; When the byte has been read from the required channel, a return is made here
; to add the byte to the INPUT line, or to return if the byte is equal to CHR$
; 13, i.e.  ENTER.

d_inp_end:
  jr   c,d_inp_acc         ;2F07; Jump with acceptable codes.
  jp   nz,rep_27           ;2F09; Give the 'END of file' error when the
                                ; Zero flag is reset.
  pop  hl                  ;2F0C; Otherwise restore address of service
  jr   d_input1            ;2F0D; routine and try again.

d_inp_acc:
  cp   13                  ;2F0F;
  jr   z,d_input2          ;2F11; Jump if the code is ENTER.
  rst  calbas              ;2F13; Otherwise the byte is to be added to
  defw rom_add_char_keeping_current_mode ;2F14; the INPUT line. This is done by calling
                                ; into the 'ADD_CHAR' subroutine.
  pop  hl                  ;2F16; Restore address of service routine and
  jr   d_input1            ;2F17; read the next byte.

d_input2:
  pop  hl                  ;2F19; Drop the address of the service routine
  jp   unpage_1            ;2F1A; and page-out the +D system.

; Now deal with the reading of a single byte.

d_inkey_dollar:
  pop  hl                  ;2F1D; Restore address of the servce routine.
  ld   de,d_inkey_dollar_end ;2F1E; Return address is 'D_INK$_END' below.
  push de                  ;2F21;
  jp   (hl)                ;2F22; Jump to the service routine.

d_inkey_dollar_end:
  ret  c                   ;2F23; Return with acceptable codes or
  ret  z                   ;2F24; with no byte read.
  call test_2              ;2F25; Give the 'END of file' error if not
  jp   z,rep_27            ;2F28; executing a 'MOVE' command.
  or   1                   ;2F2B; Otherwise return with Zero and Carry
  ret                      ;2F2D; flags both reset.

; ----------------------------------------------
; THE '"D" CHANNEL INPUT' SERVICE ROUTINE

; This is the actual input a byte from disk routine. The byte is read from the
; data buffer in the channel, when it is empty the next sector is read from
; disk (provided that the 'current' data block is not the EOF one) before
; reading the byte.

dchan_in:
  bit  0,(ix+12)           ;2F2E; Give 'Reading a WRITE file' error if
  jp   nz,rep_18           ;2F32; it's an OUTput channel.
  ld   a,(ix+31)           ;2F35; Decrease LSB of file length.
  sub  1                   ;2F38;
  ld   (ix+31),a           ;2F3A;
  jr   nc,dchan_in1        ;2F3D; Jump if more bytes left.
  ld   a,(ix+32)           ;2F3F; Decrease MID byte of file length.
  sub  1                   ;2F42;
  ld   (ix+32),a           ;2F44;
  jr   nc,dchan_in1        ;2F47; Jump if more bytes left.
  ld   a,(ix+18)           ;2F49; Decrease MSB of file length.
  sub  1                   ;2F4C;
  ld   (ix+18),a           ;2F4E;
  jr   nc,dchan_in1        ;2F51; Jump if more bytes left.
  xor  a                   ;2F53; Otherwise EOF has been reached, so
                                ; reset Zero and Carry flag to signal
                                ; 'End Of File'.
  add  a,13                ;2F54; The return byte is 13.
  ret                      ;2F56; Finished.

; NOTE: This 'end of file' test works only once, if an attempt is made to read
; more bytes after the 'End of FILE' message has been given a crash will
; almost certainly follow.

dchan_in1:
  ; XXX FIXME -- the original HTML has a typo in the label above
  call lbyt                ;2F57; Load one byte, read a new sector from
                                ; disk when the buffer is empty.
  call bord_rest           ;2F5A; Restore border colour.
  scf                      ;2F5D; Signal 'acceptable code'.
  ret                      ;2F5E;

; ----------------------------------------------
; THE '"D" CHANNEL OUTPUT' ROUTINE

; The routine which handles "D" channel output is quite short. It SAVEs the
; byte in the A register to disk by calling the ROM 'SBYT' routine, which
; handles the saving of the byte.  The only thing done here is incrementing
; the file length bytes.

dchan_out:
  ld   ix,(23633)          ;2F5F; IX point to current channel (CURCHL).
  bit  0,(ix+12)           ;2F63; Give 'Writing a READ file' error if
  jp   z,rep_19            ;2F67; it's an INput channel.
  call sbyt                ;2F6A; Save the byte in the A register.
  call bord_rest           ;2F6D; Restore the border colour.
  nop                      ;2F70;
  nop                      ;2F71;
  nop                      ;2F72;
  nop                      ;2F73;
  push ix                  ;2F74;
  ld   bc,229              ;2F76;
  add  ix,bc               ;2F79; IX now points to the file header.
  inc  (ix+2)              ;2F7B; Update file length, skip higher bytes
  jr   nz,dchan_out1       ;2F7E; if it isn't necessary to update them.
  inc  (ix+3)              ;2F80;
  jr   nz,dchan_out1       ;2F83;
  inc  (ix+0)              ;2F85;
dchan_out1:
  pop  ix                  ;2F88;
  ret                      ;2F8A; Finished.


; ===============================================================
; The Command code routines

; ----------------------------------------------
; THE 'TRANSFER UFIA TO DFCA' SUBROUTINE

; This subroutine is called by using command code 51 ($33), it transfers the
; file description and header (UFIA) to the Disk File Channel Area (DFCA). On
; entry IX must point to the start of the User's File Information Area (UFIA).

hxfer:
  push ix                  ;2F8B;
  pop  hl                  ;2F8D;
  ld   de,ufia1            ;2F8E; Start of 'UFIA1'.
  ld   bc,24               ;2F91;
  ldir                     ;2F94; Transfer the UFIA to 'UFIA1'.
  ld   ix,dfca             ;2F96;
  call test_drive.ufia1    ;2F9A; Check if the specified drive is
  ret                      ;2F9D; defined.

; ----------------------------------------------
; THE 'OPEN FILE SECTOR MAP' SUBROUTINE

; This subroutine is called by using command code 52 ($34), it Opens a File
; Sector Map with the information contained in the DFCA. On entry IX must
; point to the UFIA, a call to 'HXFER' above transfers the UFIA to the DFCA. A
; return is made with the disk buffer pointer (RPT) set to the start of the
; disk buffer in the +D RAM. 'OFSM' should be used for files which don't
; contain a 9 byte header at the start of the file.

ofsm:
  call hxfer               ;2F9E; Transfer UFIA to DFCA.
  jp   ofsm_2              ;2FA1; Open the file sector map.

; ----------------------------------------------
; THE 'OPEN A FILE' SUBROUTINE

; This subroutine is called by using command code 53 ($35), it opens a file
; for SAVEing.  As with the preceeding subroutines IX must point to the UFIA.
; By calling 'OFSM' above the UFIA is transferred to the DFCA and the file
; sector map is opened. Finally 'SAVE_HEAD1' is called to transfer the 9 bytes
; file header to the file. 'HOFLE' can be used for files which contain the 9
; byte header.

hofle:
  call ofsm                ;2FA4; Transfer UFIA to DFCA and open the file
                                ; sector map.
  call save_head1          ;2FA7; Transfer the 9 byte file header to the
  ret                      ;2FAA; file and exit.

; ----------------------------------------------
; THE 'SAVE BLOCK TO DISK' SUBROUTINE

; This is called by using command code 55 ($37). The data block starting at
; address DE with length BC is SAVEd to disk.  NOTE: A file has to be opened
; for SAVEing before writing bytes. Use 'HOFLE' or 'OFSM' to do this.

hsvbk:
  call bcde_dehl           ;2FAB; Transfer BC to DE and DE to HL.
  jp   hsvbk_2             ;2FAE; Save the block.

; ----------------------------------------------
; THE 'GET A FILE FROM DISK' SUBROUTINE

; This is called by using command code 59 ($3B), it opens a file for LOADing.
; The IX register must point to the start of the UFIA. The return is made with
; the first sector of the file loaded into the disk buffer and RPT pointing to
; the first byte (usually the start of the 9 byte file header).

hgfle:
  call hxfer               ;2FB1; Transfer the UFIA to the DFCA.
  jp   hgfle_2             ;2FB4; Open the file and load the first sector
                                ; in the disk buffer.

; ----------------------------------------------
; THE 'LOAD BLOCK FROM DISK' SUBROUTINE

; This subroutine is called by using command code 61 ($3D), it does the
; opposite of 'HSVBK' above. The data block starting at address DE with length
; BC is LOADed from disk.  NOTE: The file has to be opened by using 'HGFLE'
; before an attempt can be made to LOAD bytes. Don't try to LOAD more bytes
; than available.

hldbk:
  call bcde_dehl           ;2FB7; Transfer BC to DE and DE to HL.
  jp   load_file           ;2FBA; Load the block.

; ----------------------------------------------
; THE 'ERASE A FILE' SUBROUTINE

; This is called by using command code 65 ($41). It ERASEs one file on the
; disk (even when wildcards were used), using the information contained in the
; UFIA, so make sure that IX points to the start of it.

heraz:
  call hxfer               ;2FBD; Transfer the UFIA to the DFCA.
  call find_file_2559      ;2FC0; Find the file, HL points to the
                                ; directory entry of the file (contained
                                ; in the disk buffer).
  jp   nz,rep_26           ;2FC3; Give error if file not found.
  ld   (hl),0              ;2FC6; Directory description 0 means ERASEd.
  jp   wsad                ;2FC8; Write sector DE.

; ----------------------------------------------
; THE 'BC TO DE AND DE TO HL' SUBROUTINE

; This routine transfers the contents of BC to DE and that of DE to HL, it
; also sets IX to the start of the DFCA.

bcde_dehl:
  push de                  ;2FCB;
  push bc                  ;2FCC;
  pop  de                  ;2FCD;
  pop  hl                  ;2FCE;
  ld   ix,dfca             ;2FCF;
  ret                      ;2FD3;

; ----------------------------------------------
; THE 'READ SECTOR TO ADDRESS' SUBROUTINE

; This routine is called by using command code 68 ($44). It reads sector DE
; from drive A to the address held in the IX register.

hrsad:
  push bc                  ;2FD4;
  push ix                  ;2FD5;
  ld   ix,dfca             ;2FD7;
  call test_drive.ufia1    ;2FDB; See if the drive held in the A register
                                ; is defined.
  call rsad                ;2FDE; Load the sector into the disk buffer.
  pop  hl                  ;2FE1;
  push de                  ;2FE2;
  ld   de,$3BD6            ;2FE3; Start of disk buffer.
  ex   de,hl               ;2FE6;
  ld   bc,512              ;2FE7; Sector length.
  ldir                     ;2FEA; Move sector to specified address.
  push de                  ;2FEC;
  pop  ix                  ;2FED; Update IX.
  pop  de                  ;2FEF; Restore DE and BC.
  pop  bc                  ;2FF0;
  ret                      ;2FF1;

; ----------------------------------------------
; THE 'WRITE SECTOR FROM ADDR.' SUBROUTINE

; This is called using command code 69 ($45), it writes sector DE to drive A
; starting from address IX.

hwsad:
  push bc                  ;2FF2;
  push ix                  ;2FF3;
  pop  hl                  ;2FF5;
  ld   ix,dfca             ;2FF6;
  call test_drive.ufia1    ;2FFA; See if the drive held in the A register
  push de                  ;2FFD; is defined.
  ld   de,$3BD6            ;2FFE;
  ld   bc,512              ;3001; Sector length.
  ldir                     ;3004; Move BC bytes to the disk buffer.
  pop  de                  ;3006;
  push hl                  ;3007;
  call wsad                ;3008; Write sector DE to disk.
  pop  ix                  ;300B;
  pop  bc                  ;300D;
  ret                      ;300E; Finished.

; ----------------------------------------------
; THE 'READ SECTOR DE' SUBROUTINE

; This routine is called using command code 63 ($3F), it loads sector DE from
; the current drive into the disk buffer.

jrsad:
  ld   ix,dfca             ;300F;
  jp   rsad                ;3013; Load the sector.

; ----------------------------------------------
; THE 'WRITE SECTOR DE' SUBROUTINE

; This is called using command code 62 ($3E), it saves the contents of the
; disk buffer into sector DE on the current drive.

jwsad:
  ld   ix,dfca             ;3016;
  jp   wsad                ;301A; Save the sector.


; ===============================================================
; Miscellaneous routines III

; ----------------------------------------------
; THE 'COPY SCREEN' ROUTINE

; This routine has two entry points. The first one, $301D, is used with the
; BASIC commands 'SAVE/LOAD/VERIFY/MERGE SCREEN$'. The second entry point
; ($3020) is used for the 'COPY' command itself. Depending on the parameter
; following the 'SCREEN$', the normal or the grey scale screen dump is used.

dump_scr:
  pop  hl                  ;301D; Drop the return address (within the
                                ; routine which called 'EXPT_PARMS').
  jr   copy_1              ;301E; Jump forward.

copy:
  rst  next_c              ;3020; Advance CH_ADD.
  cp   token.screen_dollar ;3021; Give 'Nonsense in G+DOS' error if
  jp   nz,rep_0            ;3023; command isn't followed by 'SCREEN$'.
copy_1:
  ld   a,"1"               ;3026; Default is '1' for 'normal' dump.
  ld   ($3E00),a           ;3028;
  rst  next_c              ;302B; Advance CH_ADD
  cp   13                  ;302C;
  jr   z,copy_2            ;302E; Jump with ENTER.
  cp   ":"                 ;3030;
  jr   z,copy_2            ;3032; Also jump with ':'.
  ld   ($3E00),a           ;3034; Otherwise store character.
  rst  next_c              ;3037; Update CH_ADD again.
copy_2:
  call st_end_ram          ;3038; Confirm end of statement and exit
                                ; during syntax checking.
  ld   a,($3E00)           ;303B;
  cp   "1"                 ;303E; Normal screendump if '1' followed the
  call z,cops              ;3040; 'SCREEN$'.
  cp   "2"                 ;3043; Grey scale in case of a '2'.
  call z,cops2             ;3045; Ignore other values.
  jp   the_end             ;3048; Finished.


; ===============================================================
; The system message routines

; Finally there follow some messages. A message follows directly after the
; CALL to the ROM print routine.

msg_0:
  call po_msg1             ;304B;
  defm "* MGT PLUS D DISC" ;304E;
  defb " "+128             ;3060;
msg_1:
  call po_msg1             ;3061;
  defm " CATALOGUE *"      ;3064;
  defb 13,13+128           ;3070;
msg_2:
  call po_msg1             ;3072;
  defb 13,13               ;3075;
  defb "Number of Free K-Bytes =";3077;
  defb " "+128             ;308F;
msg_3:
  call po_msg              ;3090;
  defm "©Miles Gordon Technology G+DOS2a";3093;
  defb 13,13+128           ;30B3;

; This routine makes sure the 'SOURCE' and 'TARGET' messages are printed in
; turn.

to_msg1:
  ld   a,($3107)           ;30B5;
  xor  $01                 ;30B8;
  ld   ($3107),a           ;30BA;
  jr   nz,msg_5            ;30BD;
msg_4:
  call po_msg1             ;30BF;
  defb 13                  ;30C2;
  defm "Insert SOURCE disc - press SPAC"
  defb "E"+128             ;30E2;
msg_5:
  call po_msg1             ;30E3;
  defb 13                  ;30E6;
  defm "Insert TARGET disc - press SPAC"
  defb "E"+128             ;3106;

  defb $00                 ;3107;

; ----------------------------------------------
; THE 'CLEAR MESSAGE FLAG' SUBROUTINE


test_save:
  xor  a                   ;3108; Clear the flag used in printing
  ld   ($3107),a           ;3109; 'SOURCE' and 'TARGET' message.
  call test_5              ;310C;
  ret                      ;310F;


; ===============================================================
; The patches

; ----------------------------------------------
; THE 'OPENTYPE FILE OPEN/CLOSE' ROUTINE

; This routine opens or closes an opentype file according to the contents of
; the A register. When it holds 0 a "D" channel is attached to the stream
; given in the DFCA. A non zero value closes the corresponding stream.

otfoc:
  and  a                   ;3110;
  jp   z,open_chan         ;3111; Open a channel if A holds zero.
  jp   close_strm          ;3114; Otherwise close the stream.

; ----------------------------------------------
; THE 'CLOSE #' PATCH

; This patch cures the bug related to CLOSEing 'OPENTYPE' files. Before the
; file is CLOSEd first the correct drive settings are send to the FDC.

cl_patch:
  ld   e,(ix+17)           ;3117; Fetch sector and track.
  ld   d,(ix+18)           ;311A;
  ld   a,(ix+11)           ;311D; Fetch drive number.
  ld   (dfca.drive),a      ;3120;
  call set_drvsd           ;3123; Select track, sector, side and drive.
  call cfsm                ;3126; Close the file sector map.
  ret                      ;3129; Finished.

; ----------------------------------------------
; THE 'OPEN TEMPORARY OUTPUT' PATCH

; This patch gives an error report when an attempt is made to open an existing
; OUTput file using a command code. A jump back to the 'open a temporary
; channel' routine is made if not using a command code.

op_t_patch:
  push hl                  ;312A;
  ld   hl,(d_err_sp)       ;312B;
  ld   a,h                 ;312E;
  or   l                   ;312F; Jump back to the 'OP_TEMP' routine if
  pop  hl                  ;3130; 'D_ERR_SP' is zero (this isn't the case
  jp   z,op_temp6          ;3131; during command code execution).
  jp   rep_28              ;3134; Otherwise give 'File NAME used' error.

; ----------------------------------------------
; THE 'NEW' PATCH

; When the file copy command is finished the +D jumps to the 'NEW' routine.
; With System 2a a selection is made for 48K or 128K 'NEW'

to_new:
  bit  4,(iy+1)            ;3137; Jump if not in 128K mode HL contains
  jp   z,unpage_hl         ;313B; $11B7, the address of 48K 'NEW'.
  call rom_swap            ;313E; Call the paging subroutine of the 128.
  di                       ;3141;
  ld   bc,rom_128_new      ;3142; Address of 128 'NEW' routine.
  jp   unpage_bc           ;3145;

; ----------------------------------------------
; THE 'END OF STATEMENT' ROUTINE

; It isn't clear why IX should point to $000C during syntax checking.

st_end_ram:
  ld   ix,$000C            ;3148;
  call st_end              ;314C;
  ld   ix,dfca             ;314F;
  ret                      ;3153;

; ----------------------------------------------
; THE 'PCAT' ROUTINE

; This routine is called by using command code 67, in System 2a the command
; code works.

pcat:
  call test_drive.ufia1    ;3154; Drive defined?
  ld   a,(ufia1.hd00)      ;3157; Get 'CAT' type.
  jp   cat_run             ;315A; Do the CAT.

  defs $39FF-$315D+1 ; $315D..$39FF Unused locations (all set to $00).

; ----------------------------------------------
; Disk bitmap

disk_bitmap_size: equ 1560/8 ; 1560 bits, 195 bytes

  org $3A00
disk_bitmap:
  defs disk_bitmap_size

; ----------------------------------------------
; Disk File Channel Area (DFCA)

  org $3AC3

dfca:
  defw 0  ;3AC3; +0: length of file in sectors
dfca.left:
  defw 0  ;3AC5; +2: bytes left to load or save
               ;     also used as temporary storage
  defb 0  ;3AC7; +4: scan type flags (bits set):
                ;
                ; bit 0 : Search for the file with the specified program number.
                ;
                ; bit 1 : Print a 'names only' CATalogue to the current stream. A
                ; filename must be specified.
                ;
                ; bit 2 : Print an 'extended' CATalogue to the current stream. A
                ; filename has to be specified.
                ;
                ; bit 3 : Search for a file with the specified type and name.
                ;
                ; bit 4 : Search for a file with the specified filename.
                ;
                ; bit 5 : Produce the disk bitmap.
                ;
                ; bit 6 : Find the first unused entry.
                ;
                ; Note that some functions exclude others.
dfca.addr:
  defw 0  ;3AC8; +5: load/save address
               ;     also used as temporary storage
dfca.buflen:
  defw 0  ;3ACA; +7: length of data buffer
  defw 0  ;3ACC; +9
dfca.drive:
  defb 0  ;3ACE; +11: hardware representation of the drive being used
                        ; 1 or 2
flags3:
  defb 0  ;3ACF; +12: FLAGS3:
               ; the bits are set by routines `sign_0`, `sign_1`, etc.,
               ; and tested by routines `test_0`, `test_1`, etc.
                        ; bit 7 : 1=verifyng
                        ; bit 6 : 1=merging
                        ; bit 5 : 1=saving
                        ; bit 4 : 1=a second filename was given
                        ;       : 1=use source filename for destination file
                        ;       : 1=loading
                        ; bit 3 : 1=using network
                        ; bit 2 : 1=moving (?)
                        ;       : 1=don't generate the 'END of file' error
                        ; bit 1 : 1=`CLEAR #`, i.e. erase the remaining buffer contents
                        ;            when a stream is closed
                        ; bit 0 : 1=at least one file has been copied or erased

rpt:
  ; RPT (RamPoinTer) - A system variable which points to a byte in the DRAM:
  defb 0  ;3AD0; +13: RPT-lo
  defb 0  ;3AD1: +14: RPT-hi

  defw 0  ;3AD2; +15

  defw 0  ;3AD4; +17: XXX TODO -- track and sector number, backup?

; ----------------------------------------------
  org $3AD6

file_descriptor: ; XXX TMP -- directory description/entry?

fd_file_type:
  defb 0 ; +0

fd_file_name:
  defs 10 ; +1, name padded with spaces

fd_file_sectors:
  defw 0 ; +11, number of sectors occupated by the file (in Motorola byte order)

fd_track:
  defb 0  ; +13, track number of the first sector of the file

fd_sector:
  defb 0 ; +14, sector number of the first sector of the file

fd_sector_allocation_bitmap:
  defs 195 ; 15-209, sector allocation bitmap.  

  ; Each bit corresponds to a disk sector.  A bit is set if the corresponding
  ; sector belong to the file.  Examples: byte 15, bit 0 corresponds to track
  ; 4, sector 1; byte 16, bit 3 means track 5, sector 2...
  ;
  ; IMPORTANT NOTE: The s.a.b. is used only during saving operations: the
  ; s.a.b. of all the 80 files are merged together (OR) so that the system
  ; knows which sectors are free (not allocated to any file).  During loading a
  ; faster method is used: each sector contains only 510 bytes of data; the
  ; last two bytes contain the track number and the sector number of the next
  ; sector of the file, respectively. The last sector of the chain contains
  ; (0,0) as the last two bytes.

fd_unused:
  defs 46 ; 210-255, depend on the file type.

; ----------------------------------------------
  org $3BD6

sector_buffer:

  defs 256

; ----------------------------------------------
; Buffer for EXECUTE (type 11) files

  org $3DB6

  defs 510

; ----------------------------------------------
; Internal variables

  org $3DD6
d_ch_add:
  defw 0                   ;3DD6;
sectors_used:
  defw 0                   ;3DD8;
control_port_status:
  defb 0                   ;3DDA; control port status (of port 239)

  org $3DE4

system_status.minimal: equ $58 ; 'X'
system_status.loaded:  equ $44 ; 'D'

system_status:
  defb 0                   ;3DE4; 'X' ($58) = minimal system
                                ; 'D' ($44) = system loaded
calbas_flag:
  defb 0                   ;3DE5; 'G' ($47) = CALBAS executing;
                                ; zero otherwise

  org $3DEF
mapused:
  defb 0                   ;3DEF; Number of files which are using
                                ; the disk bitmap. When it reaches 0
                                ; the bitmap has to be rebuild.

; ----------------------------------------------
; UFIA1 (User File Information Area 1)

  org $3E01

ufia1:

  ; XXX TODO -- check; replace literals with field symbols

ufia1.dstr1:
  defb 0                   ;3E01; drive: 1, 2 or '*'
ufia1.fstr1:
  defb 0                   ;3E02; file directory number
ufia1.sstr1:
  defb 0                   ;3E03; stream number
ufia1.lstr1:
  defb 0                   ;3E04; device: "D" or "d"
ufia1.nstr1:
  defb 0                   ;3E05; directory description
ufia1.nstr2:
  defs 10                  ;3E06; file name
ufia1.hd00:
  defb 0                   ;3E10; file type
ufia1.hd0b:
  defw 0                   ;3E11; file length
ufia1.hd0d:
  defw 0                   ;3E13; file start address
ufia1.hd0f:
  defw 0                   ;3E15; BASIC length without variables
ufia1.hd11:
  defw 0                   ;3E17; BASIC autorun line

; ----------------------------------------------
; UFIA2 (User File Information Area 2)

  org $3E1A

ufia2:

  ; XXX TODO -- check; replace literals with field symbols

ufia2.dstr1:
  defb 0                   ;3E1A; drive: 1, 2 or '*'
ufia2.fstr1:
  defb 0                   ;3E1B; file directory number
ufia2.sstr1:
  defb 0                   ;3E1C; stream number
ufia2.lstr1:
  defb 0                   ;3E1D; device: "D" or "d"
ufia2.nstr1:
  defb 0                   ;3E1E; directory description
ufia2.nstr2:
  defs 10                  ;3E1F; file name
ufia2.hd00:
  defb 0                   ;3E29; file type
ufia2.hd0b:
  defw 0                   ;3E2A; file length
ufia2.hd0d:
  defw 0                   ;3E2C; file start address
ufia2.hd0f:
  defw 0                   ;3E2E; BASIC length without variables
ufia2.hd11:
  defw 0                   ;3E30; BASIC autorun line

; ----------------------------------------------
; Internal stack

  org $3FFE

sp_backup:
internal_stack:
  defw 0 ; copy of SP
  ; ... internal stack here, grows towards high memory
  ; ... size unknown

; ----------------------------------------------

  end

; vim: filetype=z80
